<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBGè¡¨æ ¼QCæ£€éªŒå·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            background: #f8f9fa;
            display: flex;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 20px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            color: #495057;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #f8f9fa;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab:hover:not(.active) {
            background: #dee2e6;
        }

        .tab-content {
            display: none;
            padding: 40px;
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-box:hover {
            border-color: #764ba2;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .upload-box:hover::before {
            opacity: 1;
        }

        .upload-box > * {
            position: relative;
            z-index: 1;
        }

        .upload-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .upload-box input[type="file"] {
            margin: 15px 0;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            width: 100%;
        }

        .file-info {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #666;
        }

        .check-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .check-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .check-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            margin-top: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .results h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }

        .check-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .check-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .check-item .item-name {
            font-weight: bold;
            color: #333;
            flex: 1;
        }

        .check-item .item-values {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #666;
            margin: 0 20px;
            text-align: center;
            flex: 2;
        }

        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .status.pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .summary {
            margin-top: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            text-align: center;
        }

        .summary h4 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-number.pass {
            color: #28a745;
        }

        .stat-number.fail {
            color: #dc3545;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 40px;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tab-content {
                padding: 20px;
            }

            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š MBGè¡¨æ ¼QCæ£€éªŒå·¥å…·</h1>
            <p>æ”¯æŒåŸºå‡†è¡¨ä¸æ£€éªŒè¡¨çš„æ™ºèƒ½æ•°æ®å¯¹æ¯”</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('basic-qc', this)">åŸºç¡€æ•°æ®æ£€éªŒ</button>
            <button class="tab" onclick="switchTab('tech-spec', this)">æŠ€æœ¯è§„æ ¼æ£€éªŒ</button>
        </div>

        <!-- åŸºç¡€QCæ£€éªŒ -->
        <div id="basic-qc" class="tab-content active">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>ğŸ“‹ åŸºå‡†è¡¨ (Tech Spec)</h3>
                    <input type="file" id="fileA" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"POR"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileAInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>ğŸ” æ£€éªŒè¡¨ (Offering)</h3>
                    <input type="file" id="fileB" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"MTM_MMR"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileBInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnBasic" onclick="performBasicQC()" disabled>
                å¼€å§‹åŸºç¡€æ•°æ®æ£€éªŒ
            </button>
            
            <div id="basicResults" class="results" style="display: none;">
                <h3>ğŸ” åŸºç¡€æ•°æ®æ£€éªŒç»“æœ</h3>
                <div id="basicCheckResults"></div>
                <div id="basicSummary" class="summary"></div>
            </div>
        </div>

        <!-- æŠ€æœ¯è§„æ ¼åŒ¹é… -->
        <div id="tech-spec" class="tab-content">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>ğŸ“‹ åŸºå‡†è¡¨ (Tech Spec)</h3>
                    <input type="file" id="fileBaseline" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"Tech Spec"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileBaselineInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>ğŸ” æµ‹è¯•æ–‡ä»¶ (mtmElement)</h3>
                    <input type="file" id="fileTest" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"OBJECT-ELEMENT"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileTestInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnTech" onclick="performTechSpecMatch()" disabled>
                å¼€å§‹æŠ€æœ¯è§„æ ¼åŒ¹é…
            </button>
            
            <div id="techResults" class="results" style="display: none;">
                <h3>ğŸ”  æŠ€æœ¯è§„æ ¼åŒ¹é…ç»“æœ</h3>
                <div id="productInfo" style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                    <strong>äº§å“åç§°:</strong> <span id="productName"></span>
                </div>
                <div id="techCheckResults"></div>
                <div id="techSummary" class="summary"></div>
            </div>
        </div>
            
        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let fileAData = null;
        let fileBData = null;
        let fileBaselineData = null;
        let fileTestData = null;

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId, element) {
            // éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„activeç±»
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ˜¾ç¤ºç›®æ ‡æ ‡ç­¾å†…å®¹
            document.getElementById(tabId).classList.add('active');
            
            // æ¿€æ´»ç›®æ ‡æ ‡ç­¾
            element.classList.add('active');
            
            // éšè—é”™è¯¯æ¶ˆæ¯
            hideError();
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // éšè—é”™è¯¯æ¶ˆæ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ===================åŸºç¡€QCæ£€éªŒåŠŸèƒ½===================
        
        // æ—¥æœŸæ ¼å¼æ ‡å‡†åŒ–å‡½æ•°
        function normalizeDate(value) {
            if (!value) return value;
            
            // å¦‚æœæ˜¯Excelæ—¥æœŸæ•°å­—ï¼Œè½¬æ¢ä¸ºæ—¥æœŸå¯¹è±¡
            if (typeof value === 'number' && value > 25000 && value < 100000) {
                try {
                    // Excelæ—¥æœŸè½¬æ¢
                    const date = XLSX.SSF.parse_date_code(value);
                    return `${date.y}-${String(date.m).padStart(2, '0')}-${String(date.d).padStart(2, '0')}`;
                } catch (e) {
                    return value;
                }
            }
            
            // å¦‚æœå·²ç»æ˜¯å­—ç¬¦ä¸²æ—¥æœŸï¼Œå°è¯•æ ‡å‡†åŒ–æ ¼å¼
            if (typeof value === 'string') {
                // åŒ¹é… YYYY-MM-DD æ ¼å¼
                let dateMatch = value.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
                if (dateMatch) {
                    const [, year, month, day] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
                
                // åŒ¹é… MM/DD/YYYY æ ¼å¼
                dateMatch = value.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (dateMatch) {
                    const [, month, day, year] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
            }
            
            return value;
        }

        // å›½å®¶åˆ—è¡¨æ¯”è¾ƒå‡½æ•°ï¼ˆé¡ºåºæ— å…³ï¼‰
        function compareCountryLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå›½å®¶ä»£ç æ•°ç»„
            const countries1 = String(val1).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            const countries2 = String(val2).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            
            // æ’åºåæ¯”è¾ƒ
            countries1.sort();
            countries2.sort();
            
            const isMatch = countries1.length === countries2.length && 
                   countries1.every((country, index) => country === countries2[index]);
            
            // å¦‚æœä¸åŒ¹é…ï¼Œè®¡ç®—å·®å¼‚ä¿¡æ¯
            if (!isMatch) {
                const missing = countries1.filter(c => !countries2.includes(c));
                const extra = countries2.filter(c => !countries1.includes(c));
                
                let diffMessage = '';
                if (missing.length > 0) {
                    diffMessage += `Bè¡¨ç¼ºå¤±: ${missing.join(', ')}`;
                }
                if (extra.length > 0) {
                    if (diffMessage) diffMessage += '; ';
                    diffMessage += `Bè¡¨å¤šå‡º: ${extra.join(', ')}`;
                }
                
                // å°†å·®å¼‚ä¿¡æ¯å­˜å‚¨åœ¨å…¨å±€å˜é‡ä¸­ï¼Œä¾›æ˜¾ç¤ºæ—¶ä½¿ç”¨
                compareCountryLists.lastDiffMessage = diffMessage;
            } else {
                compareCountryLists.lastDiffMessage = null;
            }
            
            return isMatch;
        }

        // Audienceæ¯”è¾ƒå‡½æ•°ï¼ˆåˆ†å‰²ååŒ¹é…ï¼‰
        function compareAudienceLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºAudienceæ•°ç»„ï¼Œæ”¯æŒé€—å·å’Œç©ºæ ¼åˆ†éš”
            const audience1 = String(val1).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            const audience2 = String(val2).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            
            // æ’åºåæ¯”è¾ƒ
            audience1.sort();
            audience2.sort();
            
            return audience1.length === audience2.length && 
                   audience1.every((audience, index) => audience === audience2[index]);
        }

        // é€šç”¨å€¼æ¯”è¾ƒå‡½æ•°
        function compareValues(val1, val2, convertFunc = null, customCompareFunc = null) {
            // å¦‚æœæä¾›äº†è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨
            if (customCompareFunc) {
                return customCompareFunc(val1, val2);
            }
            
            // åº”ç”¨è½¬æ¢å‡½æ•°ï¼ˆå¦‚æœæä¾›ï¼‰
            if (convertFunc) {
                val1 = convertFunc(val1);
                val2 = convertFunc(val2);
            }
            
            // å¤„ç†ç©ºå€¼
            if (val1 === null || val1 === undefined || val1 === '') {
                val1 = '';
            }
            if (val2 === null || val2 === undefined || val2 === '') {
                val2 = '';
            }
            
            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
            return String(val1).trim() === String(val2).trim();
        }

        // åŸºç¡€QCåŠŸèƒ½ä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ
        function findMatchingRowInPORBasic(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number(åŸºç¡€QC):', testPartNumber);
            
            // ä»B2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾,ç›´åˆ°Båˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // å¦‚æœBåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Båˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    return row;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯,æœ€å¤šæŸ¥æ‰¾1000è¡Œ
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        // åœ¨åŸºå‡†è¡¨PORä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ(ç”¨äºæŠ€æœ¯è§„æ ¼æ£€éªŒ)
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number(æŠ€æœ¯è§„æ ¼):', testPartNumber);
            
            // ä»E2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾,ç›´åˆ°Eåˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const eCell = `E${row}`;
                const partNumber = sheetPOR[eCell] ? String(sheetPOR[eCell].v).trim() : '';
                
                // å¦‚æœEåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Eåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    
                    // è·å–è¯¥è¡Œçš„ç›¸å…³æ•°æ®
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('åŒ¹é…è¡Œæ•°æ®:', rowData);
                    return rowData;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯,æœ€å¤šæŸ¥æ‰¾1000è¡Œ
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        // åŸºç¡€QCæ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('fileA').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileAData = workbook;
                        
                        document.getElementById('fileAInfo').style.display = 'block';
                        document.getElementById('fileAInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æ–‡ä»¶Aå¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æ–‡ä»¶Aæ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileB').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBData = workbook;
                        
                        document.getElementById('fileBInfo').style.display = 'block';
                        document.getElementById('fileBInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æ–‡ä»¶Bå¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æ–‡ä»¶Bæ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkBasicButtonState() {
            const btn = document.getElementById('checkBtnBasic');
            if (fileAData && fileBData) {
                btn.disabled = false;
            }
        }

        function performBasicQC() {
            try {
                hideError();
                
                if (!fileAData.SheetNames.includes('POR')) {
                    throw new Error('åŸºå‡†è¡¨(Aè¡¨)ä¸­æœªæ‰¾åˆ°"POR"å·¥ä½œè¡¨');
                }
                
                if (!fileBData.SheetNames.includes('MTM_MMR')) {
                    throw new Error('æ£€éªŒè¡¨(Bè¡¨)ä¸­æœªæ‰¾åˆ°"MTM_MMR"å·¥ä½œè¡¨');
                }
                
                const sheetA = fileAData.Sheets['POR'];
                const sheetB = fileBData.Sheets['MTM_MMR'];
                
                // 1. éå†æ£€éªŒè¡¨çš„Båˆ—,ä»B7å¼€å§‹,æ”¶é›†æ‰€æœ‰Part Number
                const testPartNumbers = [];
                let testRow = 7;
                
                console.log('å¼€å§‹éå†æ£€éªŒè¡¨Båˆ—,æ”¶é›†Part Numbers...');
                
                while (true) {
                    const bCell = `B${testRow}`;
                    const partNumber = sheetB[bCell] ? String(sheetB[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        console.log(`æ£€éªŒè¡¨B${testRow}ä¸ºç©º,åœæ­¢éå†`);
                        break;
                    }
                    
                    console.log(`æ£€éªŒè¡¨B${testRow}: Part Number = "${partNumber}"`);
                    testPartNumbers.push({
                        partNumber: partNumber,
                        testRow: testRow
                    });
                    
                    testRow++;
                    
                    if (testRow > 1000) {
                        console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢éå†');
                        break;
                    }
                }
                
                console.log(`å…±æ‰¾åˆ°${testPartNumbers.length}ä¸ªPart Numberéœ€è¦æ£€éªŒ`);
                
                if (testPartNumbers.length === 0) {
                    throw new Error('æ£€éªŒè¡¨ä¸­æœªæ‰¾åˆ°ä»»ä½•Part Number(ä»B7å¼€å§‹)');
                }
                
                // 2. å¯¹æ¯ä¸ªPart Numberè¿›è¡Œæ£€éªŒ
                let allResults = [];
                let totalPassCount = 0;
                let totalFailCount = 0;
                
                testPartNumbers.forEach((testInfo, index) => {
                    console.log(`\n====== æ£€éªŒç¬¬${index + 1}ä¸ªPart Number: ${testInfo.partNumber} (æ£€éªŒè¡¨ç¬¬${testInfo.testRow}è¡Œ) ======`);
                    
                    let matchedRow = null;
                    const foundRow = findMatchingRowInPORBasic(sheetA, testInfo.partNumber);
                    
                    if (foundRow !== null) {
                        matchedRow = foundRow;
                        console.log(`æ‰¾åˆ°åŒ¹é…çš„Part Number,ä½¿ç”¨åŸºå‡†è¡¨ç¬¬${matchedRow}è¡Œæ•°æ®`);
                    } else {
                        console.log(`æœªæ‰¾åˆ°åŒ¹é…çš„Part Number: ${testInfo.partNumber}`);
                        allResults.push({
                            partNumber: testInfo.partNumber,
                            testRow: testInfo.testRow,
                            matchedRow: null,
                            checks: [],
                            notFound: true
                        });
                        totalFailCount++;
                        return;
                    }
                    
                    const checks = [
                        {
                            name: 'Part Number',
                            cellA: `B${matchedRow}`,
                            cellB: `B${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Mkt Description',
                            cellA: `D${matchedRow}`,
                            cellB: `Y${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Audience',
                            cellA: `J${matchedRow}`,
                            cellB: `AB${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareAudienceLists
                        },
                        {
                            name: 'Country',
                            cellA: `G${matchedRow}`,
                            cellB: `AC${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareCountryLists
                        },
                        {
                            name: 'Annc Date',
                            cellA: `H${matchedRow}`,
                            cellB: `AE${testInfo.testRow}`,
                            converter: normalizeDate,
                            customCompareFunc: null
                        },
                        {
                            name: 'WW',
                            cellA: `K${matchedRow}`,
                            cellB: `AI${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        }
                    ];
                    
                    let checkResults = [];
                    let passCount = 0;
                    let failCount = 0;
                    
                    checks.forEach(check => {
                        const valueA = sheetA[check.cellA] ? sheetA[check.cellA].v : '';
                        const valueB = sheetB[check.cellB] ? sheetB[check.cellB].v : '';
                        
                        const isMatch = compareValues(valueA, valueB, check.converter, check.customCompareFunc);
                        
                        let displayValueA = valueA;
                        let displayValueB = valueB;
                        
                        if (check.converter) {
                            displayValueA = check.converter(valueA);
                            displayValueB = check.converter(valueB);
                        }
                        
                        if (check.customCompareFunc === compareCountryLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }

                        if (check.customCompareFunc === compareAudienceLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }
                        
                        checkResults.push({
                            name: check.name,
                            valueA: displayValueA,
                            valueB: displayValueB,
                            cellA: check.cellA,
                            cellB: check.cellB,
                            isMatch: isMatch,
                            diffMessage: check.customCompareFunc === compareCountryLists ? compareCountryLists.lastDiffMessage : null
                        });
                        
                        if (isMatch) {
                            passCount++;
                        } else {
                            failCount++;
                        }
                    });
                    
                    totalPassCount += passCount;
                    totalFailCount += failCount;
                    
                    allResults.push({
                        partNumber: testInfo.partNumber,
                        testRow: testInfo.testRow,
                        matchedRow: matchedRow,
                        checks: checkResults,
                        passCount: passCount,
                        failCount: failCount,
                        notFound: false
                    });
                });
                
                displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount);
                
            } catch (error) {
                showError(`æ£€éªŒè¿‡ç¨‹å‡ºé”™: ${error.message}`);
                console.error('åŸºç¡€QCæ£€éªŒé”™è¯¯:', error);
            }
        }
        
        function displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount) {
            const resultsDiv = document.getElementById('basicResults');
            const checkResultsDiv = document.getElementById('basicCheckResults');
            const summaryDiv = document.getElementById('basicSummary');
            
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    å…±æ£€éªŒ <span style="color: #2196f3; font-size: 20px;">${allResults.length}</span> ä¸ªPart Number
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            allResults.forEach((result, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                if (result.notFound) {
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">ğŸ“¦ Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">æ£€éªŒè¡¨ç¬¬${result.testRow}è¡Œ</small>
                            </div>
                            <div style="background: #dc3545; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                âŒ æœªæ‰¾åˆ°åŒ¹é…
                            </div>
                        </div>
                    `;
                    
                    const notFoundMsg = document.createElement('div');
                    notFoundMsg.style.cssText = `
                        background: #f8d7da;
                        color: #721c24;
                        padding: 15px;
                        border-radius: 8px;
                        margin-top: 10px;
                        border: 1px solid #f5c6cb;
                    `;
                    notFoundMsg.textContent = `âš ï¸ åœ¨åŸºå‡†è¡¨ä¸­æœªæ‰¾åˆ°Part Number "${result.partNumber}" çš„åŒ¹é…è¡Œ`;
                    
                    groupDiv.appendChild(headerDiv);
                    groupDiv.appendChild(notFoundMsg);
                } else {
                    const passRate = result.checks.length > 0 ? 
                        ((result.passCount / result.checks.length) * 100).toFixed(1) : 0;
                    
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">ğŸ“¦ Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">æ£€éªŒè¡¨ç¬¬${result.testRow}è¡Œ â†”ï¸ åŸºå‡†è¡¨ç¬¬${result.matchedRow}è¡Œ</small>
                            </div>
                            <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                é€šè¿‡ç‡: ${passRate}%
                            </div>
                        </div>
                    `;
                    
                    groupDiv.appendChild(headerDiv);
                    
                    const checksContainer = document.createElement('div');
                    checksContainer.style.cssText = `
                        margin-top: 15px;
                    `;
                    
                    result.checks.forEach(check => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'check-item';
                        itemDiv.style.cssText = `
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 15px 20px;
                            margin: 10px 0;
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                            transition: all 0.3s ease;
                        `;
                        
                        const statusClass = check.isMatch ? 'pass' : 'fail';
                        const statusText = check.isMatch ? 'PASS' : 'FAIL';
                        
                        let diffInfo = '';
                        if (!check.isMatch && check.diffMessage) {
                            diffInfo = `<br><small style="color: #dc3545; font-style: italic;">${check.diffMessage}</small>`;
                        }
                        
                        itemDiv.innerHTML = `
                            <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">${check.name}</div>
                            <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                                åŸºå‡†è¡¨(${check.cellA}): ${check.valueA || '(ç©º)'}<br>
                                æ£€éªŒè¡¨(${check.cellB}): ${check.valueB || '(ç©º)'}${diffInfo}
                            </div>
                            <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                        `;
                        
                        checksContainer.appendChild(itemDiv);
                    });
                    
                    groupDiv.appendChild(checksContainer);
                }
                
                checkResultsDiv.appendChild(groupDiv);
            });
            
            const totalCount = totalPassCount + totalFailCount;
            const totalPassRate = totalCount > 0 ? ((totalPassCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulParts = allResults.filter(r => !r.notFound && r.failCount === 0).length;
            const partialParts = allResults.filter(r => !r.notFound && r.failCount > 0).length;
            const notFoundParts = allResults.filter(r => r.notFound).length;
            
            summaryDiv.innerHTML = `
                <h4>æ€»ä½“æ£€éªŒæ±‡æ€»</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allResults.length}</span>
                        <div class="stat-label">æ€»Part Numberæ•°</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulParts}</span>
                        <div class="stat-label">å®Œå…¨é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialParts}</span>
                        <div class="stat-label">éƒ¨åˆ†é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number fail">${notFoundParts}</span>
                        <div class="stat-label">æœªæ‰¾åˆ°åŒ¹é…</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalPassCount}</span>
                            <div class="stat-label">æ€»é€šè¿‡é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalFailCount}</span>
                            <div class="stat-label">æ€»å¤±è´¥é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">æ€»é€šè¿‡ç‡</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        // ===================æŠ€æœ¯è§„æ ¼åŒ¹é…åŠŸèƒ½===================
        
        // æŠ€æœ¯è§„æ ¼æ˜ å°„è¡¨
        const techSpecMapping = {
            'Processor': 'PRC',
            'OS': 'OS',
            'Display': 'MON',
            'Storage': 'HD',
            'Memory': 'MEM',
            'Graphics': 'GRA',
            'Front Camera': 'CAM',
            'Back Camera': 'CAM',
            'Back': 'CAM',
            'Audio': 'AUD',
            'Fingerprint Reader': 'SEC',
            'Weight': 'PP',
            'Weight/Dimension': 'PP',
            'Dimension': 'PP',
            'Port': 'PORT',
            'Warranty': 'WAR',
            'Bluetooth': 'WS',
            'Wireless': 'WS',
            'What\'s in the box': 'MM',
            'Color': 'COLOR',
            'Battery Life': 'TI',
            'IMG': 'IMG'
        };

        // æŠ€æœ¯è§„æ ¼æ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('fileBaseline').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBaselineData = workbook;
                        
                        document.getElementById('fileBaselineInfo').style.display = 'block';
                        document.getElementById('fileBaselineInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–åŸºå‡†æ–‡ä»¶å¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–åŸºå‡†æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileTest').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileTestData = workbook;
                        
                        document.getElementById('fileTestInfo').style.display = 'block';
                        document.getElementById('fileTestInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æµ‹è¯•æ–‡ä»¶å¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æµ‹è¯•æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkTechButtonState() {
            const btn = document.getElementById('checkBtnTech');
            if (fileBaselineData && fileTestData) {
                btn.disabled = false;
            }
        }

        // ä»æŒ‡å®šåˆ—æå–åŸºå‡†è§„æ ¼æ•°æ®
        function extractBaselineSpecsForColumn(sheet, column) {
            const specs = {};
            
            console.log(`å¼€å§‹ä»åˆ—${column}æå–åŸºå‡†è§„æ ¼`);
            
            // ä»ç¬¬2è¡Œå¼€å§‹è¯»å–è§„æ ¼,ç›´åˆ°é‡åˆ°#EOFæˆ–è¶…å‡ºåˆç†èŒƒå›´
            let row = 2;
            const maxRows = 100;
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${column}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: å±æ€§="${attrName}", å€¼="${attrValue}"`);
                
                // æ£€æŸ¥æ˜¯å¦é‡åˆ°#EOFæ ‡è®°
                if (attrName === '#EOF') {
                    console.log('é‡åˆ°#EOFæ ‡è®°,åœæ­¢è¯»å–');
                    break;
                }
                
                // åªæ·»åŠ techSpecMappingä¸­å®šä¹‰çš„å±æ€§
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`æ·»åŠ è§„æ ¼: ${attrName} = "${attrValue}" (æ˜ å°„åˆ°: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`è·³è¿‡æœªæ˜ å°„çš„å±æ€§: ${attrName}`);
                }
                
                row++;
            }
            
            console.log(`åˆ—${column}åŸºå‡†è§„æ ¼æå–å®Œæˆ,æ€»å…±æå–åˆ°:`, Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            console.log('è§„æ ¼åˆ—è¡¨:', Object.keys(specs));
            
            return specs;
        }

        function performTechSpecMatch() {
            try {
                hideError();
                
                // æ£€æŸ¥å·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                if (!fileBaselineData.SheetNames.includes('Tech Spec')) {
                    throw new Error('åŸºå‡†æ–‡ä»¶ä¸­æœªæ‰¾åˆ°"Tech Spec"å·¥ä½œè¡¨');
                }
                
                if (!fileTestData.SheetNames.includes('OBJECT-ELEMENT')) {
                    throw new Error('æµ‹è¯•æ–‡ä»¶ä¸­æœªæ‰¾åˆ°"OBJECT-ELEMENT"å·¥ä½œè¡¨');
                }
                
                // æ£€æŸ¥PPå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPP = null;
                if (fileTestData.SheetNames.includes('PP')) {
                    sheetPP = fileTestData.Sheets['PP'];
                }
                
                // æ£€æŸ¥CAMå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetCAM = null;
                if (fileTestData.SheetNames.includes('CAM')) {
                    sheetCAM = fileTestData.Sheets['CAM'];
                }
                
                // æ£€æŸ¥WSå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetWS = null;
                if (fileTestData.SheetNames.includes('WS')) {
                    sheetWS = fileTestData.Sheets['WS'];
                }
                
                // æ£€æŸ¥PORå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPOR = null;
                if (fileBaselineData.SheetNames.includes('POR')) {
                    sheetPOR = fileBaselineData.Sheets['POR'];
                }
                
                // æ£€æŸ¥PRCå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPRC = null;
                if (fileTestData.SheetNames.includes('PRC')) {
                    sheetPRC = fileTestData.Sheets['PRC'];
                }
                
                // æ£€æŸ¥MEMå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetMEM = null;
                if (fileTestData.SheetNames.includes('MEM')) {
                    sheetMEM = fileTestData.Sheets['MEM'];
                }
                
                // æ£€æŸ¥HDå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetHD = null;
                if (fileTestData.SheetNames.includes('HD')) {
                    sheetHD = fileTestData.Sheets['HD'];
                }
                
                const sheetBaseline = fileBaselineData.Sheets['Tech Spec'];
                const sheetTest = fileTestData.Sheets['OBJECT-ELEMENT'];
                
                // 1. éå†æµ‹è¯•è¡¨çš„OBJECT-ELEMENTå·¥ä½œè¡¨,ä»D6å¼€å§‹æ¨ªå‘è¯»å–äº§å“,ç›´åˆ°é‡åˆ°#EOF
                const productList = [];
                let col = 'D';
                let colIndex = 4; // Dåˆ—å¯¹åº”ç´¢å¼•4
                
                console.log('å¼€å§‹éå†æµ‹è¯•è¡¨OBJECT-ELEMENT,ä»D6å¼€å§‹æ”¶é›†äº§å“åˆ—è¡¨...');
                
                while (true) {
                    const cellAddr = `${col}6`;
                    const cellValue = sheetTest[cellAddr] ? String(sheetTest[cellAddr].v).trim() : '';
                    
                    console.log(`æ£€æŸ¥å•å…ƒæ ¼${cellAddr}: "${cellValue}"`);
                    
                    // æ£€æŸ¥æ˜¯å¦é‡åˆ°#EOF
                    if (cellValue === '#EOF' || !cellValue) {
                        console.log(`åœ¨${cellAddr}é‡åˆ°#EOFæˆ–ç©ºå€¼,åœæ­¢éå†`);
                        break;
                    }
                    
                    // ä»äº§å“åç§°ä¸­æå–Part Number (æ ¼å¼: [PN]æè¿°)
                    const pnMatch = cellValue.match(/\[([^\]]+)\]/);
                    const partNumber = pnMatch ? pnMatch[1].trim() : '';
                    
                    if (partNumber) {
                        console.log(`åˆ—${col}: æ‰¾åˆ°äº§å“ Part Number="${partNumber}", å®Œæ•´åç§°="${cellValue}"`);
                        productList.push({
                            partNumber: partNumber,
                            productName: cellValue,
                            column: col,
                            colIndex: colIndex
                        });
                    } else {
                        console.log(`åˆ—${col}: æœªèƒ½ä»"${cellValue}"ä¸­æå–Part Number`);
                    }
                    
                    // ç§»åŠ¨åˆ°ä¸‹ä¸€åˆ—
                    colIndex++;
                    if (colIndex <= 26) {
                        col = String.fromCharCode(64 + colIndex); // A=65, B=66...Z=90
                    } else {
                        // å¤„ç†AA, ABç­‰åˆ—
                        const firstChar = String.fromCharCode(64 + Math.floor((colIndex - 1) / 26));
                        const secondChar = String.fromCharCode(64 + ((colIndex - 1) % 26) + 1);
                        col = firstChar + secondChar;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (colIndex > 100) {
                        console.log('è¶…è¿‡æœ€å¤§åˆ—æ•°,åœæ­¢éå†');
                        break;
                    }
                }
                
                console.log(`å…±æ‰¾åˆ°${productList.length}ä¸ªäº§å“éœ€è¦æ£€éªŒ`);
                
                if (productList.length === 0) {
                    throw new Error('æµ‹è¯•è¡¨ä¸­æœªæ‰¾åˆ°ä»»ä½•äº§å“(ä»D6å¼€å§‹,æ ¼å¼åº”ä¸º[PN]æè¿°)');
                }
                
                // 2. å¯¹æ¯ä¸ªäº§å“è¿›è¡ŒæŠ€æœ¯è§„æ ¼æ£€éªŒ
                let allProductResults = [];
                
                productList.forEach((productInfo, index) => {
                    console.log(`\n====== æ£€éªŒç¬¬${index + 1}ä¸ªäº§å“: ${productInfo.partNumber} ======`);
                    
                    // 1. æå–äº§å“åç§° (åŸºå‡†è¡¨å§‹ç»ˆä½¿ç”¨B1/C1)
                    const b1 = sheetBaseline['B1'] ? sheetBaseline['B1'].v : '';
                    const c1 = sheetBaseline['C1'] ? sheetBaseline['C1'].v : '';
                    let baselineProductName = '';
                    
                    if (String(b1).trim() === 'Product Name') {
                        baselineProductName = String(c1).trim();
                    } else if (String(c1).trim() === 'Product Name') {
                        baselineProductName = String(b1).trim();
                    }
                    
                    // 2. æå–åŸºå‡†è§„æ ¼æ•°æ®(åŸºå‡†è¡¨å§‹ç»ˆä½¿ç”¨Cåˆ—ä½œä¸ºå€¼åˆ—)
                    const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
                    const baselineSpecs = extractBaselineSpecsForColumn(sheetBaseline, valueColumn);
                    
                    // 3. å¦‚æœæœ‰Colorå±æ€§ä¸”æœ‰PORå·¥ä½œè¡¨,ä»PORè¯»å–ColoråŸºå‡†å€¼
                    if (sheetPOR && baselineSpecs['Color']) {
                        const porRow = findMatchingRowInPOR(sheetPOR, productInfo.partNumber);
                        if (porRow) {
                            const mCell = sheetPOR[`M${porRow.row}`];
                            if (mCell) {
                                baselineSpecs['Color'] = {
                                    value: String(mCell.v || '').trim(),
                                    cell: `POR M${porRow.row}`
                                };
                            }
                        }
                    }
                    
                    // 4. æå–æµ‹è¯•è§„æ ¼æ•°æ® (ä»å¯¹åº”åˆ—è¯»å–)
                    const testSpecs = extractTestSpecsForColumn(sheetTest, productInfo.column);
                    
                    // 5. æå–Cameraæ•°æ®
                    const cameraSpecs = extractCameraSpecs(sheetCAM);
                    
                    // 6. æå–Wirelessæ•°æ®
                    const wirelessSpecs = extractWirelessSpecs(sheetWS);
                    
                    // 7. è¿›è¡ŒåŒ¹é…å¯¹æ¯”                   
                    const matchResults = matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetPOR, sheetPRC, sheetMEM, sheetHD, fileTestData, productInfo);

                    allProductResults.push({
                        partNumber: productInfo.partNumber,
                        productName: productInfo.productName,
                        column: productInfo.column,
                        baselineProductName: baselineProductName,
                        matchResults: matchResults
                    });
                });
                
                // æ˜¾ç¤ºæ‰€æœ‰äº§å“çš„æ£€éªŒç»“æœ
                displayTechResultsMultiple(allProductResults);
                
            } catch (error) {
                showError(`æŠ€æœ¯è§„æ ¼åŒ¹é…è¿‡ç¨‹å‡ºé”™: ${error.message}`);
                console.error('æŠ€æœ¯è§„æ ¼åŒ¹é…é”™è¯¯:', error);
            }
        }

        function extractProductName(sheet) {
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            if (String(b1).trim() === 'Product Name') {
                return String(c1).trim();
            } else if (String(c1).trim() === 'Product Name') {
                return String(b1).trim();
            } else {
                throw new Error('æœªæ‰¾åˆ°äº§å“åç§°ï¼Œè¯·æ£€æŸ¥B1å’ŒC1å•å…ƒæ ¼');
            }
        }

        // ä»æµ‹è¯•è¡¨ä¸­è·å–Part Number
        function getTestPartNumber(sheet) {
            // æ£€æŸ¥OBJECT-ELEMENTè¡¨çš„B6å•å…ƒæ ¼ï¼ˆå‡è®¾Part Numberåœ¨è¿™é‡Œï¼‰
            // æˆ–è€…ä»ç¬¬6è¡Œå¼€å§‹æŸ¥æ‰¾"PRC"ç±»å‹å¯¹åº”çš„å€¼
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                // å¦‚æœæ‰¾åˆ°PRCç±»å‹ï¼Œè¿”å›å…¶å€¼ä½œä¸ºPart Number
                if (typeName === 'PRC') {
                    return typeValue;
                }
                
                row++;
            }
            
            return null;
        }

        // åœ¨åŸºå‡†è¡¨PORä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number:', testPartNumber);
            
            // ä»B2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾ï¼Œç›´åˆ°Båˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const bCell = `E${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // å¦‚æœBåˆ—ä¸ºç©ºï¼Œåœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Båˆ—ä¸ºç©ºï¼Œåœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    
                    // è·å–è¯¥è¡Œçš„ç›¸å…³æ•°æ®
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('åŒ¹é…è¡Œæ•°æ®:', rowData);
                    return rowData;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯ï¼Œæœ€å¤šæŸ¥æ‰¾100è¡Œ
                if (row > 100) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°ï¼Œåœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        function extractBaselineSpecs(sheet) {
            const specs = {};
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            // ç¡®å®šå€¼åˆ—ï¼ˆBåˆ—è¿˜æ˜¯Cåˆ—ï¼‰
            const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
            
            console.log('å¼€å§‹æå–åŸºå‡†è§„æ ¼ï¼Œå€¼åˆ—ä¸º:', valueColumn);
            
            // ä»ç¬¬2è¡Œå¼€å§‹è¯»å–è§„æ ¼ï¼Œç›´åˆ°é‡åˆ°#EOFæˆ–è€…è¶…å‡ºåˆç†èŒƒå›´
            let row = 2;
            const maxRows = 100; // é˜²æ­¢æ— é™å¾ªç¯ï¼Œè®¾ç½®æœ€å¤§è¡Œæ•°
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${valueColumn}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: å±æ€§="${attrName}", å€¼="${attrValue}"`);
                
                // æ£€æŸ¥æ˜¯å¦é‡åˆ°#EOFæ ‡è®°
                if (attrName === '#EOF') {
                    console.log('é‡åˆ°#EOFæ ‡è®°ï¼Œåœæ­¢è¯»å–');
                    break;
                }
                
                // åªæ·»åŠ techSpecMappingä¸­å®šä¹‰çš„å±æ€§
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`æ·»åŠ è§„æ ¼: ${attrName} = "${attrValue}" (æ˜ å°„åˆ°: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`è·³è¿‡æœªæ˜ å°„çš„å±æ€§: ${attrName}`);
                }
                // å¦‚æœå±æ€§åä¸ºç©ºï¼Œç»§ç»­è¯»å–ä¸‹ä¸€è¡Œï¼ˆè·³è¿‡ç©ºè¡Œï¼‰
                
                row++;
            }
            
            console.log('åŸºå‡†è§„æ ¼æå–å®Œæˆï¼Œæ€»å…±æå–åˆ°:', Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            console.log('è§„æ ¼åˆ—è¡¨:', Object.keys(specs));
            
            return specs;
        }

        function extractTestSpecs(sheet) {
            const specs = {};
            
            // ä»ç¬¬6è¡Œå¼€å§‹è¯»å–ï¼Œç›´åˆ°é‡åˆ°#EOF
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                specs[typeName] = {
                    value: typeValue,
                    cell: valueCell
                };
                
                row++;
            }
            
            return specs;
        }

        // ä»æŒ‡å®šåˆ—æå–æµ‹è¯•è§„æ ¼æ•°æ®
        function extractTestSpecsForColumn(sheet, column) {
            const specs = {};
            
            console.log(`å¼€å§‹ä»åˆ—${column}æå–æµ‹è¯•è§„æ ¼`);
            
            // ä»ç¬¬7è¡Œå¼€å§‹è¯»å–(ç¬¬6è¡Œæ˜¯äº§å“åç§°),ç›´åˆ°é‡åˆ°#EOF
            let row = 7;
            
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`; // æ”¹ä¸ºå§‹ç»ˆä»Cåˆ—è¯»å–å€¼,è€Œä¸æ˜¯ä»æŒ‡å®šåˆ—è¯»å–
                const markerCell = `${column}${row}`; // ç”¨æŒ‡å®šåˆ—æ¥åˆ¤æ–­æ˜¯å¦æœ‰æ ‡è®°
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                const markerValue = sheet[markerCell] ? String(sheet[markerCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: ç±»å‹="${typeName}", å€¼="${typeValue}", æ ‡è®°åˆ—${column}="${markerValue}"`);
                
                if (typeName === '#EOF' || !typeName) {
                    console.log('é‡åˆ°#EOFæˆ–ç©ºå€¼,åœæ­¢è¯»å–');
                    break;
                }
                
                // åªæœ‰å½“æŒ‡å®šåˆ—æœ‰æ ‡è®°(å¦‚X)æ—¶,æ‰æ”¶é›†è¿™ä¸€è¡Œçš„æ•°æ®
                if (markerValue) {
                    specs[typeName] = {
                        value: typeValue,
                        cell: valueCell, // å®é™…å€¼åœ¨Cåˆ—
                        markerCell: markerCell // æ ‡è®°åœ¨æŒ‡å®šåˆ—
                    };
                    console.log(`æ”¶é›†è§„æ ¼: ${typeName} = "${typeValue}" (æ ‡è®°åˆ—${markerCell}="${markerValue}")`);
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§è¡Œæ•°,åœæ­¢è¯»å–');
                    break;
                }
            }
            
            console.log(`åˆ—${column}æµ‹è¯•è§„æ ¼æå–å®Œæˆ,æ€»å…±æå–åˆ°:`, Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            
            return specs;
        }
        function extractCameraSpecs(sheet) {
            const cameraSpecs = {};
            
            if (!sheet) {
                return cameraSpecs; // è¿”å›ç©ºå¯¹è±¡å¦‚æœæ²¡æœ‰CAMå·¥ä½œè¡¨
            }
            
            // æ£€æŸ¥G2åˆ°G10çš„ä½ç½®æ¥æŸ¥æ‰¾Frontå’ŒBack camera
            for (let row = 2; row <= 10; row++) {
                const gCell = `G${row}`;
                const bCell = `E${row}`;
                
                const gValue = sheet[gCell] ? String(sheet[gCell].v).trim().toLowerCase() : '';
                const bValue = sheet[bCell] ? String(sheet[bCell].v).trim() : '';
                
                if (gValue === 'front') {
                    cameraSpecs['Front Camera'] = {
                        value: bValue,
                        cell: bCell
                    };
                } else if (gValue === 'back') {
                    cameraSpecs['Back Camera'] = {
                        value: bValue,
                        cell: bCell
                    };
                    // ä¹Ÿæ·»åŠ Backåˆ«åæ”¯æŒ
                    cameraSpecs['Back'] = {
                        value: bValue,
                        cell: bCell
                    };
                }
            }
            
            return cameraSpecs;
        }

        function extractWirelessSpecs(sheet) {
            const wirelessSpecs = {};
            
            if (!sheet) {
                return wirelessSpecs; // è¿”å›ç©ºå¯¹è±¡å¦‚æœæ²¡æœ‰WSå·¥ä½œè¡¨
            }
            
            // æ£€æŸ¥R2åˆ°R10çš„ä½ç½®æ¥æŸ¥æ‰¾WLANå’ŒPAN
            for (let row = 2; row <= 10; row++) {
                const rCell = `R${row}`;
                const eCell = `E${row}`;
                const lCell = `L${row}`;
                
                const rValue = sheet[rCell] ? String(sheet[rCell].v).trim().toUpperCase() : '';
                const eValue = sheet[eCell] ? String(sheet[eCell].v).trim() : '';
                const lValue = sheet[lCell] ? String(sheet[lCell].v).trim() : '';
                
                if (rValue === 'WLAN') {
                    wirelessSpecs['Wireless'] = {
                        value: eValue,
                        cell: eCell
                    };
                } else if (rValue === 'PAN') {
                    wirelessSpecs['Bluetooth'] = {
                        value: lValue,
                        cell: lCell
                    };
                }
            }
            
            return wirelessSpecs;
        }

       function matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetPOR, sheetPRC, sheetMEM, sheetHD, testWorkbook, productInfo) {
            const results = [];
            
            // éå†åŸºå‡†è§„æ ¼
            Object.keys(baselineSpecs).forEach(attrName => {
                const baselineSpec = baselineSpecs[attrName];
                const abbreviation = techSpecMapping[attrName];
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // è·³è¿‡What's in the boxï¼Œå› ä¸ºä¼šåœ¨æœ€åå¤„ç†
                if (attrName === 'What\'s in the box') {
                    return;
                }
                
                // å¤„ç†Cameraç‰¹æ®Šæƒ…å†µ - ä»CAMå·¥ä½œè¡¨è€Œä¸æ˜¯OBJECT-ELEMENTä¸­è¯»å–
                if ((attrName === 'Front Camera' || attrName === 'Back Camera' || attrName === 'Back') && cameraSpecs) {
                    if (cameraSpecs[attrName]) {
                        testSpec = cameraSpecs[attrName];
                        isMatched = true;
                        // å¯¹Cameraè¿›è¡Œç‰¹æ®Šæ£€éªŒï¼ŒåŒæ—¶ä¼ é€’OBJECT-ELEMENTä¸­çš„CAMå€¼ç”¨äºMBGæ£€æŸ¥
                        const objectElementCamValue = testSpecs['CAM'] ? testSpecs['CAM'].value : null;
                        checkResult = checkCamera(baselineSpec.value, testSpec.value, objectElementCamValue);
                    } else {
                        checkResult = { isValid: false, message: 'æœªåœ¨CAMå·¥ä½œè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„Cameraæ•°æ®' };
                    }
                // å¤„ç†Bluetoothå’ŒWirelessç‰¹æ®Šæƒ…å†µ - ä»WSå·¥ä½œè¡¨è€Œä¸æ˜¯OBJECT-ELEMENTä¸­è¯»å–
                } else if ((attrName === 'Bluetooth' || attrName === 'Wireless') && wirelessSpecs) {
                    if (wirelessSpecs[attrName]) {
                        testSpec = wirelessSpecs[attrName];
                        isMatched = true;
                        // å¯¹Bluetoothä½¿ç”¨ä¸“é—¨çš„æ£€éªŒå‡½æ•°ï¼Œå¯¹Wirelessä½¿ç”¨ä¸“é—¨çš„æ£€éªŒå‡½æ•°
                        if (attrName === 'Bluetooth') {
                            // ä¼ é€’OBJECT-ELEMENTä¸­çš„WSå€¼ç”¨äºMBGæ£€æŸ¥
                            const objectElementWsValue = testSpecs['WS'] ? testSpecs['WS'].value : null;
                            checkResult = checkBluetooth(baselineSpec.value, testSpec.value, objectElementWsValue);
                        } else {
                            checkResult = checkWireless(baselineSpec.value, testSpec.value);
                        }
                    } else {
                        checkResult = { isValid: false, message: 'æœªåœ¨WSå·¥ä½œè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„Bluetooth/Wirelessæ•°æ®' };
                    }
                // å¤„ç†Colorç‰¹æ®Šæƒ…å†µ - ä»PORçš„M2å’ŒPPçš„T2æ¯”è¾ƒ
                } else if (attrName === 'Color' || attrName.includes('Color')) {
                    if (sheetPP) {
                        checkResult = checkColor(baselineSpec.value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : 'æœªæ‰¾åˆ°',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡ŒColoræ£€éªŒ' };
                    }
                } else if (abbreviation && testSpecs[abbreviation]) {
                    testSpec = testSpecs[abbreviation];
                    isMatched = true;
                    
                    // å¯¹Weightã€Dimensionå’ŒProcessorè¿›è¡Œç‰¹æ®Šæ£€éªŒ
                    if (attrName === 'Weight' || attrName.includes('Weight')) {
                        if (sheetPP) {
                            checkResult = checkWeight(baselineSpec.value, sheetPP);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œé‡é‡æ£€éªŒ' };
                        }
                    } else if (attrName === 'Dimension' || attrName.includes('Dimension')) {
                        if (sheetPP) {
                            checkResult = checkDimension(baselineSpec.value, sheetPP);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå°ºå¯¸æ£€éªŒ' };
                        }
                    } else if (attrName === 'Processor' || attrName.includes('Processor')) {
                        if (sheetPRC) {
                            checkResult = checkProcessor(baselineSpec.value, sheetPRC);
                            // æ ‡è®°ä¸ºå·²åŒ¹é…ï¼Œå› ä¸ºæˆ‘ä»¬æœ‰ä¸“é—¨çš„PRCå·¥ä½œè¡¨æ£€éªŒ
                            isMatched = true;
                            testSpec = {
                                value: testSpec.value, // ä½¿ç”¨OBJECT-ELEMENTä¸­PRCçš„å€¼
                                cell: testSpec.cell
                            };
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PRCå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå¤„ç†å™¨æ£€éªŒ' };
                        }
                    } else if (attrName === 'OS' || attrName.includes('OS')) {
                        checkResult = checkOS(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Display' || attrName.includes('Display')) {
                        checkResult = checkDisplay(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Storage' || attrName.includes('Storage')) {
                        if (sheetHD) {
                            checkResult = checkStorage(baselineSpec.value, testSpec.value, sheetHD);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°HDå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå­˜å‚¨æ£€éªŒ' };
                        }
                    } else if (attrName === 'Memory' || attrName.includes('Memory')) {
                        if (sheetMEM) {
                            checkResult = checkMemory(baselineSpec.value, testSpec.value, sheetMEM);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°MEMå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå†…å­˜æ£€éªŒ' };
                        }
                    } else if (attrName === 'Graphics' || attrName.includes('Graphics')) {
                        checkResult = checkGraphics(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Battery Life' || attrName.includes('Battery Life')) {
                        // è·å–æµ‹è¯•æ–‡ä»¶çš„TIå·¥ä½œè¡¨
                        if (testWorkbook && testWorkbook.Sheets && testWorkbook.Sheets['TI']) {
                            const testSheetTI = testWorkbook.Sheets['TI'];
                            checkResult = checkBatteryLife(baselineSpec.value, testSheetTI);
                            
                            // æ›´æ–°testSpecä»¥æ˜¾ç¤ºE2å’ŒF2çš„å€¼
                            if (checkResult.isValid) {
                                testSpec = {
                                    value: `E2: ${checkResult.e2Value || 'æœªæ‰¾åˆ°'} | F2: ${checkResult.f2Value || 'æœªæ‰¾åˆ°'}`,
                                    cell: 'TI E2, F2'
                                };
                                isMatched = checkResult.isMatch;
                            } else {
                                isMatched = false;
                            }
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°TIå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡ŒBattery Lifeæ£€éªŒ' };
                            isMatched = false;
                        }
                    } else if (attrName === 'Port' || attrName.includes('Port')) {
                        checkResult = checkPort(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Audio' || attrName.includes('Audio')) {
                        checkResult = checkAudio(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Fingerprint Reader' || attrName.includes('Fingerprint Reader')) {
                        checkResult = checkFingerprintReader(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Warranty' || attrName.includes('Warranty')) {
                        checkResult = checkWarranty(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'IMG' || attrName.includes('IMG')) {
                        checkResult = checkIMG(baselineSpec.value, testSpec.value, sheetPOR, productInfo.partNumber);
                    }
                }
                
                results.push({
                    attribute: attrName,
                    abbreviation: abbreviation || 'æœªæ˜ å°„',
                    baselineValue: baselineSpec.value,
                    baselineCell: baselineSpec.cell,
                    testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            });
            
        // æœ€åæ·»åŠ What's in the boxçš„å¤„ç†ï¼ˆå³ä½¿ä¸åœ¨åŸºå‡†è§„æ ¼ä¸­ï¼‰
        if (sheetPOR) {
            const n2Cell = sheetPOR['N2'];
            if (n2Cell) {
                const n2Value = String(n2Cell.v || '').trim();
                const abbreviation = 'MM';
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // è·å–æµ‹è¯•å€¼ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰
                const testValue = testSpecs[abbreviation] ? testSpecs[abbreviation].value : null;
                
                // æ— è®ºæµ‹è¯•å€¼æ˜¯å¦å­˜åœ¨ï¼Œéƒ½è°ƒç”¨æ£€éªŒå‡½æ•°
                checkResult = checkWhatsInTheBox(n2Value, testValue);
                
                // æ ¹æ®æ£€éªŒç»“æœåˆ¤æ–­æ˜¯å¦åŒ¹é…
                if (checkResult.isValid && checkResult.isMatch) {
                    isMatched = true;
                    testSpec = testSpecs[abbreviation] || null;
                } else {
                    isMatched = false;
                    testSpec = testSpecs[abbreviation] || null;
                }
                
                results.push({
                    attribute: 'What\'s in the box',
                    abbreviation: 'MM',
                    baselineValue: n2Value,
                    baselineCell: 'POR N2',
                    testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            }
                    
                // æ·»åŠ Colorçš„å¤„ç†ï¼ˆä»POR M2è¯»å–åŸºå‡†å€¼ï¼Œä¸PP T2æ¯”è¾ƒï¼‰
                const m2Cell = sheetPOR['M2'];
                if (m2Cell && sheetPP) {
                    const m2Value = String(m2Cell.v || '').trim();
                    
                    let testSpec = null;
                    let isMatched = false;
                    let checkResult = null;
                    
                    if (m2Value) {
                        checkResult = checkColor(m2Value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : 'æœªæ‰¾åˆ°',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: 'POR M2å•å…ƒæ ¼ä¸ºç©º' };
                    }
                    
                    results.push({
                        attribute: 'Color',
                        abbreviation: 'COLOR',
                        baselineValue: m2Value,
                        baselineCell: 'POR M2',
                        testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                        testCell: testSpec ? testSpec.cell : '-',
                        isMatched: isMatched,
                        checkResult: checkResult
                    });
                }
            }
            
            // æ·»åŠ IMGçš„å¤„ç†ï¼ˆä»PORè¡¨è¯»å–Colorä½œä¸ºåŸºå‡†å€¼ï¼‰
            let imgBaselineValue = '(æœªæ‰¾åˆ°)';
            let imgBaselineCell = '-';

            // ä»PORè¡¨ä¸­è¯»å–Colorä½œä¸ºåŸºå‡†å€¼
            if (sheetPOR) {
                // æŸ¥æ‰¾å½“å‰äº§å“çš„Part Numberå¯¹åº”çš„è¡Œ
                let porRow = null;
                let row = 2;
                
                while (row <= 1000) {
                    const bCell = `B${row}`;
                    const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        break;
                    }
                    
                    if (partNumber === productInfo.partNumber) {
                        porRow = row;
                        break;
                    }
                    
                    row++;
                }
                
                // å¦‚æœæ‰¾åˆ°å¯¹åº”è¡Œï¼Œè¯»å–Måˆ—çš„Colorå€¼
                if (porRow) {
                    const mCell = `M${porRow}`;
                    const colorValue = sheetPOR[mCell] ? String(sheetPOR[mCell].v).trim() : '';
                    if (colorValue) {
                        imgBaselineValue = colorValue;
                        imgBaselineCell = mCell;
                    }
                }
            }

            // æ£€æŸ¥IMG
            if (testSpecs['IMG']) {
                const testSpec = testSpecs['IMG'];
                const checkResult = checkIMG(imgBaselineValue, testSpec.value);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: testSpec.value,
                    testCell: testSpec.cell,
                    isMatched: checkResult.isValid && checkResult.isMatch,
                    checkResult: checkResult
                });
            } else {
                // å¦‚æœæµ‹è¯•è¡¨ä¸­æ²¡æœ‰IMGï¼Œæ·»åŠ å¤±è´¥è®°å½•
                const checkResult = checkIMG(imgBaselineValue, null);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: 'æœªæ‰¾åˆ°',
                    testCell: '-',
                    isMatched: false,
                    checkResult: checkResult
                });
            }
            
            return results;
        }

        function checkWeight(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†é‡é‡æ•°æ®' };
                }

                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }

                // ä»åŸºå‡†å€¼ä¸­æå–é‡é‡æ•°å­—ï¼ˆå•ä½ï¼šå…‹ï¼‰
                const weightMatch = String(baselineValue).match(/(\d+(?:\.\d+)?)g/i);
                if (!weightMatch) {
                    return { isValid: false, message: 'åŸºå‡†å€¼æ ¼å¼æ— æ•ˆï¼Œéœ€è¦åŒ…å«"g"å•ä½' };
                }

                // âœ… è½¬æ¢ä¸ºåƒå…‹ï¼Œå¹¶ä¿ç•™ 6 ä½å°æ•°ï¼ˆé¿å…æµ®ç‚¹è¯¯å·®ï¼‰
                const weightInGrams = parseFloat(weightMatch[1]);
                const weightInKg = parseFloat((weightInGrams / 1000).toFixed(6));

                // ä»PPå·¥ä½œè¡¨çš„Z2å•å…ƒæ ¼è¯»å–é‡é‡æ•°æ®
                const z2Cell = sheetPP['Z2'];
                if (!z2Cell) {
                    return { isValid: false, message: 'PPå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°Z2å•å…ƒæ ¼' };
                }

                const testWeightValue = z2Cell.v;
                let testWeightInKg;

                if (typeof testWeightValue === 'number') {
                    testWeightInKg = parseFloat(testWeightValue.toFixed(6));
                } else {
                    const testWeightMatch = String(testWeightValue).match(/(\d+(?:\.\d+)?)/);
                    if (!testWeightMatch) {
                        return { isValid: false, message: 'PPå·¥ä½œè¡¨Z2å•å…ƒæ ¼æ ¼å¼æ— æ•ˆ' };
                    }
                    testWeightInKg = parseFloat(parseFloat(testWeightMatch[1]).toFixed(6));
                }

                // âœ… è®¡ç®—å·®å€¼ï¼ˆä¿ç•™6ä½ï¼‰
                const difference = parseFloat(Math.abs(weightInKg - testWeightInKg).toFixed(6));
                const tolerance = 0;
                const isMatch = difference <= tolerance;

                // âœ… è¿”å›ç»“æœï¼Œå…¨éƒ¨æ ¼å¼åŒ–ä¸º6ä½å°æ•°
                return {
                    isValid: true,
                    isMatch: isMatch,
                    convertedValue: weightInKg.toFixed(6),
                    testValue: testWeightInKg.toFixed(6),
                    message: isMatch
                        ? 'é‡é‡åŒ¹é…'
                        : `é‡é‡ä¸åŒ¹é… (å·®å€¼: ${difference.toFixed(6)}kg)`,
                    ppCells: `Z2: ${testWeightInKg.toFixed(6)}kg`
                };

            } catch (error) {
                return { isValid: false, message: `é‡é‡æ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }


        // å°ºå¯¸æ£€éªŒå‡½æ•°
        function checkDimension(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†å°ºå¯¸æ•°æ®' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue);
                console.log('åŸå§‹åŸºå‡†å°ºå¯¸å€¼:', baselineStr);
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«Openå’ŒClosedçŠ¶æ€
                const hasOpenClosed = /open|closed/i.test(baselineStr);
                
                if (hasOpenClosed) {
                    return checkFoldableDimension(baselineStr, sheetPP);
                } else {
                    return checkStandardDimension(baselineStr, sheetPP);
                }
                
            } catch (error) {
                return { isValid: false, message: `å°ºå¯¸æ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }
        
        // æ ‡å‡†è®¾å¤‡å°ºå¯¸æ£€éªŒå‡½æ•°
        function checkStandardDimension(baselineStr, sheetPP) {
            console.log('å¤„ç†æ ‡å‡†è®¾å¤‡å°ºå¯¸');
            
            // æ‰¾åˆ°"mm"çš„ä½ç½®ï¼Œåªå¤„ç†mmä¹‹å‰çš„å†…å®¹
            let mmIndex = baselineStr.toLowerCase().indexOf('mm');
            let processString = mmIndex !== -1 ? baselineStr.substring(0, mmIndex + 2) : baselineStr;
            console.log('å¤„ç†çš„å­—ç¬¦ä¸²ï¼ˆåˆ°mmä¸ºæ­¢ï¼‰:', processString);
            
            // ä»å¤„ç†åçš„å­—ç¬¦ä¸²ä¸­æå–å°ºå¯¸ï¼ˆæ ¼å¼ï¼šæ•°å­— x æ•°å­— x æ•°å­— mmï¼‰
            const dimensionMatch = processString.match(/(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)\s*mm/i);
            if (!dimensionMatch) {
                // å¦‚æœæ²¡æ‰¾åˆ°å®Œæ•´æ ¼å¼ï¼Œå°è¯•åªåŒ¹é…æ•°å­—éƒ¨åˆ†
                const numbersMatch = processString.match(/(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)/i);
                if (!numbersMatch) {
                    return { isValid: false, message: `åŸºå‡†å€¼æ ¼å¼æ— æ•ˆï¼Œéœ€è¦"é•¿ x å®½ x åš"æ ¼å¼ã€‚å½“å‰å€¼: "${processString}"` };
                }
                // ä½¿ç”¨æ•°å­—åŒ¹é…çš„ç»“æœ
                var [, length, width, thickness] = numbersMatch;
                console.log('ä½¿ç”¨æ•°å­—åŒ¹é…æ¨¡å¼');
            } else {
                var [, length, width, thickness] = dimensionMatch;
                console.log('ä½¿ç”¨å®Œæ•´mmåŒ¹é…æ¨¡å¼');
            }
            
            const lengthValue = parseFloat(length);
            const widthValue = parseFloat(width);
            const thicknessValue = parseFloat(thickness);
            
            console.log(`æå–çš„å°ºå¯¸: é•¿=${lengthValue}, å®½=${widthValue}, åš=${thicknessValue}`);
            
            // ä»PPå·¥ä½œè¡¨è¯»å–N2, AD2, I2çš„å€¼
            const n2Cell = sheetPP['N2'];
            const ad2Cell = sheetPP['AD2'];
            const i2Cell = sheetPP['I2'];
            
            let ppValues = {
                length: n2Cell ? (typeof n2Cell.v === 'number' ? n2Cell.v : parseFloat(String(n2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null,
                width: ad2Cell ? (typeof ad2Cell.v === 'number' ? ad2Cell.v : parseFloat(String(ad2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null,
                thickness: i2Cell ? (typeof i2Cell.v === 'number' ? i2Cell.v : parseFloat(String(i2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null
            };
            
            console.log('PPå·¥ä½œè¡¨çš„å€¼:', ppValues);
            
            // æ£€æŸ¥åŒ¹é…æƒ…å†µ
            const lengthMatch = ppValues.length !== null && Math.abs(lengthValue - ppValues.length) <= 0.1;
            const widthMatch = ppValues.width !== null && Math.abs(widthValue - ppValues.width) <= 0.1;
            const thicknessMatch = ppValues.thickness !== null && Math.abs(thicknessValue - ppValues.thickness) <= 0.1;
            
            const allMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (allMatch) {
                message = `å°ºå¯¸å…¨éƒ¨åŒ¹é… (æå–è‡ª: "${processString}")`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`é•¿åº¦(${lengthValue} vs ${ppValues.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`å®½åº¦(${widthValue} vs ${ppValues.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`åšåº¦(${thicknessValue} vs ${ppValues.thickness || 'N/A'})`);
                message = `å°ºå¯¸ä¸åŒ¹é…: ${mismatches.join(', ')} (æå–è‡ª: "${processString}")`;
            }
            
            return {
                isValid: true,
                isMatch: allMatch,
                convertedValues: {
                    length: lengthValue,
                    width: widthValue,
                    thickness: thicknessValue
                },
                ppValues: ppValues,
                message: message,
                processedString: processString,
                originalString: baselineStr,
                ppCells: `N2: ${ppValues.length || 'N/A'}mm, AD2: ${ppValues.width || 'N/A'}mm, I2: ${ppValues.thickness || 'N/A'}mm`
            };
        }
        
        // æŠ˜å è®¾å¤‡å°ºå¯¸æ£€éªŒå‡½æ•°
        function checkFoldableDimension(baselineStr, sheetPP) {
            console.log('å¤„ç†æŠ˜å è®¾å¤‡å°ºå¯¸');
            
            // è§£æOpenå’ŒClosedå°ºå¯¸
            const openPattern = /open\s*([\d\s.Ã—x]+mm)/i;
            const closedPattern = /closed\s*([\d\s.Ã—x]+mm)/i;
            
            const openMatch = baselineStr.match(openPattern);
            const closedMatch = baselineStr.match(closedPattern);
            
            console.log('OpenåŒ¹é…:', openMatch);
            console.log('ClosedåŒ¹é…:', closedMatch);
            
            // æŸ¥æ‰¾PPå·¥ä½œè¡¨ä¸­çš„Open PPå’ŒClose PPæ•°æ®
            const ppData = findPPData(sheetPP);
            console.log('æ‰¾åˆ°çš„PPæ•°æ®:', ppData);
            
            let results = [];
            let allMatch = true;
            
            // æ£€æŸ¥Openå°ºå¯¸
            if (openMatch && ppData.open) {
                const openDimensions = extractDimensionsFromString(openMatch[1]);
                if (openDimensions) {
                    const openResult = compareDimensions(openDimensions, ppData.open, 'Open');
                    results.push(openResult);
                    if (!openResult.isMatch) allMatch = false;
                } else {
                    results.push({ state: 'Open', isMatch: false, message: 'Openå°ºå¯¸æ ¼å¼æ— æ•ˆ' });
                    allMatch = false;
                }
            } else if (openMatch && !ppData.open) {
                results.push({ state: 'Open', isMatch: false, message: 'æœªæ‰¾åˆ°Open PPæ•°æ®' });
                allMatch = false;
            } else if (!openMatch && ppData.open) {
                results.push({ state: 'Open', isMatch: false, message: 'åŸºå‡†å€¼ä¸­æœªæ‰¾åˆ°Openå°ºå¯¸' });
                allMatch = false;
            }
            
            // æ£€æŸ¥Closedå°ºå¯¸
            if (closedMatch && ppData.closed) {
                const closedDimensions = extractDimensionsFromString(closedMatch[1]);
                if (closedDimensions) {
                    const closedResult = compareDimensions(closedDimensions, ppData.closed, 'Closed');
                    results.push(closedResult);
                    if (!closedResult.isMatch) allMatch = false;
                } else {
                    results.push({ state: 'Closed', isMatch: false, message: 'Closedå°ºå¯¸æ ¼å¼æ— æ•ˆ' });
                    allMatch = false;
                }
            } else if (closedMatch && !ppData.closed) {
                results.push({ state: 'Closed', isMatch: false, message: 'æœªæ‰¾åˆ°Close PPæ•°æ®' });
                allMatch = false;
            } else if (!closedMatch && ppData.closed) {
                results.push({ state: 'Closed', isMatch: false, message: 'åŸºå‡†å€¼ä¸­æœªæ‰¾åˆ°Closedå°ºå¯¸' });
                allMatch = false;
            }
            
            // ç”Ÿæˆæ±‡æ€»æ¶ˆæ¯
            let message = '';
            if (allMatch && results.length > 0) {
                message = `æŠ˜å è®¾å¤‡å°ºå¯¸å…¨éƒ¨åŒ¹é…: ${results.map(r => r.state).join(', ')}çŠ¶æ€`;
            } else {
                const failures = results.filter(r => !r.isMatch);
                if (failures.length > 0) {
                    message = `æŠ˜å è®¾å¤‡å°ºå¯¸ä¸åŒ¹é…: ${failures.map(r => `${r.state}(${r.message})`).join(', ')}`;
                } else {
                    message = 'æœªæ‰¾åˆ°æœ‰æ•ˆçš„æŠ˜å è®¾å¤‡å°ºå¯¸æ•°æ®';
                }
            }
            
            return {
                isValid: true,
                isMatch: allMatch,
                message: message,
                originalString: baselineStr,
                results: results,
                ppData: ppData
            };
        }
        
        // åœ¨PPå·¥ä½œè¡¨ä¸­æŸ¥æ‰¾Open PPå’ŒClose PPæ•°æ®
        function findPPData(sheetPP) {
            const ppData = { open: null, closed: null };
            
            // æ‰«æPPå·¥ä½œè¡¨ï¼ŒæŸ¥æ‰¾åŒ…å«"Open PP"å’Œ"Close PP"çš„è¡Œ
            for (let row = 1; row <= 50; row++) {
                for (let col of ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']) {
                    const cell = sheetPP[`${col}${row}`];
                    if (cell && cell.v) {
                        const cellValue = String(cell.v).toLowerCase();
                        
                        if (cellValue.includes('open pp') || cellValue.includes('open')) {
                            // æ‰¾åˆ°Open PPï¼Œè¯»å–åŒè¡Œçš„N, AD, Iåˆ—æ•°æ®
                            ppData.open = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        } else if (cellValue.includes('close pp') || cellValue.includes('closed') || cellValue.includes('close')) {
                            // æ‰¾åˆ°Close PPï¼Œè¯»å–åŒè¡Œçš„N, AD, Iåˆ—æ•°æ®
                            ppData.closed = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        }
                    }
                }
            }
            
            return ppData;
        }
        
        // ä»å­—ç¬¦ä¸²ä¸­æå–æ•°å­—
        function extractNumber(value) {
            if (typeof value === 'number') return value;
            const match = String(value).match(/(\d+(?:\.\d+)?)/);
            return match ? parseFloat(match[1]) : null;
        }
        
        // ä»å°ºå¯¸å­—ç¬¦ä¸²ä¸­æå–é•¿å®½é«˜
        function extractDimensionsFromString(dimensionStr) {
            const match = dimensionStr.match(/(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)/i);
            if (match) {
                return {
                    length: parseFloat(match[1]),
                    width: parseFloat(match[2]),
                    thickness: parseFloat(match[3])
                };
            }
            return null;
        }
        
        // æ¯”è¾ƒåŸºå‡†å°ºå¯¸å’ŒPPæ•°æ®
        function compareDimensions(baseline, ppData, state) {
            const tolerance = 0.1;
            
            const lengthMatch = ppData.length !== null && Math.abs(baseline.length - ppData.length) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const thicknessMatch = ppData.thickness !== null && Math.abs(baseline.thickness - ppData.thickness) <= tolerance;
            
            const isMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (isMatch) {
                message = `${state}çŠ¶æ€å°ºå¯¸åŒ¹é…`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`é•¿åº¦(${baseline.length} vs ${ppData.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`å®½åº¦(${baseline.width} vs ${ppData.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`åšåº¦(${baseline.thickness} vs ${ppData.thickness || 'N/A'})`);
                message = `${state}çŠ¶æ€ä¸åŒ¹é…: ${mismatches.join(', ')}`;
            }
            
            return {
                state: state,
                isMatch: isMatch,
                message: message,
                baseline: baseline,
                ppData: ppData,
                ppCells: `è¡Œ${ppData.row}: N${ppData.row}=${ppData.length || 'N/A'}mm, AD${ppData.row}=${ppData.width || 'N/A'}mm, I${ppData.row}=${ppData.thickness || 'N/A'}mm`
            };
        }

        // å¤„ç†å™¨æ£€éªŒå‡½æ•°
        function checkProcessor(baselineValue, sheetPRC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†å¤„ç†å™¨æ•°æ®' };
                }
                
                if (!sheetPRC) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PRCå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Processorå€¼:', baselineStr);
                
                // éœ€è¦æ£€æŸ¥çš„å­—æ®µé…ç½®
                const checkFields = [
                    { name: 'PROCMFR (åˆ¶é€ å•†)', cellKey: 'W1', cellValue: 'W2' },
                    { name: 'SERIES (ç³»åˆ—)', cellKey: 'F1', cellValue: 'F2' },
                    { name: 'SKU', cellKey: 'E1', cellValue: 'E2' },
                    { name: 'PROCCLKSPD (æ—¶é’Ÿé€Ÿåº¦)', cellKey: 'T1', cellValue: 'T2' },
                    { name: 'BRANDCODEF (å“ç‰Œä»£ç )', cellKey: 'K1', cellValue: 'K2' }
                ];
                
                let allChecks = [];
                let allPassed = true;
                
                // æ£€æŸ¥æ¯ä¸ªå­—æ®µ
                checkFields.forEach(field => {
                    const keyCell = sheetPRC[field.cellKey];
                    const valueCell = sheetPRC[field.cellValue];
                    
                    const keyText = keyCell ? String(keyCell.v || '').trim() : '';
                    const valueText = valueCell ? String(valueCell.v || '').trim() : '';
                    
                    console.log(`æ£€æŸ¥${field.name}: ${field.cellKey}="${keyText}", ${field.cellValue}="${valueText}"`);
                    
                    let checkResult = {
                        fieldName: field.name,
                        keyCell: field.cellKey,
                        valueCell: field.cellValue,
                        keyText: keyText,
                        valueText: valueText,
                        isValid: false,
                        found: false
                    };
                    
                    // æ£€æŸ¥keyæ˜¯å¦åŒ¹é…é¢„æœŸå€¼
                    let expectedKey = '';
                    if (field.cellKey === 'W1') expectedKey = 'PROCMFR';
                    else if (field.cellKey === 'F1') expectedKey = 'SERIES';
                    else if (field.cellKey === 'E1') expectedKey = 'SKU';
                    else if (field.cellKey === 'T1') expectedKey = 'PROCCLKSPD';
                    else if (field.cellKey === 'K1') expectedKey = 'BRANDCODEF';
                    
                    if (keyText.toUpperCase() !== expectedKey) {
                        checkResult.isValid = false;
                        checkResult.message = `${field.cellKey}å•å…ƒæ ¼åº”ä¸º"${expectedKey}"ï¼Œå®é™…ä¸º"${keyText}"`;
                        allPassed = false;
                    } else if (!valueText) {
                        checkResult.isValid = false;
                        checkResult.message = `${field.cellValue}å•å…ƒæ ¼ä¸ºç©º`;
                        allPassed = false;
                    } else {
                        // ç‰¹æ®Šå¤„ç†BRANDCODEFå­—æ®µï¼šK2çš„å€¼å¿…é¡»æ˜¯MBG
                        if (field.cellKey === 'K1') {
                            const found = valueText.toUpperCase() === 'MBG';
                            checkResult.isValid = true;
                            checkResult.found = found;
                            
                            if (found) {
                                checkResult.message = `âœ“ "${valueText}" åŒ¹é…è¦æ±‚çš„"MBG"`;
                            } else {
                                checkResult.message = `âœ— "${valueText}" ä¸åŒ¹é…è¦æ±‚çš„"MBG"`;
                                allPassed = false;
                            }
                        } else {
                            // å…¶ä»–å­—æ®µï¼šä½¿ç”¨ä¸¥æ ¼åŒ¹é…è€Œä¸æ˜¯åŒ…å«åŒ¹é…
                            let found = false;
                            
                            // å°†åŸºå‡†å€¼æŒ‰ç©ºæ ¼ã€é€—å·ã€æ–œæ ç­‰åˆ†éš”ç¬¦åˆ†å‰²æˆtokens
                            const baselineTokens = baselineStr.split(/[\s,/\-_()]+/).map(t => t.trim().toLowerCase()).filter(t => t.length > 0);
                            const testValueLower = valueText.toLowerCase().trim();
                            
                            console.log(`å¤„ç†å™¨å­—æ®µæ£€éªŒ - å­—æ®µ: ${field.name}, æµ‹è¯•å€¼: "${valueText}", åŸºå‡†tokens: [${baselineTokens.join(', ')}]`);
                            
                            // æ£€æŸ¥æµ‹è¯•å€¼æ˜¯å¦ä¸ä»»ä½•åŸºå‡†tokenå®Œå…¨åŒ¹é…
                            found = baselineTokens.includes(testValueLower);
                            
                            // å¦‚æœä¸¥æ ¼åŒ¹é…å¤±è´¥ï¼Œå¯¹äºSKUå­—æ®µä¸è¿›è¡Œæ•°å­—æ ‡å‡†åŒ–åŒ¹é…ï¼Œå…¶ä»–æ•°å­—å­—æ®µæ‰è¿›è¡Œ
                            if (!found && /^\d+(\.\d+)?$/.test(valueText) && field.cellKey !== 'E1') {
                                // æå–æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬å°æ•°ï¼‰
                                const baselineNumbers = baselineStr.match(/\d+\.?\d*/g) || [];
                                const testNumbers = valueText.match(/\d+\.?\d*/g) || [];
                                
                                // æ ‡å‡†åŒ–æ•°å­—æ ¼å¼ï¼ˆå»é™¤æœ«å°¾çš„0ï¼‰
                                const normalizeNumber = (num) => {
                                    const parsed = parseFloat(num);
                                    return parsed.toString();
                                };
                                
                                const normalizedBaselineNumbers = baselineNumbers.map(normalizeNumber);
                                const normalizedTestNumbers = testNumbers.map(normalizeNumber);
                                
                                // æ£€æŸ¥æµ‹è¯•å€¼ä¸­çš„æ•°å­—æ˜¯å¦åœ¨åŸºå‡†å€¼çš„æ•°å­—ä¸­å­˜åœ¨
                                found = normalizedTestNumbers.length > 0 && 
                                       normalizedTestNumbers.every(testNum => 
                                           normalizedBaselineNumbers.includes(testNum)
                                       );
                                
                                console.log(`æ•°å­—æ ‡å‡†åŒ–åŒ¹é… - åŸºå‡†æ•°å­—: [${normalizedBaselineNumbers.join(', ')}], æµ‹è¯•æ•°å­—: [${normalizedTestNumbers.join(', ')}], åŒ¹é…ç»“æœ: ${found}`);
                            }
                            
                            checkResult.isValid = true;
                            checkResult.found = found;
                            
                            if (found) {
                                checkResult.message = `âœ“ "${valueText}" ä¸¥æ ¼åŒ¹é…åŸºå‡†Processorä¸­çš„token`;
                            } else {
                                checkResult.message = `âœ— "${valueText}" åœ¨åŸºå‡†Processorä¸­æœªæ‰¾åˆ°ä¸¥æ ¼åŒ¹é… (åŸºå‡†tokens: [${baselineTokens.join(', ')}])`;
                                allPassed = false;
                            }
                        }
                    }
                    
                    allChecks.push(checkResult);
                });
                
                // ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
                let detailMessage = allChecks.map(check => 
                    `${check.fieldName}(${check.keyCell}â†’${check.valueCell}): ${check.message}`
                ).join('; ');
                
                let summaryMessage = '';
                if (allPassed) {
                    summaryMessage = 'å¤„ç†å™¨æ£€éªŒé€šè¿‡ï¼šæ‰€æœ‰å­—æ®µéƒ½åœ¨åŸºå‡†å€¼ä¸­æ‰¾åˆ°åŒ¹é…';
                } else {
                    const failedCount = allChecks.filter(check => !check.found || !check.isValid).length;
                    summaryMessage = `å¤„ç†å™¨æ£€éªŒå¤±è´¥ï¼š${failedCount}/${checkFields.length}ä¸ªå­—æ®µæœªé€šè¿‡æ£€éªŒ`;
                }
                
                return {
                    isValid: true,
                    isMatch: allPassed,
                    message: summaryMessage,
                    detailMessage: detailMessage,
                    checkResults: allChecks,
                    baselineValue: baselineStr
                };
                
            } catch (error) {
                return { isValid: false, message: `å¤„ç†å™¨æ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // OSæ£€éªŒå‡½æ•°
        function checkOS(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘OSæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æ¸…ç†å’Œæ ‡å‡†åŒ–OS tokençš„å‡½æ•°
                function cleanAndNormalizeOSToken(token) {
                    // ç§»é™¤ç‰¹æ®Šç¬¦å·ï¼ˆâ„¢ã€Â®ç­‰ï¼‰å’Œæ ‡ç‚¹ã€æ‹¬å·
                    let cleaned = token.replace(/[^\w.]/g, '');
                    
                    // å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œè¿”å›null
                    if (!cleaned) {
                        return null;
                    }
                    
                    // å¿½ç•¥çš„é¢å¤–è¯´æ˜è¯æ±‡
                    const ignoreWords = ['or', 'later', 'above', 'plus', 'and'];
                    if (ignoreWords.includes(cleaned.toLowerCase())) {
                        return null; // è¿”å›nullè¡¨ç¤ºå¿½ç•¥æ­¤token
                    }
                    
                    return cleaned.toLowerCase();
                }
                
                // 3. å¤„ç†baselineå’Œtest tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æ¸…ç†å’Œæ ‡å‡†åŒ–tokens
                const baselineTokens = rawBaselineTokens
                    .map(cleanAndNormalizeOSToken)
                    .filter(token => token !== null);
                    
                const testTokens = rawTestTokens
                    .map(cleanAndNormalizeOSToken)
                    .filter(token => token !== null);
                
                // 4. æ£€æŸ¥æµ‹è¯•è¡¨çš„æ¯ä¸ªtokenæ˜¯å¦éƒ½èƒ½åœ¨åŸºå‡†è¡¨ä¸­æ‰¾åˆ°
                const missingTokens = [];
                const foundTokens = [];
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                rawTestTokens.forEach(originalToken => {
                    const cleanedToken = cleanAndNormalizeOSToken(originalToken);
                    
                    // å¦‚æœæ˜¯è¢«å¿½ç•¥çš„tokenï¼Œè·³è¿‡
                    if (cleanedToken === null) {
                        return;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨baselineä¸­æ‰¾åˆ°
                    const found = baselineTokens.includes(cleanedToken);
                    
                    if (found) {
                        foundTokens.push(cleanedToken);
                        originalFoundTokens.push(originalToken);
                    } else {
                        missingTokens.push(cleanedToken);
                        originalMissingTokens.push(originalToken);
                    }
                });
                
                const allTokensFound = missingTokens.length === 0;
                const isMatch = hasMBG && allTokensFound;
                
                let message = '';
                if (isMatch) {
                    message = 'OSä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”æ‰€æœ‰å…³é”®tokenéƒ½æ‰¾åˆ°';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else if (!allTokensFound) {
                    message = `OS tokenä¸åŒ¹é…ï¼Œæœªæ‰¾åˆ°: ${originalMissingTokens.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineTokens,
                    cleanedTestTokens: testTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `OSæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Displayæ£€éªŒå‡½æ•°
        function checkDisplay(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Displayæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false
                    };
                }
                
                // 2. æå–Displayå…³é”®å‚æ•°çš„å‡½æ•°
                function extractDisplaySpecs(text) {
                    const specs = {};
                    
                    console.log('æå–Displayè§„æ ¼ï¼ŒåŸå§‹æ–‡æœ¬:', text);
                    
                    // æå–å±å¹•å¤§å° (è‹±å¯¸)
                    const sizeMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:inch|inches|")/i);
                    if (sizeMatch) {
                        specs.size = parseFloat(sizeMatch[1]);
                        console.log('æ‰¾åˆ°å±å¹•å¤§å°:', specs.size + ' inch');
                    }
                    
                    // æå–åˆ†è¾¨ç‡ (å®½xé«˜)
                    const resolutionMatch = text.match(/(\d+)\s*[xÃ—]\s*(\d+)/i);
                    if (resolutionMatch) {
                        specs.resolutionWidth = parseInt(resolutionMatch[1]);
                        specs.resolutionHeight = parseInt(resolutionMatch[2]);
                        // å°†åˆ†è¾¨ç‡å­˜å‚¨ä¸ºæ’åºåçš„æ•°ç»„ï¼Œç”¨äºå®½æ¾æ¯”è¾ƒ
                        specs.resolutionValues = [specs.resolutionWidth, specs.resolutionHeight].sort((a, b) => a - b);
                        specs.resolution = `${specs.resolutionWidth}x${specs.resolutionHeight}`;
                        console.log('æ‰¾åˆ°åˆ†è¾¨ç‡:', specs.resolution, 'æ’åºå€¼:', specs.resolutionValues);
                    }
                    
                    // æå–åˆ·æ–°ç‡ (Hz)
                    const refreshRateMatch = text.match(/(\d+(?:\.\d+)?)\s*Hz/i);
                    if (refreshRateMatch) {
                        specs.refreshRate = parseFloat(refreshRateMatch[1]);
                        console.log('æ‰¾åˆ°åˆ·æ–°ç‡:', specs.refreshRate + 'Hz');
                    }
                    
                    console.log('æå–çš„Displayè§„æ ¼:', specs);
                    return specs;
                }
                
                // 3. æå–åŸºå‡†å’Œæµ‹è¯•è§„æ ¼
                const baselineSpecs = extractDisplaySpecs(baselineStr);
                const testSpecs = extractDisplaySpecs(testStr);
                
                // 4. æ¯”è¾ƒå…³é”®å‚æ•°
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // æ£€æŸ¥å±å¹•å¤§å°
                if (baselineSpecs.size !== undefined) {
                    if (testSpecs.size !== undefined) {
                        if (baselineSpecs.size === testSpecs.size) {
                            foundSpecs.push(`${baselineSpecs.size}"`);
                        } else {
                            mismatchedSpecs.push(`å±å¹•å¤§å°ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.size}" vs æµ‹è¯•${testSpecs.size}"`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.size}"`);
                    }
                }
                
                // æ£€æŸ¥åˆ†è¾¨ç‡ - ä½¿ç”¨å®½æ¾æ¯”è¾ƒï¼ˆæ’åºåçš„æ•°å€¼é›†åˆï¼‰
                if (baselineSpecs.resolutionValues !== undefined) {
                    if (testSpecs.resolutionValues !== undefined) {
                        // æ¯”è¾ƒæ’åºåçš„åˆ†è¾¨ç‡æ•°å€¼
                        const baselineSorted = baselineSpecs.resolutionValues;
                        const testSorted = testSpecs.resolutionValues;
                        const resolutionMatch = baselineSorted.length === testSorted.length && 
                                              baselineSorted.every((val, index) => val === testSorted[index]);
                        
                        if (resolutionMatch) {
                            foundSpecs.push(`${baselineSpecs.resolutionValues.join('x')}åƒç´ `);
                        } else {
                            mismatchedSpecs.push(`åˆ†è¾¨ç‡ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.resolution} vs æµ‹è¯•${testSpecs.resolution}`);
                        }
                    } else {
                        missingSpecs.push(baselineSpecs.resolution);
                    }
                }
                
                // æ£€æŸ¥åˆ·æ–°ç‡
                if (baselineSpecs.refreshRate !== undefined) {
                    if (testSpecs.refreshRate !== undefined) {
                        if (baselineSpecs.refreshRate === testSpecs.refreshRate) {
                            foundSpecs.push(`${baselineSpecs.refreshRate}Hz`);
                        } else {
                            mismatchedSpecs.push(`åˆ·æ–°ç‡ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.refreshRate}Hz vs æµ‹è¯•${testSpecs.refreshRate}Hz`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.refreshRate}Hz`);
                    }
                }
                
                // 5. åˆ¤æ–­æ˜¯å¦åŒ¹é…
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Displayå…³é”®å‚æ•°å®Œå…¨åŒ¹é…: ${foundSpecs.join(', ')} (å·²å¿½ç•¥å…¶ä»–æ˜¾ç¤ºç‰¹æ€§)`;
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`æœªæ‰¾åˆ°: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Displayå‚æ•°æ£€éªŒå¤±è´¥: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG
                };
                
            } catch (error) {
                return { isValid: false, message: `Displayæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Storageæ£€éªŒå‡½æ•°
        function checkStorage(baselineValue, testValue, sheetHD) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Storageæ•°æ®' };
                }
                
                if (!sheetHD) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°HDå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Storageå€¼:', baselineStr);
                
                // ä»åŸºå‡†å€¼ä¸­æå–æ•°å­—ï¼ˆå­˜å‚¨å®¹é‡ï¼‰
                const baselineMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!baselineMatch) {
                    return { isValid: false, message: `åŸºå‡†Storageå€¼æ ¼å¼æ— æ•ˆï¼Œæ— æ³•æå–æ•°å­—ã€‚å½“å‰å€¼: "${baselineStr}"` };
                }
                
                const baselineCapacity = parseFloat(baselineMatch[1]);
                console.log('åŸºå‡†å­˜å‚¨å®¹é‡:', baselineCapacity);
                
                // æ£€æŸ¥HDå·¥ä½œè¡¨çš„M1ã€M2ã€E1ã€E2ã€N1ã€N2å•å…ƒæ ¼
                const m1Cell = sheetHD['M1'];
                const m2Cell = sheetHD['M2'];
                const e1Cell = sheetHD['E1'];
                const e2Cell = sheetHD['E2'];
                const n1Cell = sheetHD['N1'];
                const n2Cell = sheetHD['N2'];
                
                const m1Value = m1Cell ? String(m1Cell.v || '').trim() : '';
                const m2Value = m2Cell ? m2Cell.v : '';
                const e1Value = e1Cell ? String(e1Cell.v || '').trim() : '';
                const e2Value = e2Cell ? String(e2Cell.v || '').trim() : '';
                const n1Value = n1Cell ? String(n1Cell.v || '').trim() : '';
                const n2Value = n2Cell ? String(n2Cell.v || '').trim() : '';
                
                console.log('HDå·¥ä½œè¡¨ M1:', m1Value);
                console.log('HDå·¥ä½œè¡¨ M2:', m2Value);
                console.log('HDå·¥ä½œè¡¨ E1:', e1Value);
                console.log('HDå·¥ä½œè¡¨ E2:', e2Value);
                console.log('HDå·¥ä½œè¡¨ N1:', n1Value);
                console.log('HDå·¥ä½œè¡¨ N2:', n2Value);
                
                // æ£€æŸ¥M1æ˜¯å¦ä¸ºHDDCAPACITY
                if (m1Value.toUpperCase() !== 'HDDCAPACITY') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HDå·¥ä½œè¡¨M1åº”ä¸º"HDDCAPACITY"ï¼Œå®é™…ä¸º"${m1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // æ£€æŸ¥E1æ˜¯å¦ä¸ºBRANDCODEF
                if (e1Value.toUpperCase() !== 'BRANDCODEF') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HDå·¥ä½œè¡¨E1åº”ä¸º"BRANDCODEF"ï¼Œå®é™…ä¸º"${e1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // æ£€æŸ¥E2æ˜¯å¦ä¸ºMBG
                if (e2Value.toUpperCase() !== 'MBG') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HDå·¥ä½œè¡¨E2åº”ä¸º"MBG"ï¼Œå®é™…ä¸º"${e2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // æ£€æŸ¥N1æ˜¯å¦ä¸ºHDDCAPACITYUNITS
                if (n1Value.toUpperCase() !== 'HDDCAPACITYUNITS') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HDå·¥ä½œè¡¨N1åº”ä¸º"HDDCAPACITYUNITS"ï¼Œå®é™…ä¸º"${n1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // æ£€æŸ¥N2æ˜¯å¦ä¸ºGB
                if (n2Value.toUpperCase() !== 'GB') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HDå·¥ä½œè¡¨N2åº”ä¸º"GB"ï¼Œå®é™…ä¸º"${n2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // æ£€æŸ¥M2æ˜¯å¦ä¸ºæ•°å­—
                let testCapacity;
                if (typeof m2Value === 'number') {
                    testCapacity = m2Value;
                } else {
                    const m2Match = String(m2Value).match(/(\d+(?:\.\d+)?)/);
                    if (!m2Match) {
                        return {
                            isValid: true,
                            isMatch: false,
                            message: `HDå·¥ä½œè¡¨M2åº”ä¸ºæ•°å­—ï¼Œå®é™…ä¸º"${m2Value}"`,
                            baselineCapacity: baselineCapacity,
                            testCapacity: null,
                            hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                        };
                    }
                    testCapacity = parseFloat(m2Match[1]);
                }
                
                console.log('æµ‹è¯•å­˜å‚¨å®¹é‡:', testCapacity);
                
                // ä½¿ç”¨æ•°å­—æ ‡å‡†åŒ–è¿›è¡Œæ¯”è¾ƒ
                const baselineNormalized = parseFloat(baselineCapacity.toString());
                const testNormalized = parseFloat(testCapacity.toString());
                
                const isMatch = baselineNormalized === testNormalized;
                
                let message = '';
                if (isMatch) {
                    message = `å­˜å‚¨å®¹é‡åŒ¹é…: ${baselineCapacity} = ${testCapacity}ï¼ŒBRANDCODEFéªŒè¯é€šè¿‡ï¼Œå•ä½ä¸ºGB`;
                } else {
                    message = `å­˜å‚¨å®¹é‡ä¸åŒ¹é…: åŸºå‡†å€¼${baselineCapacity} â‰  æµ‹è¯•å€¼${testCapacity}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineCapacity: baselineCapacity,
                    testCapacity: testCapacity,
                    hdCells: `M1: ${m1Value}, M2: ${testCapacity}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Storageæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Memoryæ£€éªŒå‡½æ•°
        function checkMemory(baselineValue, testValue, sheetMEM) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Memoryæ•°æ®' };
                }
                
                if (!sheetMEM) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°MEMå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Memoryå€¼:', baselineStr);
                
                // ä»åŸºå‡†å€¼ä¸­æå–æ•°å­—ï¼ˆå†…å­˜å®¹é‡ï¼‰
                const baselineMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!baselineMatch) {
                    return { isValid: false, message: `åŸºå‡†Memoryå€¼æ ¼å¼æ— æ•ˆï¼Œæ— æ³•æå–æ•°å­—ã€‚å½“å‰å€¼: "${baselineStr}"` };
                }
                
                const baselineCapacity = parseFloat(baselineMatch[1]);
                console.log('åŸºå‡†å†…å­˜å®¹é‡:', baselineCapacity);
                
                // æ£€æŸ¥MEMå·¥ä½œè¡¨çš„G1å’ŒG2å•å…ƒæ ¼
                const g1Cell = sheetMEM['G1'];
                const g2Cell = sheetMEM['G2'];
                
                const g1Value = g1Cell ? String(g1Cell.v || '').trim() : '';
                const g2Value = g2Cell ? g2Cell.v : '';
                
                // æ£€æŸ¥MEMå·¥ä½œè¡¨çš„E1å’ŒE2å•å…ƒæ ¼ï¼ˆBRANDCODEFï¼‰
                const e1Cell = sheetMEM['E1'];
                const e2Cell = sheetMEM['E2'];
                
                const e1Value = e1Cell ? String(e1Cell.v || '').trim() : '';
                const e2Value = e2Cell ? String(e2Cell.v || '').trim() : '';
                
                console.log('MEMå·¥ä½œè¡¨ G1:', g1Value);
                console.log('MEMå·¥ä½œè¡¨ G2:', g2Value);
                console.log('MEMå·¥ä½œè¡¨ E1:', e1Value);
                console.log('MEMå·¥ä½œè¡¨ E2:', e2Value);
                
                // æ£€æŸ¥G1æ˜¯å¦ä¸ºMEMCAPACITY
                if (g1Value.toUpperCase() !== 'MEMCAPACITY') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEMå·¥ä½œè¡¨G1åº”ä¸º"MEMCAPACITY"ï¼Œå®é™…ä¸º"${g1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // æ£€æŸ¥E1æ˜¯å¦ä¸ºBRANDCODEF
                if (e1Value.toUpperCase() !== 'BRANDCODEF') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEMå·¥ä½œè¡¨E1åº”ä¸º"BRANDCODEF"ï¼Œå®é™…ä¸º"${e1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // æ£€æŸ¥E2æ˜¯å¦ä¸ºMBG
                if (e2Value.toUpperCase() !== 'MBG') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEMå·¥ä½œè¡¨E2åº”ä¸º"MBG"ï¼Œå®é™…ä¸º"${e2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // æ£€æŸ¥G2æ˜¯å¦ä¸ºæ•°å­—
                let testCapacity;
                if (typeof g2Value === 'number') {
                    testCapacity = g2Value;
                } else {
                    const g2Match = String(g2Value).match(/(\d+(?:\.\d+)?)/);
                    if (!g2Match) {
                        return {
                            isValid: true,
                            isMatch: false,
                            message: `MEMå·¥ä½œè¡¨G2åº”ä¸ºæ•°å­—ï¼Œå®é™…ä¸º"${g2Value}"`,
                            baselineCapacity: baselineCapacity,
                            testCapacity: null,
                            g1Value: g1Value,
                            g2Value: g2Value,
                            e1Value: e1Value,
                            e2Value: e2Value,
                            memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                        };
                    }
                    testCapacity = parseFloat(g2Match[1]);
                }
                
                console.log('æµ‹è¯•å†…å­˜å®¹é‡:', testCapacity);
                
                // ä½¿ç”¨æ•°å­—æ ‡å‡†åŒ–è¿›è¡Œæ¯”è¾ƒ
                const baselineNormalized = parseFloat(baselineCapacity.toString());
                const testNormalized = parseFloat(testCapacity.toString());
                
                const isMatch = baselineNormalized === testNormalized;
                
                let message = '';
                if (isMatch) {
                    message = `å†…å­˜å®¹é‡åŒ¹é…: ${baselineCapacity} = ${testCapacity}ï¼ŒBRANDCODEFéªŒè¯é€šè¿‡`;
                } else {
                    message = `å†…å­˜å®¹é‡ä¸åŒ¹é…: åŸºå‡†å€¼${baselineCapacity} â‰  æµ‹è¯•å€¼${testCapacity}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineCapacity: baselineCapacity,
                    testCapacity: testCapacity,
                    g1Value: g1Value,
                    g2Value: g2Value,
                    e1Value: e1Value,
                    e2Value: e2Value,
                    memCells: `G1: ${g1Value}, G2: ${testCapacity}, E1: ${e1Value}, E2: ${e2Value}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Memoryæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Graphicsæ£€éªŒå‡½æ•°
        function checkGraphics(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Graphicsæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æ¸…ç†å’Œæ ‡å‡†åŒ–Graphics tokençš„å‡½æ•°
                function cleanAndNormalizeGraphicsToken(token) {
                    // ç»Ÿä¸€è½¬æ¢ä¸ºå¤§å†™
                    let cleaned = token.toUpperCase();
                    
                    // å°† - æ›¿æ¢ä¸ºç©ºæ ¼
                    cleaned = cleaned.replace(/-/g, ' ');
                    
                    // ç§»é™¤å¤šä½™çš„ç©ºæ ¼å¹¶åˆ†å‰²
                    return cleaned.trim().split(/\s+/).filter(t => t.length > 0);
                }
                
                // 3. å¤„ç†baselineå’Œtest tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æ¸…ç†å’Œæ ‡å‡†åŒ–tokens
                const baselineTokens = [];
                rawBaselineTokens.forEach(token => {
                    const cleaned = cleanAndNormalizeGraphicsToken(token);
                    baselineTokens.push(...cleaned);
                });
                
                const testTokens = [];
                rawTestTokens.forEach(token => {
                    if (token.toUpperCase() !== 'MBG') {
                        const cleaned = cleanAndNormalizeGraphicsToken(token);
                        testTokens.push(...cleaned);
                    }
                });
                
                // 4. æ£€æŸ¥åŸºå‡†è¡¨çš„æ¯ä¸ªtokenæ˜¯å¦éƒ½èƒ½åœ¨æµ‹è¯•è¡¨ä¸­æ‰¾åˆ°
                const missingTokens = [];
                const foundTokens = [];
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                baselineTokens.forEach(baselineToken => {
                    const found = testTokens.includes(baselineToken);
                    
                    if (found) {
                        foundTokens.push(baselineToken);
                        // æ‰¾åˆ°åŸå§‹token
                        const originalToken = rawBaselineTokens.find(token => 
                            cleanAndNormalizeGraphicsToken(token).includes(baselineToken)
                        );
                        if (originalToken && !originalFoundTokens.includes(originalToken)) {
                            originalFoundTokens.push(originalToken);
                        }
                    } else {
                        missingTokens.push(baselineToken);
                        // æ‰¾åˆ°åŸå§‹token
                        const originalToken = rawBaselineTokens.find(token => 
                            cleanAndNormalizeGraphicsToken(token).includes(baselineToken)
                        );
                        if (originalToken && !originalMissingTokens.includes(originalToken)) {
                            originalMissingTokens.push(originalToken);
                        }
                    }
                });
                
                const allTokensFound = missingTokens.length === 0;
                const isMatch = hasMBG && allTokensFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Graphicsä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”æ‰€æœ‰åŸºå‡†tokenéƒ½æ‰¾åˆ°';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else if (!allTokensFound) {
                    message = `Graphics tokenä¸åŒ¹é…ï¼Œæœªæ‰¾åˆ°: ${missingTokens.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineTokens,
                    cleanedTestTokens: testTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `Graphicsæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Wirelessæ£€éªŒå‡½æ•°
        function checkWireless(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Wirelessæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æå–æ•°å­—çš„å‡½æ•°
                function extractNumbers(text) {
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. æå–å­—æ¯tokençš„å‡½æ•°ï¼ˆæ›¿æ¢æ ‡ç‚¹ä¸ºç©ºæ ¼åæå–ï¼‰
                function extractLetterTokens(text) {
                    // ç§»é™¤MBGå’Œæ•°å­—ï¼Œå°†æ‰€æœ‰æ ‡ç‚¹ç¬¦å·æ›¿æ¢ä¸ºç©ºæ ¼
                    let cleanText = text.replace(/MBG/gi, '').replace(/\d+(?:\.\d+)?/g, '');
                    // å°†æ‰€æœ‰æ ‡ç‚¹ç¬¦å·æ›¿æ¢ä¸ºç©ºæ ¼
                    cleanText = cleanText.replace(/[^\w\s]/g, ' ');
                    // æŒ‰ç©ºæ ¼åˆ†å‰²ï¼Œæå–åŒ…å«å­—æ¯çš„éƒ¨åˆ†
                    const tokens = cleanText.split(/\s+/).map(token => token.trim()).filter(token => token.length > 0 && /[a-zA-Z]/.test(token));
                    return tokens.map(token => token.toLowerCase());
                }
                
                // 4. å¤„ç†baselineå’Œtestæ•°æ®
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–æ•°å­—
                const baselineNumbers = extractNumbers(baselineStr);
                const testNumbers = extractNumbers(testStr.replace(/MBG/gi, ''));
                
                // æå–å­—æ¯tokens
                const baselineLetterTokens = extractLetterTokens(baselineStr);
                const testLetterTokens = extractLetterTokens(testStr);
                
                // 5. æ£€æŸ¥å­—æ¯åŒ¹é… - æµ‹è¯•ä¸­çš„å­—æ¯èƒ½åœ¨åŸºå‡†ä¸­æ‰¾åˆ°
                const missingLetters = [];
                const foundLetters = [];
                
                testLetterTokens.forEach(testLetter => {
                    if (baselineLetterTokens.includes(testLetter)) {
                        foundLetters.push(testLetter);
                    } else {
                        missingLetters.push(testLetter);
                    }
                });
                
                const allLettersFound = missingLetters.length === 0;
                
                // 6. æ£€æŸ¥æ•°å­—åŒ¹é… - æµ‹è¯•ä¸­çš„æ•°å­—èƒ½åœ¨åŸºå‡†ä¸­æ‰¾åˆ°
                const missingNumbers = [];
                const foundNumbers = [];
                
                testNumbers.forEach(testNum => {
                    if (baselineNumbers.includes(testNum)) {
                        foundNumbers.push(testNum);
                    } else {
                        missingNumbers.push(testNum);
                    }
                });
                
                const allNumbersFound = missingNumbers.length === 0;
                const isMatch = hasMBG && allNumbersFound && allLettersFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Wirelessä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGã€æ•°å­—åŒ¹é…ä¸”å­—æ¯tokenéƒ½æ‰¾åˆ°';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else if (!allNumbersFound) {
                    message = `Wirelessæ•°å­—ä¸åŒ¹é…ï¼Œæµ‹è¯•ä¸­æœªåœ¨åŸºå‡†ä¸­æ‰¾åˆ°: ${missingNumbers.join(', ')}`;
                } else if (!allLettersFound) {
                    message = `Wirelesså­—æ¯ä¸åŒ¹é…ï¼Œæµ‹è¯•ä¸­æœªåœ¨åŸºå‡†ä¸­æ‰¾åˆ°: ${missingLetters.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: [...foundNumbers.map(n => n.toString()), ...foundLetters],
                    missingTokens: [...missingNumbers.map(n => n.toString()), ...missingLetters],
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: {
                        numbers: baselineNumbers,
                        letterTokens: baselineLetterTokens
                    },
                    cleanedTestTokens: {
                        numbers: testNumbers,
                        letterTokens: testLetterTokens
                    }
                };
                
            } catch (error) {
                return { isValid: false, message: `Wirelessæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Bluetoothæ£€éªŒå‡½æ•°
        function checkBluetooth(baselineValue, testValue, objectElementWsValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Bluetoothæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥OBJECT-ELEMENTçš„Cåˆ—æ˜¯å¦åŒ…å« "MBG"ï¼ˆå¦‚æœæä¾›äº†è¯¥å‚æ•°ï¼‰
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementWsValue !== null) {
                    // ä»OBJECT-ELEMENTçš„Cåˆ—æ£€æŸ¥MBG
                    const objectElementStr = String(objectElementWsValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT Cåˆ—';
                } else {
                    // é™çº§åˆ°ä»WSå·¥ä½œè¡¨çš„å€¼æ£€æŸ¥MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'WSå·¥ä½œè¡¨';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`,
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. æ™ºèƒ½æå–æ•°å­—tokençš„å‡½æ•° - é¿å…åè®®åç§°ä¸­çš„æ•°å­—
                function extractBluetoothNumbers(text) {
                    // å·²çŸ¥çš„Bluetoothåè®®åç§°ï¼ŒåŒ…å«æ•°å­—ä½†ä¸åº”è¯¥è¢«æå–
                    const protocolPatterns = [
                        /A2DP/gi,
                        /HFP/gi,
                        /HSP/gi,
                        /AVRCP/gi,
                        /HID/gi,
                        /OPP/gi,
                        /FTP/gi,
                        /BIP/gi,
                        /PBAP/gi,
                        /MAP/gi,
                        /DUN/gi,
                        /PAN/gi,
                        /SPP/gi
                    ];
                    
                    // é¦–å…ˆç§»é™¤å·²çŸ¥çš„åè®®åç§°ï¼Œé˜²æ­¢æå–å…¶ä¸­çš„æ•°å­—
                    let cleanedText = text;
                    protocolPatterns.forEach(pattern => {
                        cleanedText = cleanedText.replace(pattern, ' ');
                    });
                    
                    console.log('BluetoothåŸå§‹æ–‡æœ¬:', text);
                    console.log('ç§»é™¤åè®®åçš„æ–‡æœ¬:', cleanedText);
                    
                    // ä»æ¸…ç†åçš„æ–‡æœ¬ä¸­æå–ç‹¬ç«‹çš„æ•°å­—ï¼ˆå‰åå¿…é¡»æ˜¯ç©ºæ ¼ã€æ ‡ç‚¹æˆ–å­—ç¬¦ä¸²å¼€å§‹/ç»“æŸï¼‰
                    const numbers = [];
                    const numberMatches = cleanedText.match(/(?:^|[\s,;])(\d+(?:\.\d+)?)(?=[\s,;]|$)/g);
                    
                    if (numberMatches) {
                        numberMatches.forEach(match => {
                            const num = parseFloat(match.trim());
                            if (!isNaN(num)) {
                                numbers.push(num);
                            }
                        });
                    }
                    
                    console.log('æå–çš„æ•°å­—:', numbers);
                    return numbers;
                }
                
                // 3. å¤„ç†baselineå’Œtest tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–æ•°å­—tokensï¼ˆé¿å…åè®®åç§°ä¸­çš„æ•°å­—ï¼‰
                const baselineNumbers = extractBluetoothNumbers(baselineStr);
                const testNumbers = extractBluetoothNumbers(testStr.replace(/MBG/gi, '')); // ç§»é™¤MBGåæå–æ•°å­—
                
                // 4. æ£€æŸ¥æ•°å­—æ˜¯å¦ç›¸åŒï¼ˆé¡ºåºæ— å…³ï¼‰
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);
                
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);
                
                const isMatch = hasMBG && numbersMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Bluetoothä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”ç‰ˆæœ¬å·ç›¸åŒ (MBGæ£€æŸ¥æ¥æº: ${mbgCheckSource}, å·²æ’é™¤åè®®åç§°ä¸­çš„æ•°å­—)`;
                } else if (!hasMBG) {
                    message = `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                } else if (!numbersMatch) {
                    message = `Bluetoothç‰ˆæœ¬å·ä¸åŒ¹é…ï¼ŒåŸºå‡†: [${sortedBaselineNumbers.join(', ')}], æµ‹è¯•: [${sortedTestNumbers.join(', ')}] (MBGæ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: isMatch ? sortedTestNumbers.map(n => n.toString()) : [],
                    missingTokens: !numbersMatch ? sortedBaselineNumbers.filter(n => !sortedTestNumbers.includes(n)).map(n => n.toString()) : [],
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineNumbers,
                    cleanedTestTokens: testNumbers,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Bluetoothæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Cameraæ£€éªŒå‡½æ•°
        function checkCamera(baselineValue, testValue, objectElementCamValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Cameraæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥OBJECT-ELEMENTçš„Cåˆ—æ˜¯å¦åŒ…å« "MBG"ï¼ˆå¦‚æœæä¾›äº†è¯¥å‚æ•°ï¼‰
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementCamValue !== null) {
                    // ä»OBJECT-ELEMENTçš„Cåˆ—æ£€æŸ¥MBG
                    const objectElementStr = String(objectElementCamValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT Cåˆ—';
                } else {
                    // é™çº§åˆ°ä»CAMå·¥ä½œè¡¨çš„å€¼æ£€æŸ¥MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'CAMå·¥ä½œè¡¨';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`,
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. æå–å…³é”®Cameraå‚æ•°çš„å‡½æ•°
                function extractCameraSpecs(text) {
                    const specs = {};
                    
                    console.log('æå–Cameraè§„æ ¼ï¼ŒåŸå§‹æ–‡æœ¬:', text);
                    
                    // æå–åƒç´  (MP)
                    const mpMatch = text.match(/(\d+)\s*MP/i);
                    if (mpMatch) {
                        specs.pixels = parseInt(mpMatch[1]);
                        console.log('æ‰¾åˆ°åƒç´ :', specs.pixels + 'MP');
                    }
                    
                    // æå–å…‰åœˆ (f/æ•°å­—)
                    const apertureMatch = text.match(/f\/(\d+\.\d+)/i);
                    if (apertureMatch) {
                        specs.aperture = parseFloat(apertureMatch[1]);
                        console.log('æ‰¾åˆ°å…‰åœˆ:', 'f/' + specs.aperture);
                    }
                    
                    // æå–åƒç´ å°ºå¯¸ (æ•°å­—Âµm æˆ– æ•°å­—Î¼m)
                    const pixelSizeMatch = text.match(/(\d+(?:\.\d+)?)[ÂµÎ¼]m/i);
                    if (pixelSizeMatch) {
                        specs.pixelSize = parseFloat(pixelSizeMatch[1]);
                        console.log('æ‰¾åˆ°åƒç´ å°ºå¯¸:', specs.pixelSize + 'Âµm');
                    }
                    
                    console.log('æå–çš„è§„æ ¼:', specs);
                    return specs;
                }
                
                // 3. æå–åŸºå‡†å’Œæµ‹è¯•è§„æ ¼
                const baselineSpecs = extractCameraSpecs(baselineStr);
                const testSpecs = extractCameraSpecs(testStr);
                
                // 4. æ¯”è¾ƒå…³é”®å‚æ•°
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // æ£€æŸ¥åƒç´ 
                if (baselineSpecs.pixels !== undefined) {
                    if (testSpecs.pixels !== undefined) {
                        if (baselineSpecs.pixels === testSpecs.pixels) {
                            foundSpecs.push(`${baselineSpecs.pixels}MP`);
                        } else {
                            mismatchedSpecs.push(`åƒç´ ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.pixels}MP vs æµ‹è¯•${testSpecs.pixels}MP`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixels}MP`);
                    }
                }
                
                // æ£€æŸ¥å…‰åœˆ
                if (baselineSpecs.aperture !== undefined) {
                    if (testSpecs.aperture !== undefined) {
                        if (baselineSpecs.aperture === testSpecs.aperture) {
                            foundSpecs.push(`f/${baselineSpecs.aperture}`);
                        } else {
                            mismatchedSpecs.push(`å…‰åœˆä¸åŒ¹é…: åŸºå‡†f/${baselineSpecs.aperture} vs æµ‹è¯•f/${testSpecs.aperture}`);
                        }
                    } else {
                        missingSpecs.push(`f/${baselineSpecs.aperture}`);
                    }
                }
                
                // æ£€æŸ¥åƒç´ å°ºå¯¸
                if (baselineSpecs.pixelSize !== undefined) {
                    if (testSpecs.pixelSize !== undefined) {
                        if (baselineSpecs.pixelSize === testSpecs.pixelSize) {
                            foundSpecs.push(`${baselineSpecs.pixelSize}Âµm`);
                        } else {
                            mismatchedSpecs.push(`åƒç´ å°ºå¯¸ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.pixelSize}Âµm vs æµ‹è¯•${testSpecs.pixelSize}Âµm`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixelSize}Âµm`);
                    }
                }
                
                // 5. åˆ¤æ–­æ˜¯å¦åŒ¹é…
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Cameraå…³é”®å‚æ•°å®Œå…¨åŒ¹é…: ${foundSpecs.join(', ')} (MBGæ£€æŸ¥æ¥æº: ${mbgCheckSource}, å·²å¿½ç•¥ç„¦è·ã€ä¼ æ„Ÿå™¨ç­‰å…¶ä»–å‚æ•°)`;
                } else if (!hasMBG) {
                    message = `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`æœªæ‰¾åˆ°: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Cameraå‚æ•°æ£€éªŒå¤±è´¥: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Cameraæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Battery Lifeæ£€éªŒå‡½æ•°ï¼ˆä¿®æ”¹ç‰ˆï¼‰
        function checkBatteryLife(baselineValue, testSheetTI) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Battery LifeåŸºå‡†æ•°æ®' };
                }
                
                if (!testSheetTI) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶ä¸­æœªæ‰¾åˆ°TIå·¥ä½œè¡¨' };
                }
                
                // è·å–TIè¡¨çš„E2å’ŒF2å•å…ƒæ ¼
                const e2Cell = testSheetTI['E2'];
                const f2Cell = testSheetTI['F2'];
                
                if (!e2Cell) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶TIè¡¨ä¸­æœªæ‰¾åˆ°E2å•å…ƒæ ¼æ•°æ®' };
                }
                
                if (!f2Cell) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶TIè¡¨ä¸­æœªæ‰¾åˆ°F2å•å…ƒæ ¼æ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const e2Value = String(e2Cell.v || '').trim();
                const f2Value = String(f2Cell.v || '').trim();
                
                console.log('Battery Lifeæ£€éªŒ:');
                console.log('åŸºå‡†å€¼:', baselineStr);
                console.log('TI-E2å€¼:', e2Value);
                console.log('TI-F2å€¼:', f2Value);
                
                // 1. æ£€æŸ¥F2å•å…ƒæ ¼æ˜¯å¦åŒ…å«"MBG"
                const hasMBG = f2Value.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'TIè¡¨F2å•å…ƒæ ¼å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineValue: baselineStr,
                        e2Value: e2Value,
                        f2Value: f2Value,
                        hasMBG: false,
                        baselineNumbers: [],
                        testNumbers: []
                    };
                }
                
                // 2. æå–æ‰€æœ‰æ•°å­—çš„å‡½æ•°
                function extractNumericTokens(text) {
                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬å°æ•°ï¼‰
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. ä»åŸºå‡†å€¼å’ŒE2å•å…ƒæ ¼ä¸­æå–æ•°å­—
                const baselineNumbers = extractNumericTokens(baselineStr);
                const testNumbers = extractNumericTokens(e2Value);
                
                console.log('åŸºå‡†å€¼æ•°å­—:', baselineNumbers);
                console.log('E2å•å…ƒæ ¼æ•°å­—:', testNumbers);
                
                // 4. æ£€æŸ¥æ•°å­—æ˜¯å¦ç›¸åŒæˆ–éƒ¨åˆ†åŒ¹é…
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);

                // æ£€æŸ¥ä¸¥æ ¼åŒ¹é…
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);

                // æ£€æŸ¥å®½æ¾åŒ¹é…ï¼ˆæµ‹è¯•å€¼æ˜¯åŸºå‡†çš„å­é›†ï¼‰
                const subsetMatch = sortedTestNumbers.every(num => sortedBaselineNumbers.includes(num));

                // 5. åˆ¤æ–­æ•´ä½“åŒ¹é…çŠ¶æ€
                let isMatch = hasMBG && (numbersMatch || subsetMatch);
                let message = '';

                if (isMatch && numbersMatch) {
                    message = `Battery Lifeå®Œå…¨åŒ¹é…ï¼šF2åŒ…å«MBGï¼ŒE2æ•°å­— [${sortedTestNumbers.join(', ')}] ä¸åŸºå‡†å€¼ [${sortedBaselineNumbers.join(', ')}] ç›¸åŒ`;
                } else if (isMatch && subsetMatch) {
                    message = `Battery Lifeéƒ¨åˆ†åŒ¹é…ï¼šF2åŒ…å«MBGï¼ŒE2æ•°å­— [${sortedTestNumbers.join(', ')}] æ˜¯åŸºå‡†å€¼ [${sortedBaselineNumbers.join(', ')}] çš„å­é›†`;
                } else if (!hasMBG) {
                    message = 'TIè¡¨F2å•å…ƒæ ¼å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    message = `Battery Lifeæ•°å­—ä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼æ•°å­—: [${sortedBaselineNumbers.join(', ')}], E2æ•°å­—: [${sortedTestNumbers.join(', ')}]`;
                }

                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineStr,
                    e2Value: e2Value,
                    f2Value: f2Value,
                    hasMBG: hasMBG,
                    baselineNumbers: sortedBaselineNumbers,
                    testNumbers: sortedTestNumbers,
                    numbersMatch: numbersMatch
                };
                
            } catch (error) {
                return { isValid: false, message: `Battery Lifeæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Fingerprint Readeræ£€éªŒå‡½æ•°
        function checkFingerprintReader(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Fingerprint Readeræ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. å®šä¹‰ä½ç½®æ˜ å°„å…³ç³»ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
                const positionMapping = {
                    'on-screen': 'display',
                    'back': 'back',
                    'side': 'side'
                };
                
                // 3. æ£€æŸ¥åŸºå‡†ä¸­çš„ä½ç½®token
                function extractPositionTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundPositions = [];
                    
                    Object.keys(positionMapping).forEach(baselinePos => {
                        if (cleanText.includes(baselinePos)) {
                            foundPositions.push(baselinePos);
                        }
                    });
                    
                    return foundPositions;
                }
                
                // 4. æ£€æŸ¥æµ‹è¯•ä¸­çš„ä½ç½®token
                function extractTestPositionTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundPositions = [];
                    
                    Object.values(positionMapping).forEach(testPos => {
                        if (cleanText.includes(testPos)) {
                            foundPositions.push(testPos);
                        }
                    });
                    
                    return foundPositions;
                }
                
                // 5. å¤„ç†baselineå’Œtestæ•°æ®
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–ä½ç½®tokens
                const baselinePositions = extractPositionTokens(baselineStr);
                const testPositions = extractTestPositionTokens(testStr.replace(/MBG/gi, '')); // ç§»é™¤MBGåæå–
                
                // 6. æ£€æŸ¥åŒ¹é…è§„åˆ™
                const missingMappings = [];
                const extraPositions = [];
                const foundMappings = [];
                
                // æ£€æŸ¥åŸºå‡†ä¸­çš„ä½ç½®æ˜¯å¦åœ¨æµ‹è¯•ä¸­æœ‰å¯¹åº”çš„æ˜ å°„
                baselinePositions.forEach(baselinePos => {
                    const expectedTestPos = positionMapping[baselinePos];
                    if (testPositions.includes(expectedTestPos)) {
                        foundMappings.push(`${baselinePos} -> ${expectedTestPos}`);
                    } else {
                        missingMappings.push(`${baselinePos} -> ${expectedTestPos}`);
                    }
                });
                
                // æ£€æŸ¥æµ‹è¯•ä¸­æ˜¯å¦æœ‰åŸºå‡†æ²¡æœ‰è¦æ±‚çš„ä½ç½®
                const allExpectedTestPositions = baselinePositions.map(pos => positionMapping[pos]);
                testPositions.forEach(testPos => {
                    if (!allExpectedTestPositions.includes(testPos)) {
                        extraPositions.push(testPos);
                    }
                });
                
                const isMatch = hasMBG && missingMappings.length === 0 && extraPositions.length === 0;
                
                let message = '';
                if (isMatch) {
                    if (foundMappings.length > 0) {
                        message = `Fingerprint Readerä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”ä½ç½®æ˜ å°„æ­£ç¡® (${foundMappings.join(', ')})`;
                    } else {
                        message = 'Fingerprint Readerä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”æ— ä½ç½®è¦æ±‚';
                    }
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    const issues = [];
                    if (missingMappings.length > 0) {
                        issues.push(`ç¼ºå°‘ä½ç½®æ˜ å°„: ${missingMappings.join(', ')}`);
                    }
                    if (extraPositions.length > 0) {
                        issues.push(`å¤šä½™çš„ä½ç½®: ${extraPositions.join(', ')}`);
                    }
                    message = `Fingerprint Readerä½ç½®ä¸åŒ¹é… - ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundMappings,
                    missingTokens: missingMappings,
                    extraTokens: extraPositions,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselinePositions,
                    cleanedTestTokens: testPositions
                };
                
            } catch (error) {
                return { isValid: false, message: `Fingerprint Readeræ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Audioæ£€éªŒå‡½æ•°
        function checkAudio(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Audioæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. å®šä¹‰å…³é”®tokenï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
                const keyTokens = ['dual', 'dolby atmos'];
                
                // 3. æå–å…³é”®tokençš„å‡½æ•°ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
                function extractKeyTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundTokens = [];
                    
                    keyTokens.forEach(token => {
                        if (cleanText.includes(token.toLowerCase())) {
                            foundTokens.push(token);
                        }
                    });
                    
                    return foundTokens;
                }
                
                // 4. å¤„ç†baselineå’Œtestæ•°æ®
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–å…³é”®tokens
                const baselineKeyTokens = extractKeyTokens(baselineStr);
                const testKeyTokens = extractKeyTokens(testStr.replace(/MBG/gi, '')); // ç§»é™¤MBGåæå–
                
                // 5. æ£€æŸ¥è§„åˆ™ï¼šå¦‚æœåŸºå‡†æœ‰ï¼Œæµ‹è¯•ä¸€å®šè¦æœ‰ï¼›å¦‚æœåŸºå‡†æ²¡æœ‰ï¼Œæµ‹è¯•å°±ä¸èƒ½æœ‰
                const missingTokens = [];
                const extraTokens = [];
                const foundTokens = [];
                
                // æ£€æŸ¥åŸºå‡†ä¸­çš„tokenæ˜¯å¦åœ¨æµ‹è¯•ä¸­å­˜åœ¨
                baselineKeyTokens.forEach(baselineToken => {
                    if (testKeyTokens.includes(baselineToken)) {
                        foundTokens.push(baselineToken);
                    } else {
                        missingTokens.push(baselineToken);
                    }
                });
                
                // æ£€æŸ¥æµ‹è¯•ä¸­æ˜¯å¦æœ‰åŸºå‡†æ²¡æœ‰çš„token
                testKeyTokens.forEach(testToken => {
                    if (!baselineKeyTokens.includes(testToken)) {
                        extraTokens.push(testToken);
                    }
                });
                
                const isMatch = hasMBG && missingTokens.length === 0 && extraTokens.length === 0;
                
                let message = '';
                if (isMatch) {
                    message = 'Audioä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”å…³é”®tokenä¸€è‡´';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    const issues = [];
                    if (missingTokens.length > 0) {
                        issues.push(`ç¼ºå°‘å…³é”®token: ${missingTokens.join(', ')}`);
                    }
                    if (extraTokens.length > 0) {
                        issues.push(`å¤šä½™çš„å…³é”®token: ${extraTokens.join(', ')}`);
                    }
                    message = `Audioå…³é”®tokenä¸åŒ¹é… - ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundTokens,
                    missingTokens: missingTokens,
                    extraTokens: extraTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineKeyTokens,
                    cleanedTestTokens: testKeyTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `Audioæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Warrantyæ£€éªŒå‡½æ•°
        function checkWarranty(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Warrantyæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æå–æ‰€æœ‰æ•°å­—çš„å‡½æ•°
                function extractNumbers(text) {
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. å¤„ç†baselineå’Œtestæ•°æ®
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–æ•°å­—
                const baselineNumbers = extractNumbers(baselineStr);
                const testNumbers = extractNumbers(testStr.replace(/MBG/gi, '')); // ç§»é™¤MBGåæå–æ•°å­—
                
                // 4. æ£€æŸ¥åŸºå‡†ä¸­çš„æ•°å­—èƒ½åœ¨æµ‹è¯•ä¸­æ‰¾åˆ°
                const missingNumbers = [];
                const foundNumbers = [];
                
                baselineNumbers.forEach(baselineNum => {
                    if (testNumbers.includes(baselineNum)) {
                        foundNumbers.push(baselineNum);
                    } else {
                        missingNumbers.push(baselineNum);
                    }
                });
                
                const allNumbersFound = missingNumbers.length === 0;
                const isMatch = hasMBG && allNumbersFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Warrantyä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”åŸºå‡†ä¸­æ‰€æœ‰æ•°å­—éƒ½åœ¨æµ‹è¯•ä¸­æ‰¾åˆ°';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else if (!allNumbersFound) {
                    message = `Warrantyæ•°å­—ä¸åŒ¹é…ï¼ŒåŸºå‡†ä¸­æœªåœ¨æµ‹è¯•ä¸­æ‰¾åˆ°: ${missingNumbers.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundNumbers.map(n => n.toString()),
                    missingTokens: missingNumbers.map(n => n.toString()),
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineNumbers,
                    cleanedTestTokens: testNumbers
                };
                
            } catch (error) {
                return { isValid: false, message: `Warrantyæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // IMGæ£€éªŒå‡½æ•°
        function checkIMG(baselineColorValue, testValue) {
            try {
                console.log('IMGæ£€éªŒ - åŸºå‡†é¢œè‰²å€¼:', baselineColorValue);
                console.log('IMGæ£€éªŒ - æµ‹è¯•å€¼:', testValue);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åŸºå‡†é¢œè‰²å€¼
                if (!baselineColorValue || baselineColorValue === '(æœªæ‰¾åˆ°)') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæœªèƒ½ä»PORè¡¨ä¸­è·å–é¢œè‰²ä¿¡æ¯',
                        baselineValue: baselineColorValue || '(æœªæ‰¾åˆ°)',
                        testValue: testValue || '(ç©º)'
                    };
                }
                
                // æ£€æŸ¥æµ‹è¯•å€¼æ˜¯å¦å­˜åœ¨
                if (!testValue || String(testValue).trim() === '') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•è¡¨ä¸­æœªæ‰¾åˆ°IMGå€¼',
                        baselineValue: baselineColorValue,
                        testValue: '(ç©º)'
                    };
                }
                
                const testStr = String(testValue).trim();
                
                // è§„åˆ™1ï¼šæ£€æŸ¥æ˜¯å¦ä»¥MBGç»“å°¾
                const endsWithMBG = /\bMBG\s*$/i.test(testStr);
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•å€¼å¿…é¡»ä»¥"MBG"ç»“å°¾',
                        baselineValue: baselineColorValue,
                        testValue: testStr,
                        endsWithMBG: false,
                        colorMatch: false
                    };
                }
                
                // è§„åˆ™2ï¼šæ£€æŸ¥æµ‹è¯•å€¼æ˜¯å¦åŒ…å«åŸºå‡†é¢œè‰²å€¼
                // æ ‡å‡†åŒ–å¤„ç†ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
                const normalizedTest = testStr.toLowerCase();
                const normalizedColor = baselineColorValue.toLowerCase();
                
                const colorMatch = normalizedTest.includes(normalizedColor);
                
                console.log('IMGæ£€éªŒ - ä»¥MBGç»“å°¾:', endsWithMBG);
                console.log('IMGæ£€éªŒ - é¢œè‰²åŒ¹é…:', colorMatch);
                
                // ä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³æ‰é€šè¿‡
                const isMatch = endsWithMBG && colorMatch;
                
                let message = '';
                if (isMatch) {
                    message = `IMGæ£€éªŒé€šè¿‡ï¼šä»¥MBGç»“å°¾ä¸”åŒ…å«é¢œè‰² "${baselineColorValue}"`;
                } else if (!colorMatch) {
                    message = `IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•å€¼ä¸­æœªåŒ…å«åŸºå‡†é¢œè‰² "${baselineColorValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineColorValue,
                    testValue: testStr,
                    endsWithMBG: endsWithMBG,
                    colorMatch: colorMatch
                };
                
            } catch (error) {
                return { 
                    isValid: false, 
                    message: `IMGæ£€éªŒé”™è¯¯: ${error.message}`,
                    baselineValue: baselineColorValue || '(æœªçŸ¥)',
                    testValue: testValue || '(æœªçŸ¥)'
                };
            }
        }

        // Portæ£€éªŒå‡½æ•°
        function checkPort(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Portæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. å¤„ç†åŸºå‡†å€¼ï¼šå°†æ ‡ç‚¹ç¬¦å·è½¬æ¢ä¸ºç©ºæ ¼
                const normalizedBaseline = baselineStr.replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
                
                // 3. åˆ†ç¦»æ•°å­—å’Œéæ•°å­—tokençš„å‡½æ•°
                function separateTokens(text) {
                    const tokens = text.split(/\s+/).filter(token => token.length > 0);
                    const numbers = [];
                    const words = [];
                    
                    tokens.forEach(token => {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºæ•°å­—
                        const numberMatch = token.match(/^\d+(?:\.\d+)?$/);
                        if (numberMatch) {
                            numbers.push(parseFloat(token));
                        } else {
                            // å¦‚æœtokenåŒ…å«æ•°å­—ï¼Œæå–æ•°å­—éƒ¨åˆ†
                            const numbersInToken = token.match(/\d+(?:\.\d+)?/g);
                            if (numbersInToken) {
                                numbersInToken.forEach(num => {
                                    numbers.push(parseFloat(num));
                                });
                            }
                            
                            // æå–éæ•°å­—éƒ¨åˆ†ä½œä¸ºword
                            const wordPart = token.replace(/\d+(?:\.\d+)?/g, '').replace(/[^\w]/g, '');
                            if (wordPart) {
                                words.push(wordPart.toLowerCase());
                            }
                        }
                    });
                    
                    return { numbers, words, originalTokens: tokens };
                }
                
                // 4. å¤„ç†baselineå’Œtest tokens
                const baselineProcessed = separateTokens(normalizedBaseline);
                const testProcessed = separateTokens(testStr.replace(/MBG/gi, '').trim());
                
                // 5. æ£€æŸ¥æ•°å­—åŒ¹é…
                const missingNumbers = [];
                const foundNumbers = [];
                
                testProcessed.numbers.forEach(testNum => {
                    const found = baselineProcessed.numbers.includes(testNum);
                    if (found) {
                        foundNumbers.push(testNum);
                    } else {
                        missingNumbers.push(testNum);
                    }
                });
                
                // 6. æ£€æŸ¥å•è¯åŒ¹é…
                const missingWords = [];
                const foundWords = [];
                const rawTestTokens = testStr.split(/\s+/)
                    .filter(token => token.length > 0 && token.toUpperCase() !== 'MBG');
                
                testProcessed.words.forEach(testWord => {
                    const found = baselineProcessed.words.includes(testWord);
                    if (found) {
                        foundWords.push(testWord);
                    } else {
                        missingWords.push(testWord);
                    }
                });
                
                // 7. è®¡ç®—åŒ¹é…ç»“æœ
                const allNumbersFound = missingNumbers.length === 0;
                const allWordsFound = missingWords.length === 0;
                const allTokensFound = allNumbersFound && allWordsFound;
                const isMatch = hasMBG && allTokensFound;
                
                // 8. æ„é€ åŸå§‹missing tokensç”¨äºæ˜¾ç¤º
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                rawTestTokens.forEach(originalToken => {
                    const tokenNumbers = originalToken.match(/\d+(?:\.\d+)?/g) || [];
                    const tokenWords = originalToken.replace(/\d+(?:\.\d+)?/g, '').replace(/[^\w]/g, '').toLowerCase();
                    
                    let tokenFound = true;
                    
                    // æ£€æŸ¥tokenä¸­çš„æ•°å­—
                    tokenNumbers.forEach(numStr => {
                        const num = parseFloat(numStr);
                        if (!baselineProcessed.numbers.includes(num)) {
                            tokenFound = false;
                        }
                    });
                    
                    // æ£€æŸ¥tokenä¸­çš„å•è¯
                    if (tokenWords && !baselineProcessed.words.includes(tokenWords)) {
                        tokenFound = false;
                    }
                    
                    if (tokenFound) {
                        originalFoundTokens.push(originalToken);
                    } else {
                        originalMissingTokens.push(originalToken);
                    }
                });
                
                let message = '';
                if (isMatch) {
                    message = 'Portä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”æµ‹è¯•ä¸­æ‰€æœ‰tokenéƒ½åœ¨åŸºå‡†ä¸­æ‰¾åˆ°';
                } else if (!hasMBG) {
                    message = 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    const missingParts = [];
                    if (missingNumbers.length > 0) {
                        missingParts.push(`æ•°å­—: ${missingNumbers.join(', ')}`);
                    }
                    if (missingWords.length > 0) {
                        missingParts.push(`å•è¯: ${missingWords.join(', ')}`);
                    }
                    message = `Port tokenä¸åŒ¹é…ï¼Œæµ‹è¯•ä¸­æœªåœ¨åŸºå‡†ä¸­æ‰¾åˆ° ${missingParts.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: baselineProcessed.originalTokens,
                    testTokens: rawTestTokens,
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: {
                        numbers: baselineProcessed.numbers,
                        words: baselineProcessed.words
                    },
                    cleanedTestTokens: {
                        numbers: testProcessed.numbers,
                        words: testProcessed.words
                    },
                    normalizedBaseline: normalizedBaseline
                };
                
            } catch (error) {
                return { isValid: false, message: `Portæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Coloræ£€éªŒå‡½æ•°
        function checkColor(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Coloræ•°æ®' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }
                
                // ä»PPå·¥ä½œè¡¨çš„T2å•å…ƒæ ¼è¯»å–Coloræ•°æ®
                const t2Cell = sheetPP['T2'];
                if (!t2Cell) {
                    return { isValid: false, message: 'PPå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°T2å•å…ƒæ ¼' };
                }
                
                const testColorValue = String(t2Cell.v || '').trim();
                const baselineColorValue = String(baselineValue).trim();
                
                // æ¸…ç†å’Œæ ‡å‡†åŒ–é¢œè‰²å€¼çš„å‡½æ•°
                function normalizeColorValue(colorValue) {
                    // ç§»é™¤PANTONEå‰ç¼€ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
                    let cleaned = colorValue.replace(/^PANTONE\s+/i, '').trim();
                    
                    // å¦‚æœè¿˜æœ‰å…¶ä»–å“ç‰Œå‰ç¼€ï¼Œä¹Ÿå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
                    // ä¾‹å¦‚ï¼šcleaned = cleaned.replace(/^RAL\s+/i, '').trim();
                    
                    return cleaned;
                }
                
                // æ ‡å‡†åŒ–ä¸¤ä¸ªé¢œè‰²å€¼
                const normalizedBaseline = normalizeColorValue(baselineColorValue);
                const normalizedTest = normalizeColorValue(testColorValue);
                
                // æ¯”è¾ƒæ ‡å‡†åŒ–åçš„Colorå€¼
                const isMatch = normalizedBaseline === normalizedTest;
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: isMatch ? 'ColoråŒ¹é…ï¼ˆå·²å¿½ç•¥PANTONEå‰ç¼€ï¼‰' : `Colorä¸åŒ¹é… (åŸºå‡†: "${normalizedBaseline}", æµ‹è¯•: "${normalizedTest}")`,
                    baselineValue: baselineColorValue,
                    testValue: testColorValue,
                    normalizedBaseline: normalizedBaseline,
                    normalizedTest: normalizedTest,
                    ppCells: `T2: ${testColorValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Coloræ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // What's in the boxæ£€éªŒå‡½æ•°
        function checkWhatsInTheBox(baselineValue, testValue) {
            try {
                // æ£€æŸ¥åŸºå‡†å€¼æ˜¯å¦å­˜åœ¨
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘What\'s in the boxåŸºå‡†æ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = testValue ? String(testValue).trim() : '';
                
                console.log('What\'s in the boxæ£€éªŒ:');
                console.log('åŸºå‡†å€¼:', baselineStr);
                console.log('æµ‹è¯•å€¼:', testStr || '(ç©º)');
                
                // ã€æ–°å¢ã€‘ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœåŸºå‡†å€¼åªåŒ…å«"No"ä¸”æ²¡æœ‰é€—å·ï¼Œæµ‹è¯•å€¼ä¸ºç©ºæ˜¯åˆç†çš„
                const baselineUpper = baselineStr.toUpperCase();
                const hasNoInBaseline = baselineUpper.includes('NO');
                const hasComma = baselineStr.includes(',');
                
                if (hasNoInBaseline && !hasComma && !testStr) {
                    // åŸºå‡†å€¼çº¯ç²¹æ˜¯"No xxx"ï¼Œæµ‹è¯•å€¼ä¸ºç©º = åŒ¹é…æˆåŠŸ
                    console.log('åŸºå‡†å€¼è¦æ±‚æ— å†…å®¹ï¼Œæµ‹è¯•å€¼ä¸ºç©ºï¼Œåˆ¤å®šä¸ºåŒ¹é…æˆåŠŸ');
                    return {
                        isValid: true,
                        isMatch: true,
                        message: 'åŸºå‡†å€¼è¦æ±‚æ— å†…å®¹ï¼Œæµ‹è¯•å€¼ä¸ºç©ºï¼ŒåŒ¹é…æˆåŠŸ',
                        hasNoInBaseline: true,
                        noItemsPart: baselineStr,
                        positiveItemsPart: '',
                        noItemsViolation: false,
                        positiveItemsMatch: true,
                        hasMBG: false,
                        baselineValue: baselineStr,
                        testValue: testStr || '(ç©º)'
                    };
                }
                
                // å¯¹äºå…¶ä»–æƒ…å†µï¼Œæµ‹è¯•å€¼ä¸èƒ½ä¸ºç©º
                if (!testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘What\'s in the boxæµ‹è¯•æ•°æ®' };
                }
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æ£€æŸ¥åŸºå‡†å€¼æ˜¯å¦åŒ…å«"No"ï¼Œå¦‚æœåŒ…å«åˆ™è¿›è¡Œç‰¹æ®Šå¤„ç†
                let processedBaselineStr = baselineStr;
                let shouldCheckNoItems = false;
                let noItemsPart = '';
                let positiveItemsPart = '';
                
                if (hasNoInBaseline) {
                    console.log('åŸºå‡†å€¼åŒ…å«"No"ï¼Œè¿›è¡Œç‰¹æ®Šå¤„ç†');
                    
                    // æŸ¥æ‰¾é€—å·åˆ†éš”ç¬¦
                    const commaIndex = baselineStr.indexOf(',');
                    if (commaIndex !== -1) {
                        // åˆ†å‰²ä¸ºNoéƒ¨åˆ†å’Œæ­£é¢éƒ¨åˆ†
                        noItemsPart = baselineStr.substring(0, commaIndex).trim();
                        positiveItemsPart = baselineStr.substring(commaIndex + 1).trim();
                        
                        console.log('Noéƒ¨åˆ†:', noItemsPart);
                        console.log('æ­£é¢éƒ¨åˆ†:', positiveItemsPart);
                        
                        // ä½¿ç”¨æ­£é¢éƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒ
                        processedBaselineStr = positiveItemsPart;
                        shouldCheckNoItems = true;
                    } else {
                        // æ²¡æœ‰é€—å·ï¼Œæ•´ä¸ªéƒ½æ˜¯Noéƒ¨åˆ†
                        noItemsPart = baselineStr;
                        positiveItemsPart = '';
                        processedBaselineStr = '';
                        shouldCheckNoItems = true;
                        
                        console.log('æ•´ä¸ªåŸºå‡†å€¼éƒ½æ˜¯Noéƒ¨åˆ†ï¼Œæ— æ­£é¢å†…å®¹');
                    }
                }
                
                console.log('å¤„ç†åçš„åŸºå‡†å€¼:', processedBaselineStr);
                
                // 2.5. æå–å’Œæ¸…ç†tokençš„å‡½æ•°
                function extractAndCleanTokens(text, removeMBG = false) {
                    let cleanedText = text;
                    
                    // å¦‚æœéœ€è¦ï¼Œç§»é™¤MBG
                    if (removeMBG) {
                        cleanedText = cleanedText.replace(/\bMBG\b/gi, '');
                    }
                    
                    // éœ€è¦å¿½ç•¥çš„å¸¸è§è¿æ¥è¯å’Œä»‹è¯
                    const stopWords = [
                        'and', 'or', 'with', 'without', 'the', 'a', 'an', 
                        'in', 'on', 'at', 'for', 'of', 'to', 'from',
                        '&', '+', ',', '-'
                    ];
                    
                    // åˆ†å‰²ä¸ºtokenså¹¶æ¸…ç†
                    const tokens = cleanedText
                        .split(/\s+/)
                        .map(token => {
                            // ç§»é™¤æ ‡ç‚¹ç¬¦å·
                            const cleaned = token.replace(/[^\w]/g, '').trim();
                            return cleaned.toLowerCase();
                        })
                        .filter(token => token.length > 0)
                        .filter(token => !stopWords.includes(token)); // è¿‡æ»¤åœç”¨è¯
                    
                    console.log('åŸå§‹æ–‡æœ¬:', text);
                    console.log('æ¸…ç†åçš„tokens:', tokens);
                    return tokens;
                }
                
                // 3. å¦‚æœéœ€è¦æ£€æŸ¥Noé¡¹ç›®ï¼ŒéªŒè¯æµ‹è¯•å€¼ä¸­ä¸åº”åŒ…å«Noéƒ¨åˆ†çš„å…³é”®è¯
                let noItemsViolation = false;
                let noItemsViolationDetails = '';
                
                if (shouldCheckNoItems && noItemsPart) {
                    // æå–Noéƒ¨åˆ†çš„å…³é”®è¯ï¼ˆæ’é™¤"No"æœ¬èº«ï¼‰
                    const noItemsTokens = extractAndCleanTokens(noItemsPart, false)
                        .filter(token => token.toLowerCase() !== 'no');
                    
                    console.log('Noéƒ¨åˆ†çš„å…³é”®è¯:', noItemsTokens);
                    
                    // æ£€æŸ¥æµ‹è¯•å€¼ä¸­æ˜¯å¦åŒ…å«è¿™äº›ä¸åº”è¯¥å‡ºç°çš„å…³é”®è¯
                    const testTokensForNoCheck = extractAndCleanTokens(testStr, true); // ç§»é™¤MBG
                    const foundNoItems = noItemsTokens.filter(token => 
                        testTokensForNoCheck.some(testToken => 
                            testToken.includes(token) || token.includes(testToken)
                        )
                    );
                    
                    if (foundNoItems.length > 0) {
                        noItemsViolation = true;
                        noItemsViolationDetails = `æµ‹è¯•å€¼ä¸­ä¸åº”åŒ…å«ä»¥ä¸‹é¡¹ç›®: ${foundNoItems.join(', ')}`;
                        console.log('å‘ç°è¿è§„é¡¹ç›®:', foundNoItems);
                    }
                }
                
                // 4. å¤„ç†æ­£é¢éƒ¨åˆ†çš„åŒ¹é…ï¼ˆå¦‚æœæœ‰ï¼‰
                let positiveItemsMatch = true;
                let positiveMatchDetails = '';
                
                if (processedBaselineStr) {
                    // æå–æ­£é¢éƒ¨åˆ†çš„tokens
                    const baselineTokens = extractAndCleanTokens(processedBaselineStr, false);
                    const testTokens = extractAndCleanTokens(testStr, true); // ç§»é™¤MBG
                    
                    console.log('æ­£é¢éƒ¨åˆ†åŸºå‡†tokens:', baselineTokens);
                    console.log('æµ‹è¯•tokens (ç§»é™¤MBGå):', testTokens);
                    
                    // è¿›è¡Œæ¨¡ç³ŠåŒ¹é…ï¼šæ£€æŸ¥åŸºå‡†ä¸­çš„æ¯ä¸ªtokenæ˜¯å¦åœ¨æµ‹è¯•å€¼ä¸­å­˜åœ¨
                    const missingTokens = baselineTokens.filter(baseToken => 
                        !testTokens.some(testToken => 
                            testToken.includes(baseToken) || baseToken.includes(testToken)
                        )
                    );
                    
                    positiveItemsMatch = missingTokens.length === 0;
                    
                    if (!positiveItemsMatch) {
                        positiveMatchDetails = `ç¼ºå°‘å…³é”®è¯: ${missingTokens.join(', ')}`;
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰æ­£é¢éƒ¨åˆ†ï¼Œåˆ™è®¤ä¸ºæ­£é¢åŒ¹é…æˆåŠŸ
                    positiveMatchDetails = 'æ— éœ€æ£€æŸ¥æ­£é¢å†…å®¹';
                }
                
                // 5. ç”Ÿæˆæœ€ç»ˆç»“æœ
                const isMatch = hasMBG && !noItemsViolation && positiveItemsMatch;
                
                let message = '';
                if (isMatch) {
                    if (hasNoInBaseline) {
                        message = `What's in the boxåŒ¹é…æˆåŠŸï¼šåŒ…å«MBGï¼Œæœªå‘ç°ç¦æ­¢é¡¹ç›®${positiveItemsPart ? 'ï¼Œæ­£é¢å†…å®¹åŒ¹é…' : ''}`;
                    } else {
                        message = 'What\'s in the boxå®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”å…³é”®è¯ç›¸åŒï¼ˆå·²å¿½ç•¥è¿æ¥è¯å¦‚andã€withç­‰ï¼‰';
                    }
                } else {
                    let issues = [];
                    if (!hasMBG) issues.push('æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"');
                    if (noItemsViolation) issues.push(noItemsViolationDetails);
                    if (!positiveItemsMatch && positiveMatchDetails) issues.push(positiveMatchDetails);
                    message = `What's in the boxéªŒè¯å¤±è´¥: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    hasNoInBaseline: hasNoInBaseline,
                    noItemsPart: noItemsPart,
                    positiveItemsPart: positiveItemsPart,
                    noItemsViolation: noItemsViolation,
                    noItemsViolationDetails: noItemsViolationDetails,
                    positiveItemsMatch: positiveItemsMatch,
                    positiveMatchDetails: positiveMatchDetails,
                    hasMBG: hasMBG,
                    baselineValue: baselineStr,
                    testValue: testStr
                };
                
            } catch (error) {
                return { isValid: false, message: `What's in the boxæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        function displayTechResultsMultiple(allProductResults) {
            const resultsDiv = document.getElementById('techResults');
            const productNameSpan = document.getElementById('productName');
            const checkResultsDiv = document.getElementById('techCheckResults');
            const summaryDiv = document.getElementById('techSummary');
            
            // æ˜¾ç¤ºäº§å“æ€»æ•°
            productNameSpan.textContent = `å…± ${allProductResults.length} ä¸ªäº§å“`;
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    å…±æ£€éªŒ <span style="color: #2196f3; font-size: 20px;">${allProductResults.length}</span> ä¸ªäº§å“çš„æŠ€æœ¯è§„æ ¼
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            let totalMatchedCount = 0;
            let totalUnmatchedCount = 0;
            
            // æ˜¾ç¤ºæ¯ä¸ªäº§å“çš„æ£€éªŒç»“æœ
            allProductResults.forEach((productResult, productIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                let matchedCount = 0;
                let unmatchedCount = 0;
                
                productResult.matchResults.forEach(result => {
                    if (result.checkResult) {
                        if (result.checkResult.isMatch === true) {
                            matchedCount++;
                        } else if (result.checkResult.isMatch === false) {
                            unmatchedCount++;
                        } else {
                            matchedCount++; // æ‰‹åŠ¨æ£€éªŒä¹Ÿç®—é€šè¿‡
                        }
                    } else {
                        if (result.isMatched) {
                            matchedCount++;
                        } else {
                            unmatchedCount++;
                        }
                    }
                });
                
                totalMatchedCount += matchedCount;
                totalUnmatchedCount += unmatchedCount;
                
                const totalCount = matchedCount + unmatchedCount;
                const passRate = totalCount > 0 ? ((matchedCount / totalCount) * 100).toFixed(1) : 0;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                headerDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 1.2rem;">ğŸ“¦ äº§å“ ${productIndex + 1}: ${productResult.partNumber}</span>
                            <br>
                            <small style="opacity: 0.9;">${productResult.productName}</small>
                            <br>
                            <small style="opacity: 0.9;">åŸºå‡†è¡¨åˆ—: ${productResult.column}</small>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                            é€šè¿‡ç‡: ${passRate}%
                        </div>
                    </div>
                `;
                
                groupDiv.appendChild(headerDiv);
                
                const checksContainer = document.createElement('div');
                checksContainer.style.cssText = `
                    margin-top: 15px;
                `;
                
                // æ˜¾ç¤ºæ¯é¡¹è§„æ ¼å¯¹æ¯”ç»“æœ
                productResult.matchResults.forEach(result => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'check-item';
                    itemDiv.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 15px 20px;
                        margin: 10px 0;
                        background: white;
                        border-radius: 10px;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                        transition: all 0.3s ease;
                    `;
                    
                    let statusClass = result.isMatched ? 'pass' : 'fail';
                    let statusText = result.isMatched ? 'å·²åŒ¹é…' : 'æœªåŒ¹é…';
                    
                    // å¤„ç†ç‰¹æ®Šæ£€éªŒç»“æœ
                    let extraInfo = '';
                    if (result.checkResult) {
                        const checkResult = result.checkResult;
                        if (checkResult.isValid) {
                            if (checkResult.isMatch === true) {
                                statusClass = 'pass';
                                statusText = 'PASS';
                                extraInfo = `<br><small style="color: #28a745;">âœ“ ${checkResult.message}</small>`;
                            } else if (checkResult.isMatch === false) {
                                statusClass = 'fail';
                                statusText = 'FAIL';
                                extraInfo = `<br><small style="color: #dc3545;">âœ— ${checkResult.message}</small>`;
                            } else {
                                statusClass = 'pass';
                                statusText = 'éœ€æ‰‹åŠ¨æ£€éªŒ';
                                extraInfo = `<br><small style="color: #ffc107;">âš  ${checkResult.message}</small>`;
                            }
                            
                            // æ·»åŠ è½¬æ¢åçš„å€¼ä¿¡æ¯
                            if (checkResult.convertedValue) {
                                extraInfo += `<br><small style="color: #666;">è½¬æ¢å€¼: ${checkResult.convertedValue}kg</small>`;
                            }
                            if (checkResult.convertedValues) {
                                const cv = checkResult.convertedValues;
                                extraInfo += `<br><small style="color: #666;">è½¬æ¢å€¼: é•¿=${cv.length}mm, å®½=${cv.width}mm, åš=${cv.thickness}mm</small>`;
                            }
                            if (checkResult.ppCells) {
                                extraInfo += `<br><small style="color: #007bff;">PPå·¥ä½œè¡¨: ${checkResult.ppCells}</small>`;
                            }
                            
                            // // æ·»åŠ Processoræ£€éªŒçš„è¯¦ç»†ä¿¡æ¯
                            // if (checkResult.detailMessage) {
                            //     extraInfo += `<br><small style="color: #666;">è¯¦ç»†ä¿¡æ¯: ${checkResult.detailMessage}</small>`;
                            // }
                        } else {
                            statusClass = 'fail';
                            statusText = 'ERROR';
                            extraInfo = `<br><small style="color: #dc3545;">âœ— ${checkResult.message}</small>`;
                        }
                    }
                    
                    itemDiv.innerHTML = `
                        <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">
                            ${result.attribute}<br>
                            <small style="color: #666;">(${result.abbreviation})</small>
                        </div>
                        <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                            åŸºå‡†(${result.baselineCell}): ${result.baselineValue || '(ç©º)'}<br>
                            æµ‹è¯•(${result.testCell}): ${result.testValue || '(ç©º)'}${extraInfo}
                        </div>
                        <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                    `;
                    
                    checksContainer.appendChild(itemDiv);
                });
                
                groupDiv.appendChild(checksContainer);
                checkResultsDiv.appendChild(groupDiv);
            });
            
            // æ˜¾ç¤ºæ±‡æ€»ä¿¡æ¯
            const totalCount = totalMatchedCount + totalUnmatchedCount;
            const totalPassRate = totalCount > 0 ? ((totalMatchedCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulProducts = allProductResults.filter(p => {
                const total = p.matchResults.length;
                const passed = p.matchResults.filter(r => {
                    if (r.checkResult) {
                        return r.checkResult.isMatch === true || r.checkResult.isMatch === undefined;
                    }
                    return r.isMatched;
                }).length;
                return passed === total;
            }).length;
            
            const partialProducts = allProductResults.length - successfulProducts;
            
            summaryDiv.innerHTML = `
                <h4>æ€»ä½“æ£€éªŒæ±‡æ€»</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allProductResults.length}</span>
                        <div class="stat-label">æ€»äº§å“æ•°</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulProducts}</span>
                        <div class="stat-label">å®Œå…¨é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialProducts}</span>
                        <div class="stat-label">éƒ¨åˆ†é€šè¿‡</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalMatchedCount}</span>
                            <div class="stat-label">æ€»é€šè¿‡é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalUnmatchedCount}</span>
                            <div class="stat-label">æ€»å¤±è´¥é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">æ€»é€šè¿‡ç‡</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }
        
    </script>
</body>
</html>