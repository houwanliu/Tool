<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motorola QC Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: #f7f7f5;
            min-height: 100vh;
            padding: 0;
            color: #2f3437;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: transparent;
            min-height: 100vh;
            padding: 0 40px;
        }

        .header {
            background: transparent;
            color: #2c3e50;
            padding: 100px 60px 60px;
            text-align: center;
            border-bottom: none;
        }

        .header h1 {
            font-size: 56px;
            font-weight: 700;
            letter-spacing: -2px;
            margin-bottom: 16px;
            line-height: 1.1;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 20px;
            font-weight: 300;
            color: #7f8c8d;
            line-height: 1.6;
            letter-spacing: 0.3px;
        }

        .tabs {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            display: flex;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            position: sticky;
            top: 0;
            z-index: 100;
            border-radius: 16px 16px 0 0;
            overflow: hidden;
            margin: 0 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
        }

        .tab {
            flex: 1;
            padding: 20px 32px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 17px;
            font-weight: 400;
            color: #7f8c8d;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            letter-spacing: 0.3px;
        }

        .tab.active {
            color: #2c3e50;
            font-weight: 500;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 3px;
            background: #2c3e50;
            border-radius: 3px 3px 0 0;
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideIn {
            from {
                width: 0;
                opacity: 0;
            }
            to {
                width: 40px;
                opacity: 1;
            }
        }

        .tab:hover:not(.active) {
            color: #34495e;
            background: rgba(0, 0, 0, 0.02);
        }

        .tab-content {
            display: none;
            padding: 60px 40px 100px;
            animation: fadeIn 0.5s ease-out;
            background: transparent;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            margin-bottom: 60px;
        }

        .upload-box {
            border: 2px dashed rgba(44, 62, 80, 0.15);
            border-radius: 24px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            min-height: 320px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #2c3e50, #34495e);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .upload-box:hover {
            border-color: #2c3e50;
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(44, 62, 80, 0.12);
        }

        .upload-box:hover::before {
            opacity: 1;
        }

        .upload-box h3 {
            color: #2c3e50;
            margin-bottom: 16px;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .upload-box p {
            color: #7f8c8d;
            font-size: 15px;
            margin-bottom: 28px;
            line-height: 1.6;
            font-weight: 300;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            margin: 24px 0;
        }

        .upload-box input[type="file"] {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }

        .file-input-label {
            display: inline-block;
            padding: 14px 36px;
            background: #2c3e50;
            color: #ffffff;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.3px;
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.2);
        }

        .file-input-label:hover {
            background: #34495e;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(44, 62, 80, 0.3);
        }

        .file-input-label:active {
            transform: translateY(0);
        }

        .file-info {
            margin-top: 24px;
            padding: 20px 24px;
            background: rgba(236, 240, 241, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            font-size: 14px;
            color: #7f8c8d;
            line-height: 1.7;
            text-align: left;
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        .file-info strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .check-button {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            border: none;
            padding: 18px 64px;
            border-radius: 14px;
            font-size: 17px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: block;
            margin: 60px auto;
            letter-spacing: 0.5px;
            box-shadow: 0 8px 24px rgba(44, 62, 80, 0.25);
        }

        .check-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(44, 62, 80, 0.35);
        }

        .check-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .check-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results {
            margin-top: 80px;
            padding: 0;
        }

        .results h3 {
            color: #2c3e50;
            margin-bottom: 48px;
            font-size: 36px;
            font-weight: 700;
            letter-spacing: -1.2px;
            text-align: center;
        }

        .check-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 28px 36px;
            margin: 0 0 12px 0;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        .check-item:hover {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
            transform: translateX(4px);
        }

        .check-item .item-name {
            font-weight: 500;
            color: #2c3e50;
            flex: 1;
            font-size: 17px;
            letter-spacing: 0.2px;
        }

        .check-item .item-values {
            font-size: 14px;
            color: #7f8c8d;
            margin: 0 32px;
            text-align: center;
            flex: 2;
            letter-spacing: 0;
        }

        .status {
            padding: 10px 24px;
            border-radius: 10px;
            font-weight: 500;
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .status.pass {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
            border: 1px solid rgba(39, 174, 96, 0.2);
        }

        .status.fail {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.2);
        }

        .summary {
        margin-top: 80px;
        padding: 56px;
        background: #ffffff;
        border-radius: 16px;
        text-align: center;
        border: 1px solid rgba(0, 0, 0, 0.06);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        }

        .summary h4 {
        font-size: 24px;
        margin-bottom: 40px;
        color: #1f2328;
        font-weight: 600;
        letter-spacing: -0.4px;
        }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 80px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
        }

        .stat-number {
        font-size: 48px;
        font-weight: 600;
        letter-spacing: -1px;
        line-height: 1.1;
        margin-bottom: 12px;
        }

        .stat-number.pass { color: #2da44e; }
        .stat-number.fail { color: #cf222e; }

        .stat-label {
            color: #7f8c8d;
            font-size: 15px;
            text-transform: none;
            letter-spacing: 0.3px;
            font-weight: 400;
        }

        .error-message {
            background: rgba(231, 76, 60, 0.08);
            color: #e74c3c;
            padding: 24px 32px;
            border-radius: 16px;
            margin: 30px 0;
            border: 1px solid rgba(231, 76, 60, 0.15);
            font-size: 15px;
            line-height: 1.7;
            backdrop-filter: blur(10px);
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(236, 240, 241, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(44, 62, 80, 0.2);
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(44, 62, 80, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 20px;
            }

            .header {
                padding: 60px 20px 40px;
            }

            .header h1 {
                font-size: 32px;
            }

            .header p {
                font-size: 16px;
            }

            .upload-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        
            .tab-content {
                padding: 40px 20px;
            }

            .tabs {
                margin: 0;
                border-radius: 0;
            }

            .tab {
                font-size: 15px;
                padding: 16px 20px;
            }

            .summary-stats {
                gap: 40px;
            }

            .stat-number {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 style="height: 70px;">Motorola QC Tool</h1>
        </div>
    
        <div class="tabs">
            <button class="tab active" onclick="switchTab('basic-qc', this)">基础数据检验</button>
            <button class="tab" onclick="switchTab('tech-spec', this)">技术规格检验</button>
        </div>

        <!-- 基础QC检验 -->
        <div id="basic-qc" class="tab-content active">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>基准表</h3>
                    <p>请上传包含"POR"工作表的Tech Spec文件</p>
                    <div class="file-input-wrapper">
                        <input type="file" id="fileA" accept=".xlsx,.xls,.xlsm" />
                        <label for="fileA" class="file-input-label">选择文件</label>
                    </div>
                    <div id="fileAInfo" class="file-info" style="display: none;"></div>
                </div>
            
                <div class="upload-box">
                    <h3>检验表</h3>
                    <p>请上传包含"MTM_MMR"工作表的Offering文件</p>
                    <div class="file-input-wrapper">
                        <input type="file" id="fileB" accept=".xlsx,.xls,.xlsm" />
                        <label for="fileB" class="file-input-label">选择文件</label>
                    </div>
                    <div id="fileBInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
        
            <button class="check-button" id="checkBtnBasic" onclick="performBasicQC()" disabled>
                开始基础数据检验
            </button>
        
            <div id="basicResults" class="results" style="display: none;">
                <h3>基础数据检验结果</h3>
                <div id="basicCheckResults"></div>
                <div id="basicSummary" class="summary"></div>
            </div>
        </div>

        <!-- 技术规格匹配 -->
        <div id="tech-spec" class="tab-content">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>基准表</h3>
                    <p>请上传包含"Tech Spec"工作表的Excel文件</p>
                    <div class="file-input-wrapper">
                        <input type="file" id="fileBaseline" accept=".xlsx,.xls,.xlsm" />
                        <label for="fileBaseline" class="file-input-label">选择文件</label>
                    </div>
                    <div id="fileBaselineInfo" class="file-info" style="display: none;"></div>
                </div>
            
                <div class="upload-box">
                    <h3>测试文件</h3>
                    <p>请上传包含"OBJECT-ELEMENT"工作表的mtmElement文件</p>
                    <div class="file-input-wrapper">
                        <input type="file" id="fileTest" accept=".xlsx,.xls,.xlsm" />
                        <label for="fileTest" class="file-input-label">选择文件</label>
                    </div>
                    <div id="fileTestInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
        
            <button class="check-button" id="checkBtnTech" onclick="performTechSpecMatch()" disabled>
                开始技术规格匹配
            </button>
        
            <div id="techResults" class="results" style="display: none;">
                <h3>技术规格匹配结果</h3>
                <div id="techCheckResults"></div>
                <div id="techSummary" class="summary"></div>
            </div>
        </div>
        
        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        // 全局变量
        let fileAData = null;
        let fileBData = null;
        let fileBaselineData = null;
        let fileTestData = null;

        // 切换标签页
        function switchTab(tabId, element) {
            // 隐藏所有标签内容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 移除所有标签的active类
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示目标标签内容
            document.getElementById(tabId).classList.add('active');
            
            // 激活目标标签
            element.classList.add('active');
            
            // 隐藏错误消息
            hideError();
        }

        // 显示错误消息
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // 隐藏错误消息
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ===================基础QC检验功能===================
        
        // 日期格式标准化函数
        function normalizeDate(value) {
            if (!value) return value;
            
            // 如果是Excel日期数字，转换为日期对象
            if (typeof value === 'number' && value > 25000 && value < 100000) {
                try {
                    // Excel日期转换
                    const date = XLSX.SSF.parse_date_code(value);
                    return `${date.y}-${String(date.m).padStart(2, '0')}-${String(date.d).padStart(2, '0')}`;
                } catch (e) {
                    return value;
                }
            }
            
            // 如果已经是字符串日期，尝试标准化格式
            if (typeof value === 'string') {
                // 匹配 YYYY-MM-DD 格式
                let dateMatch = value.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
                if (dateMatch) {
                    const [, year, month, day] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
                
                // 匹配 MM/DD/YYYY 格式
                dateMatch = value.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (dateMatch) {
                    const [, month, day, year] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
            }
            
            return value;
        }

        // 国家列表比较函数（顺序无关）
        function compareCountryLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // 将字符串转换为国家代码数组
            const countries1 = String(val1).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            const countries2 = String(val2).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            
            // 排序后比较
            countries1.sort();
            countries2.sort();
            
            const isMatch = countries1.length === countries2.length && 
                   countries1.every((country, index) => country === countries2[index]);
            
            // 如果不匹配，计算差异信息
            if (!isMatch) {
                const missing = countries1.filter(c => !countries2.includes(c));
                const extra = countries2.filter(c => !countries1.includes(c));
                
                let diffMessage = '';
                if (missing.length > 0) {
                    diffMessage += `B表缺失: ${missing.join(', ')}`;
                }
                if (extra.length > 0) {
                    if (diffMessage) diffMessage += '; ';
                    diffMessage += `B表多出: ${extra.join(', ')}`;
                }
                
                // 将差异信息存储在全局变量中，供显示时使用
                compareCountryLists.lastDiffMessage = diffMessage;
            } else {
                compareCountryLists.lastDiffMessage = null;
            }
            
            return isMatch;
        }

        // Audience比较函数（分割后匹配）
        function compareAudienceLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // 将字符串转换为Audience数组，支持逗号和空格分隔
            const audience1 = String(val1).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            const audience2 = String(val2).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            
            // 排序后比较
            audience1.sort();
            audience2.sort();
            
            return audience1.length === audience2.length && 
                   audience1.every((audience, index) => audience === audience2[index]);
        }

        // 通用值比较函数
        function compareValues(val1, val2, convertFunc = null, customCompareFunc = null) {
            // 如果提供了自定义比较函数，直接使用
            if (customCompareFunc) {
                return customCompareFunc(val1, val2);
            }
            
            // 应用转换函数（如果提供）
            if (convertFunc) {
                val1 = convertFunc(val1);
                val2 = convertFunc(val2);
            }
            
            // 处理空值
            if (val1 === null || val1 === undefined || val1 === '') {
                val1 = '';
            }
            if (val2 === null || val2 === undefined || val2 === '') {
                val2 = '';
            }
            
            // 转换为字符串进行比较
            return String(val1).trim() === String(val2).trim();
        }

        // 基础QC功能中查找匹配的Part Number行
        function findMatchingRowInPORBasic(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number(基础QC):', testPartNumber);
            
            // 从B2开始向下查找,直到B列为空
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空,停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空,停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    return row;
                }
                
                row++;
                
                // 防止无限循环,最多查找1000行
                if (row > 1000) {
                    console.log('超过最大查找行数,停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        // 在基准表POR中查找匹配的Part Number行(用于技术规格检验)
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number(技术规格):', testPartNumber);
            
            // 从B2开始向下查找,直到B列为空
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空,停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空,停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    
                    // 获取该行的相关数据
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('匹配行数据:', rowData);
                    return rowData;
                }
                
                row++;
                
                // 防止无限循环,最多查找1000行
                if (row > 1000) {
                    console.log('超过最大查找行数,停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        // 基础QC文件上传处理
        document.getElementById('fileA').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileAData = workbook;
                        
                        document.getElementById('fileAInfo').style.display = 'block';
                        document.getElementById('fileAInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取文件A失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取文件A时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileB').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBData = workbook;
                        
                        document.getElementById('fileBInfo').style.display = 'block';
                        document.getElementById('fileBInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取文件B失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取文件B时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkBasicButtonState() {
            const btn = document.getElementById('checkBtnBasic');
            if (fileAData && fileBData) {
                btn.disabled = false;
            }
        }

        function performBasicQC() {
            try {
                hideError();
                
                if (!fileAData.SheetNames.includes('POR')) {
                    throw new Error('基准表(A表)中未找到"POR"工作表');
                }
                
                if (!fileBData.SheetNames.includes('MTM_MMR')) {
                    throw new Error('检验表(B表)中未找到"MTM_MMR"工作表');
                }
                
                const sheetA = fileAData.Sheets['POR'];
                const sheetB = fileBData.Sheets['MTM_MMR'];
                
                // 1. 遍历检验表的B列,从B7开始,收集所有Part Number
                const testPartNumbers = [];
                let testRow = 7;
                
                console.log('开始遍历检验表B列,收集Part Numbers...');
                
                while (true) {
                    const bCell = `B${testRow}`;
                    const partNumber = sheetB[bCell] ? String(sheetB[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        console.log(`检验表B${testRow}为空,停止遍历`);
                        break;
                    }
                    
                    console.log(`检验表B${testRow}: Part Number = "${partNumber}"`);
                    testPartNumbers.push({
                        partNumber: partNumber,
                        testRow: testRow
                    });
                    
                    testRow++;
                    
                    if (testRow > 1000) {
                        console.log('超过最大查找行数,停止遍历');
                        break;
                    }
                }
                
                console.log(`共找到${testPartNumbers.length}个Part Number需要检验`);
                
                if (testPartNumbers.length === 0) {
                    throw new Error('检验表中未找到任何Part Number(从B7开始)');
                }
                
                // 2. 对每个Part Number进行检验
                let allResults = [];
                let totalPassCount = 0;
                let totalFailCount = 0;
                
                testPartNumbers.forEach((testInfo, index) => {
                    console.log(`\n====== 检验第${index + 1}个Part Number: ${testInfo.partNumber} (检验表第${testInfo.testRow}行) ======`);
                    
                    let matchedRow = null;
                    const foundRow = findMatchingRowInPORBasic(sheetA, testInfo.partNumber);
                    
                    if (foundRow !== null) {
                        matchedRow = foundRow;
                        console.log(`找到匹配的Part Number,使用基准表第${matchedRow}行数据`);
                    } else {
                        console.log(`未找到匹配的Part Number: ${testInfo.partNumber}`);
                        allResults.push({
                            partNumber: testInfo.partNumber,
                            testRow: testInfo.testRow,
                            matchedRow: null,
                            checks: [],
                            notFound: true
                        });
                        totalFailCount++;
                        return;
                    }
                    
                    const checks = [
                        {
                            name: 'Part Number',
                            cellA: `B${matchedRow}`,
                            cellB: `B${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Mkt Description',
                            cellA: `D${matchedRow}`,
                            cellB: `Y${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Audience',
                            cellA: `J${matchedRow}`,
                            cellB: `AB${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareAudienceLists
                        },
                        {
                            name: 'Country',
                            cellA: `G${matchedRow}`,
                            cellB: `AC${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareCountryLists
                        },
                        {
                            name: 'Annc Date',
                            cellA: `H${matchedRow}`,
                            cellB: `AE${testInfo.testRow}`,
                            converter: normalizeDate,
                            customCompareFunc: null
                        },
                        {
                            name: 'WW',
                            cellA: `K${matchedRow}`,
                            cellB: `AI${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        }
                    ];
                    
                    let checkResults = [];
                    let passCount = 0;
                    let failCount = 0;
                    
                    checks.forEach(check => {
                        const valueA = sheetA[check.cellA] ? sheetA[check.cellA].v : '';
                        const valueB = sheetB[check.cellB] ? sheetB[check.cellB].v : '';
                        
                        const isMatch = compareValues(valueA, valueB, check.converter, check.customCompareFunc);
                        
                        let displayValueA = valueA;
                        let displayValueB = valueB;
                        
                        if (check.converter) {
                            displayValueA = check.converter(valueA);
                            displayValueB = check.converter(valueB);
                        }
                        
                        if (check.customCompareFunc === compareCountryLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }

                        if (check.customCompareFunc === compareAudienceLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }
                        
                        checkResults.push({
                            name: check.name,
                            valueA: displayValueA,
                            valueB: displayValueB,
                            cellA: check.cellA,
                            cellB: check.cellB,
                            isMatch: isMatch,
                            diffMessage: check.customCompareFunc === compareCountryLists ? compareCountryLists.lastDiffMessage : null
                        });
                        
                        if (isMatch) {
                            passCount++;
                        } else {
                            failCount++;
                        }
                    });
                    
                    totalPassCount += passCount;
                    totalFailCount += failCount;
                    
                    allResults.push({
                        partNumber: testInfo.partNumber,
                        testRow: testInfo.testRow,
                        matchedRow: matchedRow,
                        checks: checkResults,
                        passCount: passCount,
                        failCount: failCount,
                        notFound: false
                    });
                });
                
                displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount);
                
            } catch (error) {
                showError(`检验过程出错: ${error.message}`);
                console.error('基础QC检验错误:', error);
            }
        }
        
        function displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount) {
            const resultsDiv = document.getElementById('basicResults');
            const checkResultsDiv = document.getElementById('basicCheckResults');
            const summaryDiv = document.getElementById('basicSummary');

            checkResultsDiv.innerHTML = '';

            /* 顶部总览提示 */
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background: rgba(227, 242, 253, 0.8);
                border: 2px solid #2196f3;
                border-radius: 16px;
                padding: 18px;
                margin-bottom: 32px;
                font-size: 16px;
                font-weight: 600;
                text-align: center;
                backdrop-filter: blur(8px);
            `;
            totalInfoDiv.innerHTML = `
                共检验 <span style="color:#2196f3;font-size:22px;">${allResults.length}</span> 个 Part Number
            `;
            checkResultsDiv.appendChild(totalInfoDiv);

            /* 每个 Part Number */
            allResults.forEach((result, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 40px;
                    border: 2px solid rgba(44, 62, 80, 0.08);
                    border-radius: 24px;
                    background: rgba(255, 255, 255, 0.6);
                    backdrop-filter: blur(10px);
                    overflow: hidden;
                    box-shadow: 0 4px 20px rgba(44, 62, 80, 0.06);
                `;

                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                    color: white;
                    padding: 24px 32px;
                    font-weight: 600;
                    font-size: 1.1rem;
                `;

                if (result.notFound) {
                    headerDiv.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <span style="font-size:1.3rem;">Part ${index + 1}: ${result.partNumber}</span><br>
                                <small style="opacity:0.85;">检验表第 ${result.testRow} 行</small>
                            </div>
                            <div style="background:rgba(220,53,69,0.2);padding:10px 20px;border-radius:20px;">
                                ❌ 未找到匹配
                            </div>
                        </div>
                    `;
                    groupDiv.appendChild(headerDiv);

                    const msg = document.createElement('div');
                    msg.style.cssText = `
                        background: rgba(220, 53, 69, 0.1);
                        color: #dc3545;
                        padding: 20px;
                        margin: 20px;
                        border-radius: 16px;
                        border: 1px solid rgba(220,53,69,0.2);
                    `;
                    msg.textContent = `⚠️ 基准表中未找到 Part Number "${result.partNumber}"`;
                    groupDiv.appendChild(msg);
                } else {
                    const passRate = result.checks.length
                        ? ((result.passCount / result.checks.length) * 100).toFixed(1)
                        : 0;

                    headerDiv.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div>
                                <span style="font-size:1.3rem;">Part Number ${index + 1}: ${result.partNumber}</span><br>
                            </div>
                            <div style="background:rgba(255,255,255,0.15);padding:10px 20px;border-radius:20px;">
                                通过率 ${passRate}%
                            </div>
                        </div>
                    `;
                    groupDiv.appendChild(headerDiv);

                    const checksContainer = document.createElement('div');
                    checksContainer.style.cssText = `padding:24px;`;

                    result.checks.forEach(check => {
                        const itemDiv = document.createElement('div');
                        const isPass = check.isMatch;

                        itemDiv.style.cssText = `
                            display:flex;
                            justify-content:space-between;
                            align-items:center;
                            padding:20px 24px;
                            margin:12px 0;
                            background: rgba(255,255,255,0.9);
                            border-radius:16px;
                            border:1px solid rgba(44,62,80,0.06);
                            box-shadow:0 2px 8px rgba(44,62,80,0.04);
                        `;

                        itemDiv.innerHTML = `
                            <div style="flex:1;font-weight:600;color:#2c3e50;">
                                ${check.name}
                            </div>
                            <div style="flex:2;text-align:center;color:#7f8c8d;">
                                基准(${check.cellA}): <b>${check.valueA || '(空)'}</b><br>
                                测试(${check.cellB}): <b>${check.valueB || '(空)'}</b>
                                ${!isPass && check.diffMessage ? `<br><small style="color:#dc3545;">✗ ${check.diffMessage}</small>` : ''}
                            </div>
                            <div style="
                                padding:10px 20px;
                                border-radius:20px;
                                font-weight:500;
                                min-width:90px;
                                text-align:center;
                                color:${isPass ? '#28a745' : '#dc3545'};
                                background:${isPass ? 'rgba(40,167,69,0.1)' : 'rgba(220,53,69,0.1)'};
                            ">
                                ${isPass ? 'PASS' : 'FAIL'}
                            </div>
                        `;

                        checksContainer.appendChild(itemDiv);
                    });

                    groupDiv.appendChild(checksContainer);
                }

                checkResultsDiv.appendChild(groupDiv);
            });

            /* 汇总区 */
            const totalCount = totalPassCount + totalFailCount;
            const totalPassRate = totalCount ? ((totalPassCount / totalCount) * 100).toFixed(1) : 0;

            const successfulParts = allResults.filter(r => !r.notFound && r.failCount === 0).length;
            const partialParts = allResults.filter(r => !r.notFound && r.failCount > 0).length;
            const notFoundParts = allResults.filter(r => r.notFound).length;

            summaryDiv.innerHTML = `
                <h4 style="font-size:1.8rem;font-weight:600;color:#2c3e50;margin-bottom:32px;">
                    总体检验汇总
                </h4>

                <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:24px;margin-bottom:32px;">
                    ${summaryCard(allResults.length, '总 Part 数', '#2c3e50')}
                    ${summaryCard(successfulParts, '完全通过', '#28a745')}
                    ${summaryCard(partialParts, '部分通过', '#f39c12')}
                    ${summaryCard(notFoundParts, '未找到匹配', '#dc3545')}
                </div>

                <div style="padding-top:32px;border-top:1px solid rgba(44,62,80,0.08);display:grid;grid-template-columns:repeat(3,1fr);gap:24px;">
                    ${summaryCard(totalPassCount, '总通过项目', '#28a745')}
                    ${summaryCard(totalFailCount, '总失败项目', '#dc3545')}
                    ${summaryCard(`${totalPassRate}%`, '总通过率', '#2c3e50')}
                </div>
            `;

            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        /* 汇总卡片 helper */
        function summaryCard(value, label, color) {
            return `
                <div style="
                    background: rgba(255,255,255,0.6);
                    padding:28px;
                    border-radius:20px;
                    text-align:center;
                    border:1px solid rgba(44,62,80,0.06);
                    box-shadow:0 2px 12px rgba(44,62,80,0.04);
                ">
                    <span style="font-size:3rem;font-weight:600;color:${color};display:block;margin-bottom:8px;">
                        ${value}
                    </span>
                    <div style="font-size:0.95rem;color:${color};">
                        ${label}
                    </div>
                </div>
            `;
        }

        // ===================技术规格匹配功能===================
        
        // 技术规格映射表
        const techSpecMapping = {
            'Processor': 'PRC',
            'OS': 'OS',
            'Display': 'MON',
            'Storage': 'HD',
            'Memory': 'MEM',
            'Graphics': 'GRA',
            'Front Camera': 'CAM',
            'Back Camera': 'CAM',
            'Back': 'CAM',
            'Audio': 'AUD',
            'Fingerprint Reader': 'SEC',
            'Weight': 'PP',
            'Weight/Dimension': 'PP',
            'Dimension': 'PP',
            'Port': 'PORT',
            'Warranty': 'WAR',
            'Bluetooth': 'WS',
            'Wireless': 'WS',
            'What\'s in the box': 'MM',
            'Color': 'COLOR',
            'Battery Life': 'TI',
            'IMG': 'IMG'
        };

        // 技术规格文件上传处理
        document.getElementById('fileBaseline').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBaselineData = workbook;
                        
                        document.getElementById('fileBaselineInfo').style.display = 'block';
                        document.getElementById('fileBaselineInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取基准文件失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取基准文件时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileTest').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileTestData = workbook;
                        
                        document.getElementById('fileTestInfo').style.display = 'block';
                        document.getElementById('fileTestInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取测试文件失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取测试文件时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkTechButtonState() {
            const btn = document.getElementById('checkBtnTech');
            if (fileBaselineData && fileTestData) {
                btn.disabled = false;
            }
        }

        // 从指定列提取基准规格数据
        function extractBaselineSpecsForColumn(sheet, column) {
            const specs = {};
            
            let row = 2;
            const maxRows = 100;
            let lastAttrName = null;  // 记录上一行的属性名
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${column}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`行${row}: 属性="${attrName}", 值="${attrValue}"`);
                
                if (attrName === '#EOF') {
                    console.log('遇到#EOF标记,停止读取');
                    break;
                }
                
                // 情况1: A列有属性名，且在mapping中
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell,
                        cells: [valueCell]
                    };
                    lastAttrName = attrName;
                    console.log(`添加规格: ${attrName} = "${attrValue}"`);
                }
                // 情况2: A列为空，但有值，且上一行是有效属性 - 这是多行数据的延续
                else if (!attrName && attrValue && lastAttrName && specs[lastAttrName]) {
                    // 追加到上一个属性
                    const existingValue = specs[lastAttrName].value;
                    specs[lastAttrName].value = existingValue + '\n' + attrValue;
                    specs[lastAttrName].cells.push(valueCell);
                    console.log(`追加到${lastAttrName}: "${attrValue}"`);
                }
                // 情况3: A列为空，值也为空 - 重置lastAttrName
                else if (!attrName && !attrValue) {
                    lastAttrName = null;
                }
                
                row++;
            }
            
            console.log('基准规格提取完成,总共提取到:', Object.keys(specs).length, '个规格');
            console.log('规格列表:', Object.keys(specs));
            
            return specs;
        }

        function performTechSpecMatch() {
            try {
                hideError();
                
                // 检查工作表是否存在
                if (!fileBaselineData.SheetNames.includes('Tech Spec')) {
                    throw new Error('基准文件中未找到"Tech Spec"工作表');
                }
                
                if (!fileTestData.SheetNames.includes('OBJECT-ELEMENT')) {
                    throw new Error('测试文件中未找到"OBJECT-ELEMENT"工作表');
                }
                
                // 检查PP工作表是否存在
                let sheetPP = null;
                if (fileTestData.SheetNames.includes('PP')) {
                    sheetPP = fileTestData.Sheets['PP'];
                }
                
                // 检查CAM工作表是否存在
                let sheetCAM = null;
                if (fileTestData.SheetNames.includes('CAM')) {
                    sheetCAM = fileTestData.Sheets['CAM'];
                }
                
                // 检查WS工作表是否存在
                let sheetWS = null;
                if (fileTestData.SheetNames.includes('WS')) {
                    sheetWS = fileTestData.Sheets['WS'];
                }
                
                // 检查POR工作表是否存在
                let sheetPOR = null;
                if (fileBaselineData.SheetNames.includes('POR')) {
                    sheetPOR = fileBaselineData.Sheets['POR'];
                }
                
                // 检查PRC工作表是否存在
                let sheetPRC = null;
                if (fileTestData.SheetNames.includes('PRC')) {
                    sheetPRC = fileTestData.Sheets['PRC'];
                }
                
                // 检查MEM工作表是否存在
                let sheetMEM = null;
                if (fileTestData.SheetNames.includes('MEM')) {
                    sheetMEM = fileTestData.Sheets['MEM'];
                }
                
                // 检查HD工作表是否存在
                let sheetHD = null;
                if (fileTestData.SheetNames.includes('HD')) {
                    sheetHD = fileTestData.Sheets['HD'];
                }

                let sheetOS = null;
                if (fileTestData.SheetNames.includes('OS')) {
                    sheetOS = fileTestData.Sheets['OS'];
                }

                // 检查GRA工作表是否存在
                let sheetGRA = null;
                if (fileTestData.SheetNames.includes('GRA')) {
                    sheetGRA = fileTestData.Sheets['GRA'];
                }
                
                // 检查TI工作表是否存在
                let sheetTI = null;
                if (fileTestData.SheetNames.includes('TI')) {
                    sheetTI = fileTestData.Sheets['TI'];
                }

                // 检查AUD工作表是否存在
                let sheetAUD = null;
                if (fileTestData.SheetNames.includes('AUD')) {
                    sheetAUD = fileTestData.Sheets['AUD'];
                }

                // 检查WAR工作表是否存在
                let sheetWAR = null;
                if (fileTestData.SheetNames.includes('WAR')) {
                    sheetWAR = fileTestData.Sheets['WAR'];
                }

                // 检查PORT工作表是否存在
                let sheetPORT = null;
                if (fileTestData.SheetNames.includes('PORT')) {
                    sheetPORT = fileTestData.Sheets['PORT'];
                }

                // 检查SEC工作表是否存在
                let sheetSEC = null;
                if (fileTestData.SheetNames.includes('SEC')) {
                    sheetSEC = fileTestData.Sheets['SEC'];
                }

                // 检查MM工作表是否存在
                let sheetMM = null;
                if (fileTestData.SheetNames.includes('MM')) {
                    sheetMM = fileTestData.Sheets['MM'];
                }

                // 检查MON工作表是否存在
                let sheetMON = null;
                if (fileTestData.SheetNames.includes('MON')) {
                    sheetMON = fileTestData.Sheets['MON'];
                }

                let sheetIMG = null;
                if (fileTestData.SheetNames.includes('IMG')) {
                    sheetIMG = fileTestData.Sheets['IMG'];
                }

                // 检查OBJECT-ELEMENT工作表是否存在
                let sheetObjectElement = null;
                if (fileTestData.SheetNames.includes('OBJECT-ELEMENT')) {
                    sheetObjectElement = fileTestData.Sheets['OBJECT-ELEMENT'];
                }

                const sheetBaseline = fileBaselineData.Sheets['Tech Spec'];
                const sheetTest = fileTestData.Sheets['OBJECT-ELEMENT'];
                
                // 1. 遍历测试表的OBJECT-ELEMENT工作表,从D6开始横向读取产品,直到遇到#EOF
                const productList = [];
                let col = 'D';
                let colIndex = 4; // D列对应索引4
                
                console.log('开始遍历测试表OBJECT-ELEMENT,从D6开始收集产品列表...');
                
                while (true) {
                    const cellAddr = `${col}6`;
                    const cellValue = sheetTest[cellAddr] ? String(sheetTest[cellAddr].v).trim() : '';
                    
                    console.log(`检查单元格${cellAddr}: "${cellValue}"`);
                    
                    // 检查是否遇到#EOF
                    if (cellValue === '#EOF' || !cellValue) {
                        console.log(`在${cellAddr}遇到#EOF或空值,停止遍历`);
                        break;
                    }
                    
                    // 从产品名称中提取Part Number (格式: [PN]描述)
                    const pnMatch = cellValue.match(/\[([^\]]+)\]/);
                    const partNumber = pnMatch ? pnMatch[1].trim() : '';
                    
                    if (partNumber) {
                        console.log(`列${col}: 找到产品 Part Number="${partNumber}", 完整名称="${cellValue}"`);
                        productList.push({
                            partNumber: partNumber,
                            productName: cellValue,
                            column: col,
                            colIndex: colIndex
                        });
                    } else {
                        console.log(`列${col}: 未能从"${cellValue}"中提取Part Number`);
                    }
                    
                    // 移动到下一列
                    colIndex++;
                    if (colIndex <= 26) {
                        col = String.fromCharCode(64 + colIndex); // A=65, B=66...Z=90
                    } else {
                        // 处理AA, AB等列
                        const firstChar = String.fromCharCode(64 + Math.floor((colIndex - 1) / 26));
                        const secondChar = String.fromCharCode(64 + ((colIndex - 1) % 26) + 1);
                        col = firstChar + secondChar;
                    }
                    
                    // 防止无限循环
                    if (colIndex > 100) {
                        console.log('超过最大列数,停止遍历');
                        break;
                    }
                }
                
                console.log(`共找到${productList.length}个产品需要检验`);
                
                if (productList.length === 0) {
                    throw new Error('测试表中未找到任何产品(从D6开始,格式应为[PN]描述)');
                }
                
                // 2. 对每个产品进行技术规格检验
                let allProductResults = [];
                
                productList.forEach((productInfo, index) => {
                    console.log(`\n====== 检验第${index + 1}个产品: ${productInfo.partNumber} ======`);
                    
                    // 1. 提取产品名称 (基准表始终使用B1/C1)
                    const b1 = sheetBaseline['B1'] ? sheetBaseline['B1'].v : '';
                    const c1 = sheetBaseline['C1'] ? sheetBaseline['C1'].v : '';
                    let baselineProductName = '';
                    let valueColumn = 'C'; // 默认值列
                    
                    console.log('🔍 基准表第一行检查:');
                    console.log('  B1 原始值:', b1);
                    console.log('  B1 处理后:', String(b1).trim());
                    console.log('  C1 原始值:', c1);
                    console.log('  C1 处理后:', String(c1).trim());
                    
                    if (String(b1).trim() === 'Product Name') {
                        baselineProductName = String(c1).trim();
                        valueColumn = 'C'; // B1是Product Name，值在C列
                        console.log('  ✅ 检测到B1是Product Name，值列设为C');
                    } else if (String(c1).trim() === 'Product Name') {
                        baselineProductName = String(b1).trim();
                        valueColumn = 'B'; // C1是Product Name，值在B列
                        console.log('  ✅ 检测到C1是Product Name，值列设为B');
                    } else {
                        console.log('  ⚠️ 警告:B1和C1都不是Product Name！');
                        console.log('  B1 === "Product Name"?', String(b1).trim() === 'Product Name');
                        console.log('  C1 === "Product Name"?', String(c1).trim() === 'Product Name');
                        // 默认使用C列
                        valueColumn = 'C';
                    }
                    
                    console.log('  📍 最终值列:', valueColumn);
                    console.log('  📍 产品名称:', baselineProductName);
                    
                    // 2. 提取基准规格数据
                    const baselineSpecs = extractBaselineSpecsForColumn(sheetBaseline, valueColumn);
                    
                    // 3. 如果有Color属性且有POR工作表,从POR读取Color基准值
                    if (sheetPOR && baselineSpecs['Color']) {
                        const porRow = findMatchingRowInPOR(sheetPOR, productInfo.partNumber);
                        if (porRow) {
                            const mCell = sheetPOR[`M${porRow.row}`];
                            if (mCell) {
                                baselineSpecs['Color'] = {
                                    value: String(mCell.v || '').trim(),
                                    cell: `POR M${porRow.row}`
                                };
                            }
                        }
                    }
                    
                    // 4. 提取测试规格数据 (从对应列读取)
                    const testSpecs = extractTestSpecsForColumn(sheetTest, productInfo.column, sheetPP);

                    // 5. 提取Camera数据
                    const cameraSpecs = extractCameraSpecs(sheetCAM);
                    
                    // 6. 提取Wireless数据
                    const wirelessSpecs = extractWirelessSpecs(sheetWS);
                    
                    // 7. 进行匹配对比                   
                    const matchResults = matchTechSpecs(
                    baselineSpecs, 
                    testSpecs, 
                    sheetPP, 
                    cameraSpecs, 
                    wirelessSpecs, 
                    sheetWS,   // 传入WS工作表
                    sheetPOR,
                    sheetPRC, 
                    sheetMEM, 
                    sheetHD, 
                    fileTestData, 
                    productInfo,
                    sheetOS,     // 新增
                    sheetGRA,    // 新增
                    sheetTI,     // 新增
                    sheetAUD,    // 新增
                    sheetWAR,    // 新增
                    sheetPORT,   // 新增
                    sheetSEC,    // 新增
                    sheetMM,     // 新增
                    sheetMON,     // 新增
                    sheetObjectElement,
                    sheetIMG
                );

                    allProductResults.push({
                        partNumber: productInfo.partNumber,
                        productName: productInfo.productName,
                        column: productInfo.column,
                        baselineProductName: baselineProductName,
                        matchResults: matchResults
                    });
                });
                
                // 显示所有产品的检验结果
                displayTechResultsMultiple(allProductResults);
                
            } catch (error) {
                showError(`技术规格匹配过程出错: ${error.message}`);
                console.error('技术规格匹配错误:', error);
            }
        }

        // 在基准表POR中查找匹配的Part Number行(用于技术规格检验)
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number(技术规格):', testPartNumber);
            
            // 从B2开始向下查找,直到B列为空
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空,停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空,停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                console.log(`  比较: "${partNumber}" === "${testPartNumber}" ?`, partNumber === testPartNumber);
                console.log(`  testPartNumber类型:`, typeof testPartNumber, `实际值:`, testPartNumber);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    
                    // 获取该行的相关数据
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('匹配行数据:', rowData);
                    return rowData;
                }
                
                row++;
                
                // 防止无限循环,最多查找1000行
                if (row > 1000) {
                    console.log('超过最大查找行数,停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }


        // 检查OS工作表
        let sheetOS = null;
        if (fileTestData.SheetNames.includes('OS')) {
            sheetOS = fileTestData.Sheets['OS'];
        }

        // 检查GRA工作表
        let sheetGRA = null;
        if (fileTestData.SheetNames.includes('GRA')) {
            sheetGRA = fileTestData.Sheets['GRA'];
        }

        // 检查AUD工作表
        let sheetAUD = null;
        if (fileTestData.SheetNames.includes('AUD')) {
            sheetAUD = fileTestData.Sheets['AUD'];
        }

        // 检查WAR工作表
        let sheetWAR = null;
        if (fileTestData.SheetNames.includes('WAR')) {
            sheetWAR = fileTestData.Sheets['WAR'];
        }

        // 检查PORT工作表
        let sheetPORT = null;
        if (fileTestData.SheetNames.includes('PORT')) {
            sheetPORT = fileTestData.Sheets['PORT'];
        }

        // 检查SEC工作表
        let sheetSEC = null;
        if (fileTestData.SheetNames.includes('SEC')) {
            sheetSEC = fileTestData.Sheets['SEC'];
        }

        // 检查MM工作表
        let sheetMM = null;
        if (fileTestData.SheetNames.includes('MM')) {
            sheetMM = fileTestData.Sheets['MM'];
        }

        // 检查MON工作表
        let sheetMON = null;
        if (fileTestData.SheetNames.includes('MON')) {
            sheetMON = fileTestData.Sheets['MON'];
        }

        function extractProductName(sheet) {
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            if (String(b1).trim() === 'Product Name') {
                return String(c1).trim();
            } else if (String(c1).trim() === 'Product Name') {
                return String(b1).trim();
            } else {
                throw new Error('未找到产品名称，请检查B1和C1单元格');
            }
        }

        // 从测试表中获取Part Number
        function getTestPartNumber(sheet) {
            // 检查OBJECT-ELEMENT表的B6单元格（假设Part Number在这里）
            // 或者从第6行开始查找"PRC"类型对应的值
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                // 如果找到PRC类型，返回其值作为Part Number
                if (typeName === 'PRC') {
                    return typeValue;
                }
                
                row++;
            }
            
            return null;
        }

        // 在基准表POR中查找匹配的Part Number行
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number:', testPartNumber);
            
            // 从B2开始向下查找，直到B列为空
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空，停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空，停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    
                    // 获取该行的相关数据
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('匹配行数据:', rowData);
                    return rowData;
                }
                
                row++;
                
                // 防止无限循环，最多查找100行
                if (row > 100) {
                    console.log('超过最大查找行数，停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        function getLinkedElements(sheetOE, partNumber, type) {
    try {
        if (!sheetOE) {
            return { isValid: false, message: '未找到OBJECT-ELEMENT工作表' };
        }

        if (!partNumber) {
            return { isValid: false, message: '缺少Part Number' };
        }

        const targetPN = partNumber.trim().toUpperCase();
        const targetType = type.trim().toUpperCase();

        // 1️⃣ 找 PN 所在的列
        let pnCol = null;
        for (let col = 1; col <= 100; col++) {
            const colLetter = getColumnLetter(col);
            const headerCell = sheetOE[`${colLetter}1`];
            if (!headerCell || !headerCell.v) continue;

            const headerText = String(headerCell.v).toUpperCase();
            if (headerText.includes(`[${targetPN}]`)) {
                pnCol = colLetter;
                break;
            }
        }

        if (!pnCol) {
            return {
                isValid: false,
                message: `OBJECT-ELEMENT表中未找到PN列: ${targetPN}`
            };
        }

        // 2️⃣ 找 TYPE / ELEMENT NAME / ID 列
        let typeCol = null;
        let elementNameCol = null;
        let idCol = 'A'; // ID 在你表里是 A 列（12[xxxx]）

        for (let col = 1; col <= 20; col++) {
            const colLetter = getColumnLetter(col);
            const headerCell = sheetOE[`${colLetter}1`];
            if (!headerCell || !headerCell.v) continue;

            const headerValue = String(headerCell.v).trim().toUpperCase();
            if (headerValue === 'TYPE NAME' || headerValue === 'TYPE') {
                typeCol = colLetter;
            }
            if (headerValue === 'ELEMENT NAME') {
                elementNameCol = colLetter;
            }
        }

        if (!typeCol || !elementNameCol) {
            return {
                isValid: false,
                message: 'OBJECT-ELEMENT表缺少 TYPE 或 ELEMENT NAME 列'
            };
        }

        // 3️⃣ 扫描数据行:TYPE 匹配 + PN列 = X
        const elements = [];

        for (let row = 2; row <= 500; row++) {
            const typeCell = sheetOE[`${typeCol}${row}`];
            if (!typeCell || !typeCell.v) continue;

            if (String(typeCell.v).trim().toUpperCase() !== targetType) continue;

            const pnCell = sheetOE[`${pnCol}${row}`];
            if (!pnCell || String(pnCell.v).trim().toUpperCase() !== 'X') continue;

            const elementNameCell = sheetOE[`${elementNameCol}${row}`];
            const idCell = sheetOE[`${idCol}${row}`];

            elements.push({
                row,
                elementId: idCell ? String(idCell.v).trim() : '',
                elementName: elementNameCell ? String(elementNameCell.v).trim() : ''
            });
        }

        return {
            isValid: true,
            elements
        };

    } catch (error) {
        return {
            isValid: false,
            message: `OBJECT-ELEMENT解析错误: ${error.message}`
        };
    }
}

        function extractBaselineSpecs(sheet) {
            const specs = {};
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            // 确定值列（B列还是C列）
            const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
            
            console.log('开始提取基准规格，值列为:', valueColumn);
            
            // 从第2行开始读取规格，直到遇到#EOF或者超出合理范围
            let row = 2;
            const maxRows = 100; // 防止无限循环，设置最大行数
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${valueColumn}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`行${row}: 属性="${attrName}", 值="${attrValue}"`);
                
                // 检查是否遇到#EOF标记
                if (attrName === '#EOF') {
                    console.log('遇到#EOF标记，停止读取');
                    break;
                }
                
                // 只添加techSpecMapping中定义的属性
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`添加规格: ${attrName} = "${attrValue}" (映射到: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`跳过未映射的属性: ${attrName}`);
                }
                // 如果属性名为空，继续读取下一行（跳过空行）
                
                row++;
            }
            
            console.log('基准规格提取完成，总共提取到:', Object.keys(specs).length, '个规格');
            console.log('规格列表:', Object.keys(specs));
            
            return specs;
        }

        function extractTestSpecs(sheet) {
            const specs = {};
            
            // 从第6行开始读取，直到遇到#EOF
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                specs[typeName] = {
                    value: typeValue,
                    cell: valueCell
                };
                
                row++;
            }
            
            return specs;
        }

        function extractTestSpecsForColumn(sheet, column, sheetPP = null) {  // 添加 sheetPP 参数
            const specs = {};
            
            console.log(`开始从列${column}提取测试规格`);
            
            let row = 7;
            
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                const markerCell = `${column}${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                const markerValue = sheet[markerCell] ? String(sheet[markerCell].v).trim() : '';
                
                console.log(`行${row}: 类型="${typeName}", 值="${typeValue}", 标记列${column}="${markerValue}"`);
                
                if (typeName === '#EOF' || !typeName) {
                    console.log('遇到#EOF或空值,停止读取');
                    break;
                }
                
                if (markerValue) {
                    // ⭐ 新增:当类型是PP时的特殊处理
                    if (typeName === 'PP' && sheetPP) {
                        const ppData = extractPPDimensionData(sheetPP);
                        
                        // 只在第一次遇到PP时处理,避免重复
                        if (!specs[typeName]) {
                            specs[typeName] = {
                                value: ppData.displayValue,
                                rawData: ppData,
                                cell: 'PP工作表',
                                markerCell: markerCell,
                                row: row
                            };
                            console.log(`从PP工作表提取数据: ${ppData.displayValue}`);
                        }
                    } else {
                        // 原有逻辑保持不变
                        if (specs[typeName]) {
                            if (!Array.isArray(specs[typeName])) {
                                specs[typeName] = [specs[typeName]];
                            }
                            specs[typeName].push({
                                value: typeValue,
                                cell: valueCell,
                                markerCell: markerCell,
                                row: row
                            });
                            console.log(`添加重复规格: ${typeName} = "${typeValue}"`);
                        } else {
                            specs[typeName] = {
                                value: typeValue,
                                cell: valueCell,
                                markerCell: markerCell,
                                row: row
                            };
                            console.log(`收集规格: ${typeName} = "${typeValue}"`);
                        }
                    }
                }
                
                row++;
                
                if (row > 1000) {
                    console.log('超过最大行数,停止读取');
                    break;
                }
            }
            
            console.log(`列${column}测试规格提取完成,总共提取到:`, Object.keys(specs).length, '个规格');
            
            return specs;
        }

        function extractCameraSpecs(sheet) {
            const cameraSpecs = {};
            
            if (!sheet) {
                return cameraSpecs;
            }
            
            // 找到关键列的位置
            let locationCol = null;
            let elementDescCol = null;
            let descriptionCol = null;
            
            // 扫描第1行找到列标题
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheet[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    if (headerValue === 'LOCATION' || headerValue === 'FEATURES_LOCATION') locationCol = colLetter;
                    if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC' || headerValue === 'IELEMENT_DESC') elementDescCol = colLetter;
                    if (headerValue === 'DESCRIPTION' || headerValue === 'DESCRIPTI') descriptionCol = colLetter;
                }
            }
            
            console.log('CAM表列位置:', {
                locationCol,
                elementDescCol,
                descriptionCol
            });
            
            // 遍历数据行
            for (let row = 2; row <= 20; row++) {
                if (!locationCol || !elementDescCol) {
                    console.log('未找到必要的列，跳过CAM表解析');
                    break;
                }
                
                const locationValue = sheet[`${locationCol}${row}`] ? 
                    String(sheet[`${locationCol}${row}`].v).trim().toLowerCase() : '';
                const elementDescValue = sheet[`${elementDescCol}${row}`] ? 
                    String(sheet[`${elementDescCol}${row}`].v).trim() : '';
                const descriptionValue = descriptionCol && sheet[`${descriptionCol}${row}`] ? 
                    String(sheet[`${descriptionCol}${row}`].v).trim() : '';
                
                console.log(`CAM表第${row}行: LOCATION=${locationValue}, ElementDesc=${elementDescValue}`);
                
                if (locationValue === 'front') {
                    // Front Camera - 使用Element Desc列作为显示值
                    cameraSpecs['Front Camera'] = {
                        value: elementDescValue,  // 显示Element Desc列的值
                        cell: `${elementDescCol}${row}`,
                        technicalValue: descriptionValue || elementDescValue  // 技术参数值
                    };
                    console.log('找到Front Camera:', cameraSpecs['Front Camera']);
                    
                } else if (locationValue === 'back') {
                    // Back Camera - 使用Element Desc列作为显示值
                    cameraSpecs['Back Camera'] = {
                        value: elementDescValue,  // 显示Element Desc列的值
                        cell: `${elementDescCol}${row}`,
                        technicalValue: descriptionValue || elementDescValue  // 技术参数值
                    };
                    // 也添加Back别名
                    cameraSpecs['Back'] = cameraSpecs['Back Camera'];
                    console.log('找到Back Camera:', cameraSpecs['Back Camera']);
                }
            }
            
            return cameraSpecs;
        }

        function extractWirelessSpecs(sheet) {
            const wirelessSpecs = {};
            
            if (!sheet) {
                return wirelessSpecs;
            }
            
            // 找到关键列的位置
            let wsTypeCol = null;
            let elementDescCol = null;
            let wsOnPlanACol = null;
            let wsStandardCol = null;
            
            // 扫描第1行找到列标题
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheet[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    if (headerValue === 'WSTYPE') wsTypeCol = colLetter;
                    if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC' || headerValue === 'IELEMENT_DESC') elementDescCol = colLetter;
                    if (headerValue === 'WSONPLANA') wsOnPlanACol = colLetter;
                    if (headerValue === 'WSSTANDARD') wsStandardCol = colLetter;
                }
            }
            
            // 遍历数据行
            for (let row = 2; row <= 20; row++) {
                if (!wsTypeCol || !elementDescCol) {
                    break;
                }
                
                const wsTypeValue = sheet[`${wsTypeCol}${row}`] ? String(sheet[`${wsTypeCol}${row}`].v).trim().toUpperCase() : '';
                const elementDescValue = sheet[`${elementDescCol}${row}`] ? String(sheet[`${elementDescCol}${row}`].v).trim() : '';
                
                if (wsTypeValue === 'WLAN') {
                    // Wireless - 使用Element Desc列作为显示值
                    const wsOnPlanAValue = wsOnPlanACol && sheet[`${wsOnPlanACol}${row}`] ? 
                        String(sheet[`${wsOnPlanACol}${row}`].v).trim() : '';
                    
                    wirelessSpecs['Wireless'] = {
                        value: elementDescValue,  // 显示Element Desc列的值
                        cell: `${elementDescCol}${row}`,
                        technicalValue: wsOnPlanAValue  // 技术参数值，用于检验
                    };
                    
                } else if (wsTypeValue === 'PAN') {
                    // Bluetooth - 使用Element Desc列作为显示值
                    const wsStandardValue = wsStandardCol && sheet[`${wsStandardCol}${row}`] ? 
                        String(sheet[`${wsStandardCol}${row}`].v).trim() : '';
                    
                    wirelessSpecs['Bluetooth'] = {
                        value: elementDescValue,  // 显示Element Desc列的值
                        cell: `${elementDescCol}${row}`,
                        technicalValue: wsStandardValue  // 技术参数值，用于检验
                    };
                }
            }
            
            return wirelessSpecs;
        }

        // 辅助函数:将列号转换为列字母
        function getColumnLetter(col) {
            let letter = '';
            while (col > 0) {
                const remainder = (col - 1) % 26;
                letter = String.fromCharCode(65 + remainder) + letter;
                col = Math.floor((col - 1) / 26);
            }
            return letter;
        }

        function matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetWS, sheetPOR, sheetPRC, sheetMEM, sheetHD, testWorkbook, productInfo, sheetOS, sheetGRA, sheetTI, sheetAUD, sheetWAR, sheetPORT, sheetSEC, sheetMM, sheetMON, sheetObjectElement, sheetIMG) {
            const results = [];
            
            // 遍历基准规格
            Object.keys(baselineSpecs).forEach(attrName => {
                const baselineSpec = baselineSpecs[attrName];
                const abbreviation = techSpecMapping[attrName];
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // 跳过What's in the box，因为会在最后处理
                if (attrName === 'What\'s in the box') {
                    return;
                }
                
                // 处理Camera特殊情况
                if ((attrName === 'Front Camera' || attrName === 'Back Camera' || attrName === 'Back') && cameraSpecs) {
                    if (cameraSpecs[attrName]) {
                        testSpec = cameraSpecs[attrName];  // 使用CAM表的Element Desc列作为显示值
                        isMatched = true;
                        
                        // 使用技术参数值进行检验
                        const technicalValue = cameraSpecs[attrName].technicalValue || cameraSpecs[attrName].value;
                        
                        // Camera检验:传递技术参数值和Element Desc值（用于MBG检查）
                        checkResult = checkCamera(baselineSpec.value, technicalValue, cameraSpecs[attrName].value);
                        isMatched = checkResult.isValid && checkResult.isMatch;
                    } else {
                        checkResult = { isValid: false, message: `未在CAM工作表中找到对应的${attrName}数据` };
                    }
                // 处理Bluetooth和Wireless特殊情况
                } else if ((attrName === 'Bluetooth' || attrName === 'Wireless') && wirelessSpecs) {
                    if (wirelessSpecs[attrName]) {
                        testSpec = wirelessSpecs[attrName];  // 使用WS表的Element Desc列作为显示值
                        isMatched = true

                        // 使用技术参数值进行检验
                        const technicalValue = wirelessSpecs[attrName].technicalValue || wirelessSpecs[attrName].value;

                        if (attrName === 'Bluetooth') {
                            // === 改动1:确保传入完整的 WS 表对象，而不是单行值 ===
                            // 原来传的是 baselineSpec.value 或 wirelessSpecs[attrName]，新版 checkBluetooth 需要 sheetWS
                            checkResult = checkBluetooth(baselineSpec.value, sheetWS);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            // Wireless检验
                            if (sheetWS) {
                                checkResult = checkWireless(baselineSpec.value, sheetWS);
                                isMatched = checkResult.isValid && checkResult.isMatch;
                            } else {
                                checkResult = { isValid: false, message: '未找到WS工作表' };
                            }
                        }
                    } else {
                        checkResult = { isValid: false, message: '未在WS工作表中找到对应的Bluetooth/Wireless数据' };
                    }
                }else if (abbreviation && testSpecs[abbreviation]) {
                    // 检查是否有多个相同类型的规格
                    const specData = testSpecs[abbreviation];
                    const isMultipleSpecs = Array.isArray(specData);
                    
                    if (isMultipleSpecs) {
                        // 有多个相同类型的规格,合并显示
                        testSpec = {
                            value: specData.map((s, idx) => `[${idx + 1}] ${s.value}`).join('\n'),
                            cell: specData.map((s, idx) => `[${idx + 1}] ${s.cell}`).join(', '),
                            isMultiple: true,
                            specs: specData
                        };
                    } else {
                        testSpec = specData;
                    }
                    isMatched = true;
                    
                    // 对Weight、Dimension和Processor进行特殊检验
                    if (attrName === 'Weight' || attrName.includes('Weight')) {
                        if (sheetPP) {
                            checkResult = checkWeight(baselineSpec.value, sheetPP);
                            // 更新testSpec为实际的weight数据，而不是dimension数据
                            if (checkResult.isValid && checkResult.ppRows) {
                                // 多个PP的情况
                                const weightDisplay = checkResult.ppRows.map(p => 
                                    `${p.state} (Z${p.row}): ${p.weight}`
                                ).join(', ');
                                testSpec = {
                                    value: weightDisplay,
                                    cell: 'PP工作表',
                                    rawData: checkResult.ppRows
                                };
                            } else if (checkResult.isValid) {
                                // 单个PP的情况（向后兼容）
                                testSpec = {
                                    value: checkResult.ppCells || `${checkResult.testValue}kg`,
                                    cell: 'PP工作表'
                                };
                            }
                        } else {
                            checkResult = { isValid: false, message: '未找到PP工作表，无法进行重量检验' };
                        }
                    } else if (attrName === 'Dimension' || attrName.includes('Dimension')) {
                        if (sheetPP) {
                            checkResult = checkDimension(baselineSpec.value, sheetPP);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到PP工作表，无法进行尺寸检验' };
                        }
                    } else if (attrName === 'Processor' || attrName.includes('Processor')) {
                        if (sheetPRC) {
                            checkResult = checkProcessor(baselineSpec.value, sheetPRC);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到PRC工作表，无法进行处理器检验' };
                        }
                    } else if (attrName === 'OS' || attrName.includes('OS')) {
                        if (sheetOS) {
                            checkResult = checkOS(baselineSpec.value, sheetOS);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到OS工作表' };
                        }
                    }else if (attrName === 'Display' || attrName.includes('Display')) {
                        if (sheetMON) {
                            checkResult = checkDisplay(baselineSpec.value, sheetMON);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = {isValid: false, message: '未找到MON工作表，无法进行Display检验'};
                        }
                    } else if (attrName === 'Storage' || attrName.includes('Storage')) {
                        if (sheetHD) {
                            checkResult = checkStorage(baselineSpec.value, sheetHD);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到HD工作表，无法进行存储检验' };  
                        }
                    } else if (attrName === 'Memory' || attrName.includes('Memory')) {
                        if (sheetMEM) {
                            checkResult = checkMemory(baselineSpec.value, sheetMEM);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到MEM工作表，无法进行内存检验' };
                        }
                    } else if (attrName === 'Graphics' || attrName.includes('Graphics')) {
                        if (sheetGRA) {
                            checkResult = checkGraphics(baselineSpec.value, sheetGRA);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到GRA工作表' };
                        }
                    } else if (attrName === 'Battery Life' || attrName.includes('Battery Life')) {
                        if (sheetTI) {
                            checkResult = checkBatteryLife(baselineSpec.value, sheetTI);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到TI工作表' };
                        }
                    } else if (attrName === 'Port' || attrName.includes('Port')) {
                        if (sheetPORT) {
                            checkResult = checkPort(baselineSpec.value, sheetPORT);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到PORT工作表' };          
                        }
                    } else if (attrName === 'Audio' || attrName.includes('Audio')) {
                        if (sheetAUD) {
                            checkResult = checkAudio(baselineSpec.value, sheetAUD);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到AUD工作表' };
                        }
                    } else if (attrName === 'Fingerprint Reader' || attrName.includes('Fingerprint Reader')) {
                        if (sheetSEC) {
                            checkResult = checkFingerprintReader(baselineSpec.value, sheetSEC);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到SEC工作表' };
                        }
                    } else if (attrName === 'Warranty' || attrName.includes('Warranty')) {
                        if (sheetWAR) {
                            checkResult = checkWarranty(baselineSpec.value, sheetWAR);
                            isMatched = checkResult.isValid && checkResult.isMatch;
                        } else {
                            checkResult = { isValid: false, message: '未找到WAR工作表' };
                        }
                    }
                }
                
                results.push({
                    attribute: attrName,
                    abbreviation: abbreviation || '未映射',
                    baselineValue: baselineSpec.value,
                    baselineCell: baselineSpec.cell,
                    testValue: testSpec ? testSpec.value : '未找到',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            });
            
        // 最后添加What's in the box的处理
        if (sheetPOR) {
            const n2Cell = sheetPOR['N2'];
            if (n2Cell) {
                const n2Value = String(n2Cell.v || '').trim();

                let testSpec = null;
                let isMatched = false;
                let checkResult = null;

                if (sheetMM && sheetObjectElement && productInfo.partNumber) {
                checkResult = checkWhatsInTheBox(n2Value, sheetMM, sheetObjectElement, productInfo.partNumber);
                isMatched = checkResult.isValid && checkResult.isMatch;
                
                    testSpec = {
                        value: checkResult.isValid 
                            ? (checkResult.results && checkResult.results.length > 0
                                ? checkResult.results.map(r => `${r.whatInTheBox}`).join(', ')
                                : checkResult.message)
                            : checkResult.message,
                        cell: 'MM工作表'
                    };
                } else if (!sheetMM) {
                    checkResult = { isValid: false, message: '未找到MM工作表' };
                    isMatched = false;
                    testSpec = { value: '未找到MM工作表', cell: '-' };
                } else if (!sheetObjectElement) {
                    checkResult = { isValid: false, message: '未找到OBJECT-ELEMENT工作表' };
                    isMatched = false;
                    testSpec = { value: '未找到OBJECT-ELEMENT工作表', cell: '-' };
                } else {
                    checkResult = { isValid: false, message: '缺少Part Number' };
                    isMatched = false;
                    testSpec = { value: '缺少Part Number', cell: '-' };
                }

                results.push({
                    attribute: "What's in the box",
                    abbreviation: 'MM',
                    baselineValue: n2Value,
                    baselineCell: 'POR N2',
                    testValue: testSpec.value,
                    testCell: testSpec.cell,
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            }
                    
                const porRow = findMatchingRowInPOR(sheetPOR, productInfo.partNumber);
                
                if (porRow) {
                    const mCell = sheetPOR[`M${porRow.row}`];
                    console.log(`M${porRow.row}单元格:`, mCell);
                    
                    if (mCell) {
                        const colorValue = String(mCell.v || '').trim();
                        console.log('Color基准值:', colorValue);
                        let checkResult = null;
                        let testSpec = null;
                        let isMatched = false;

                        // 调用改造后的 checkColor，必须传入 sheetObjectElement 和 productInfo.partNumber
                        checkResult = checkColor(colorValue, sheetPP, sheetObjectElement, productInfo.partNumber);

                        // 判断是否匹配
                        isMatched = true;

                        // testSpec 可以展示 PP 表中实际的 Color 或错误信息
                        testSpec = {
                            value: checkResult.isValid 
                                ? (checkResult.results ? checkResult.results.map(r => `${r.color}`).join(', ') : '未找到')
                                : checkResult.message,  // 显示详细错误信息
                            cell: 'PP工作表'
                        };

                        results.push({
                            attribute: 'Color',
                            abbreviation: 'COLOR',
                            baselineValue: colorValue,
                            baselineCell: `POR M${porRow.row}`,
                            testValue: testSpec.value,
                            testCell: testSpec.cell,
                            isMatched: isMatched,
                            checkResult: checkResult
                        });
                    } else {
                        console.log('✗ M单元格不存在');
                        // M单元格不存在，仍然显示Color行但标记为未找到
                        results.push({
                            attribute: 'Color',
                            abbreviation: 'COLOR',
                            baselineValue: '未找到',
                            baselineCell: `POR M${porRow.row}`,
                            testValue: '未检验',
                            testCell: '-',
                            isMatched: false,
                            checkResult: { isValid: false, message: 'POR表中未找到Color数据' }
                        });
                    }
                } else {
                    console.log('✗ 未找到匹配的POR行');
                    // 未找到匹配的POR行，仍然显示Color行但标记为未找到
                    results.push({
                        attribute: 'Color',
                        abbreviation: 'COLOR',
                        baselineValue: '未找到',
                        baselineCell: 'POR',
                        testValue: '未检验',
                        testCell: '-',
                        isMatched: false,
                        checkResult: { isValid: false, message: `在POR表中未找到Part Number: ${productInfo.partNumber}` }
                    });
                }
            }
            
            // 添加IMG的处理（从POR表读取Color作为基准值）
            let imgBaselineValue = '(未找到)';
            let imgBaselineCell = '-';

            // 从POR表中读取Color作为基准值
            if (sheetPOR) {
                // 查找当前产品的Part Number对应的行
                let porRow = null;
                let row = 2;
                
                while (row <= 1000) {
                    const bCell = `B${row}`;
                    const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        break;
                    }
                    
                    if (partNumber === productInfo.partNumber) {
                        porRow = row;
                        break;
                    }
                    
                    row++;
                }
                
                // 如果找到对应行，读取M列的Color值
                if (porRow) {
                    const mCell = `M${porRow}`;
                    const colorValue = sheetPOR[mCell] ? String(sheetPOR[mCell].v).trim() : '';
                    if (colorValue) {
                        imgBaselineValue = colorValue;
                        imgBaselineCell = mCell;
                    }
                }
            }

            // 检查IMG
            if (testSpecs['IMG']) {
                const checkResult = checkIMG(
                    imgBaselineValue,
                    sheetIMG,
                    sheetObjectElement,
                    productInfo.partNumber
                );

                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: testSpecs['IMG'].value,
                    testCell: testSpecs['IMG'].cell,
                    isMatched: checkResult.isValid && checkResult.isMatch,
                    checkResult
                });
            } else {
                const checkResult = checkIMG(
                    imgBaselineValue,
                    sheetIMG,
                    sheetObjectElement,
                    partNumber
                );

                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: '未找到',
                    testCell: '-',
                    isMatched: false,
                    checkResult
                });
            }
            
            return results;
        }

        // 详细比对尺寸（逐个比对高度、宽度、深度）
        function compareDimensionsDetailed(baseline, ppData, state) {
            const tolerance = 0.1;
            
            console.log(`${state}状态 - 基准值:`, baseline);
            console.log(`${state}状态 - PP数据:`, ppData);
            
            // 首先检查单位
            if (!ppData.unitsValid) {
                return {
                    state: state,
                    isMatch: false,
                    message: `${state}单位错误`,
                    detailMessage: `${state}单位必须为mm: HEIGHT=${ppData.heightUnit}, WIDTH=${ppData.widthUnit}, DEPTH=${ppData.depthUnit}`,
                    baseline: baseline,
                    ppData: ppData
                };
            }
            
            // 逐个比对
            const heightMatch = ppData.height !== null && Math.abs(baseline.height - ppData.height) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const depthMatch = ppData.depth !== null && Math.abs(baseline.depth - ppData.depth) <= tolerance;
            
            const allMatch = heightMatch && widthMatch && depthMatch;
            
            // 生成详细信息
            let details = [];
            if (!heightMatch) {
                details.push(`高度不匹配(基准${baseline.height}mm vs 测试${ppData.height || 'N/A'}mm)`);
            }
            if (!widthMatch) {
                details.push(`宽度不匹配(基准${baseline.width}mm vs 测试${ppData.width || 'N/A'}mm)`);
            }
            if (!depthMatch) {
                details.push(`深度不匹配(基准${baseline.depth}mm vs 测试${ppData.depth || 'N/A'}mm)`);
            }
            
            let message = '';
            let detailMessage = '';
            
            if (allMatch) {
                message = `${state}状态尺寸匹配`;
                detailMessage = `Dimension检验通过（H: ${baseline.height}mm ✓, W: ${baseline.width}mm ✓, D: ${baseline.depth}mm ✓）`;
            } else {
                message = `${state}状态尺寸不匹配`;
                detailMessage = `${state}[${details.join(', ')}]`;
            }
            
            return {
                state: state,
                isMatch: allMatch,
                message: message,
                detailMessage: detailMessage,
                baseline: baseline,
                ppData: ppData,
                heightMatch: heightMatch,
                widthMatch: widthMatch,
                depthMatch: depthMatch,
                ppCells: ppData.cells
            };
        }
        
        // 在PP工作表中查找Open PP和Close PP数据
        function findPPData(sheetPP) {
            const ppData = { open: null, closed: null };
            
            // 扫描PP工作表，查找包含"Open PP"和"Close PP"的行
            for (let row = 1; row <= 50; row++) {
                for (let col of ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']) {
                    const cell = sheetPP[`${col}${row}`];
                    if (cell && cell.v) {
                        const cellValue = String(cell.v).toLowerCase();
                        
                        if (cellValue.includes('open pp') || cellValue.includes('open')) {
                            // 找到Open PP，读取同行的N, AD, I列数据
                            ppData.open = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        } else if (cellValue.includes('close pp') || cellValue.includes('closed') || cellValue.includes('close')) {
                            // 找到Close PP，读取同行的N, AD, I列数据
                            ppData.closed = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        }
                    }
                }
            }
            
            return ppData;
        }
        
        // 从字符串中提取数字
        function extractNumber(value) {
            if (typeof value === 'number') return value;
            const match = String(value).match(/(\d+(?:\.\d+)?)/);
            return match ? parseFloat(match[1]) : null;
        }

        function extractPPDimensionData(sheetPP) {
            console.log('开始从PP工作表提取尺寸数据');
            
            // 查找Open PP和Close PP的数据
            const ppData = { open: null, closed: null, standard: null };
            const processedRows = new Set(); // 避免重复处理同一行
            
            // 扫描PP工作表的Element Desc列（B列）和其他列
            for (let row = 2; row <= 50; row++) {
                if (processedRows.has(row)) continue;
                
                // 检查该行是否有数据（通过检查B列的Element Desc）
                const bCell = sheetPP[`B${row}`];
                if (!bCell || !bCell.v) continue;
                
                const desc = String(bCell.v).toLowerCase();
                
                // 在PP工作表中，只需检查是否包含"open"或"closed"关键词
                if (desc.includes('open') && !ppData.open) {
                    // 找到Open PP，读取同行的尺寸数据
                    ppData.open = extractDimensionFromRow(sheetPP, row, 'Open');
                    console.log(`找到Open PP数据 (行${row}):`, ppData.open);
                    processedRows.add(row);
                } else if ((desc.includes('closed') || desc.includes('close')) && !ppData.closed) {
                    // 找到Closed PP，读取同行的尺寸数据
                    ppData.closed = extractDimensionFromRow(sheetPP, row, 'Closed');
                    console.log(`找到Closed PP数据 (行${row}):`, ppData.closed);
                    processedRows.add(row);
                }
            }
            
            // 如果没有找到Open/Closed，尝试读取标准设备的数据（第2行）
            if (!ppData.open && !ppData.closed) {
                ppData.standard = extractDimensionFromRow(sheetPP, 2, 'Standard');
                console.log('提取标准设备数据:', ppData.standard);
            }
            
            // 生成显示值
            let displayValue = '';
            if (ppData.open) {
                displayValue += `Open: ${ppData.open.displayText}`;
            }
            if (ppData.closed) {
                if (displayValue) displayValue += ', ';
                displayValue += `Closed: ${ppData.closed.displayText}`;
            }
            if (ppData.standard) {
                displayValue = ppData.standard.displayText;
            }
            
            return {
                displayValue: displayValue || '(未找到PP数据)',
                isFoldable: !!(ppData.open || ppData.closed),
                isStandard: !!ppData.standard,
                open: ppData.open,
                closed: ppData.closed,
                standard: ppData.standard
            };
        }

        // 新增:从指定行提取尺寸数据的函数
        function extractDimensionFromRow(sheetPP, row, state) {
            // 查找列标题所在的行（通常是第1行）
            let depthCol = null, heightCol = null, widthCol = null;
            let depthUnitCol = null, heightUnitCol = null, widthUnitCol = null;
            
            // 扫描第1行找到对应的列
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheetPP[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    
                    if (headerValue === 'DEPTH_MET' || headerValue === 'DEPTH') depthCol = colLetter;
                    if (headerValue === 'HEIGHT_MET' || headerValue === 'HEIGHT') heightCol = colLetter;
                    if (headerValue === 'WIDTH_MET' || headerValue === 'WIDTH') widthCol = colLetter;
                    if (headerValue === 'DEPTH_METUNITS' || headerValue === 'DEPTHUNITS') depthUnitCol = colLetter;
                    if (headerValue === 'HEIGHT_METUNITS' || headerValue === 'HEIGHTUNITS') heightUnitCol = colLetter;
                    if (headerValue === 'WIDTH_METUNITS' || headerValue === 'WIDTHUNITS') widthUnitCol = colLetter;
                }
            }
            
            console.log(`${state}状态 - 找到的列:`, {
                depth: depthCol,
                height: heightCol,
                width: widthCol,
                depthUnit: depthUnitCol,
                heightUnit: heightUnitCol,
                widthUnit: widthUnitCol
            });
            
            if (!depthCol || !heightCol || !widthCol) {
                console.log(`${state}状态 - 未找到完整的尺寸列`);
                return null;
            }
            
            // 读取数据
            const depth = sheetPP[`${depthCol}${row}`] ? extractNumber(sheetPP[`${depthCol}${row}`].v) : null;
            const height = sheetPP[`${heightCol}${row}`] ? extractNumber(sheetPP[`${heightCol}${row}`].v) : null;
            const width = sheetPP[`${widthCol}${row}`] ? extractNumber(sheetPP[`${widthCol}${row}`].v) : null;
            
            // 读取单位
            const depthUnit = depthUnitCol && sheetPP[`${depthUnitCol}${row}`] ? 
                String(sheetPP[`${depthUnitCol}${row}`].v).trim().toLowerCase() : null;
            const heightUnit = heightUnitCol && sheetPP[`${heightUnitCol}${row}`] ? 
                String(sheetPP[`${heightUnitCol}${row}`].v).trim().toLowerCase() : null;
            const widthUnit = widthUnitCol && sheetPP[`${widthUnitCol}${row}`] ? 
                String(sheetPP[`${widthUnitCol}${row}`].v).trim().toLowerCase() : null;
            
            console.log(`${state}状态 - 提取的值:`, {
                depth, height, width,
                depthUnit, heightUnit, widthUnit
            });
            
            // 验证单位
            const unitsValid = (!depthUnit || depthUnit === 'mm') && 
                            (!heightUnit || heightUnit === 'mm') && 
                            (!widthUnit || widthUnit === 'mm');
            
            if (!unitsValid) {
                console.warn(`${state}状态 - 单位验证失败:`, { depthUnit, heightUnit, widthUnit });
            }
            
            return {
                depth: depth,
                height: height,
                width: width,
                depthUnit: depthUnit || 'mm',
                heightUnit: heightUnit || 'mm',
                widthUnit: widthUnit || 'mm',
                unitsValid: unitsValid,
                row: row,
                displayText: `${height || '?'}mm(H) x ${width || '?'}mm(W) x ${depth || '?'}mm(D)`,
                cells: `行${row}: HEIGHT=${height}${heightUnit || 'mm'}, WIDTH=${width}${widthUnit || 'mm'}, DEPTH=${depth}${depthUnit || 'mm'}`
            };
        }
        
        // 从尺寸字符串中提取长宽高
        function extractDimensionsFromString(dimensionStr) {
            const match = dimensionStr.match(/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)/i);
            if (match) {
                return {
                    length: parseFloat(match[1]),
                    width: parseFloat(match[2]),
                    thickness: parseFloat(match[3])
                };
            }
            return null;
        }
        
        // 比较基准尺寸和PP数据
        function compareDimensions(baseline, ppData, state) {
            const tolerance = 0.1;
            
            const lengthMatch = ppData.length !== null && Math.abs(baseline.length - ppData.length) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const thicknessMatch = ppData.thickness !== null && Math.abs(baseline.thickness - ppData.thickness) <= tolerance;
            
            const isMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (isMatch) {
                message = `${state}状态尺寸匹配`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`长度(${baseline.length} vs ${ppData.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`宽度(${baseline.width} vs ${ppData.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`厚度(${baseline.thickness} vs ${ppData.thickness || 'N/A'})`);
                message = `${state}状态不匹配: ${mismatches.join(', ')}`;
            }
            
            return {
                state: state,
                isMatch: isMatch,
                message: message,
                baseline: baseline,
                ppData: ppData,
                ppCells: `行${ppData.row}: N${ppData.row}=${ppData.length || 'N/A'}mm, AD${ppData.row}=${ppData.width || 'N/A'}mm, I${ppData.row}=${ppData.thickness || 'N/A'}mm`
            };
        }

        //PRC处理器检验函数
        function checkProcessor(baselineValue, sheetPRC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准处理器数据' };
                }

                if (!sheetPRC) {
                    return { isValid: false, message: '未找到PRC工作表' };
                }

                // 从PRC工作表找到PROCESSORTYPE和PROCCLKSPD列
                let processorTypeCol = null;
                let procClkSpdCol = null;
                let procClkSpdUnitsCol = null;
                let processorTypeValue = '';
                let procClkSpdValue = '';
                let unitValue = '';
                
                // 扫描第1行找到列标题
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetPRC[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'PROCESSORTYPE') {
                            processorTypeCol = colLetter;
                        }
                        if (headerValue === 'PROCCLKSPD') {
                            procClkSpdCol = colLetter;
                        } else if (headerValue === 'PROCCLKSPDUNITS') {
                            procClkSpdUnitsCol = colLetter;
                        }
                    }
                }
                
                // 检查PROCCLKSPDUNITS列的值必须是GHz
                if (procClkSpdUnitsCol) {
                    for (let row = 2; row <= 1000; row++) {
                        const cellRef = `${procClkSpdUnitsCol}${row}`;
                        const cell = sheetPRC[cellRef];
                        if (cell && cell.v) {
                            // 给外层 unitValue 赋值
                            unitValue = String(cell.v).trim();
                            if (unitValue !== 'GHz') {
                               return { isValid: false, message: `第${row}行PROCCLKSPDUNITS值"${cell.v}"无效，必须是GHz` };
                            }
                        } else {
                            // 到达空行，停止检查
                            break;
                        }
                    }
                }

                if (!processorTypeCol) {
                    return { isValid: false, message: 'PRC工作表中未找到PROCESSORTYPE列' };
                }
                
                // 读取PROCESSORTYPE列的第2行数据
                const processorCell = sheetPRC[`${processorTypeCol}2`];
                if (!processorCell) {
                    return { isValid: false, message: `PRC工作表${processorTypeCol}2单元格为空` };
                }
                
                processorTypeValue = String(processorCell.v).trim();
                
                if (!processorTypeValue) {
                    return { isValid: false, message: 'PRC工作表PROCESSORTYPE字段为空' };
                }

                // 读取PROCCLKSPD列的第2行数据（如果存在）
                let clockSpeedFormatted = '';
                let clockSpeedNumeric = null;
                
                if (procClkSpdCol) {
                    const clockSpeedCell = sheetPRC[`${procClkSpdCol}2`];
                    if (clockSpeedCell && clockSpeedCell.v) {
                        const rawValue = clockSpeedCell.v;
                        // 尝试解析为数字
                        clockSpeedNumeric = parseFloat(rawValue);
                        if (!isNaN(clockSpeedNumeric)) {
                            // 格式化为保留两位小数
                            clockSpeedFormatted = clockSpeedNumeric.toFixed(2);
                        }
                    }
                }

                // 统一清洗函数
                const clean = (str) => str
                    .toLowerCase()
                    .normalize("NFKD")
                    .replace(/[\u00AE\u2122]/g, "")
                    .replace(/[^\w\s.-]/g, " ")
                    .replace(/\s+/g, " ")
                    .trim();

                const baseClean = clean(baselineValue);
                const testClean = clean(processorTypeValue);

                // 提取关键词（过滤掉常见无意义词）
                const extractKeywords = (str) =>
                    str.split(/[\s\/-]+/)
                    .filter(s =>
                        s.length > 0 &&
                        !["processor","mobile","platform","qualcomm"].includes(s)
                    );

                const baseKeys = extractKeywords(baseClean);
                
                // 记录每个关键字的匹配情况
                const matchDetails = [];
                const missing = [];
                
                baseKeys.forEach(baseKey => {
                    // 在测试值中查找这个关键字
                    if (testClean.includes(baseKey)) {
                        // 找到匹配的完整词
                        const testWords = testClean.split(/\s+/);
                        const matchedWord = testWords.find(word => word.includes(baseKey) || baseKey.includes(word));
                        
                        if (matchedWord) {
                            matchDetails.push(`"${baseKey}" 匹配 "${matchedWord}"`);
                        } else {
                            matchDetails.push(`"${baseKey}" 已匹配`);
                        }
                    } else {
                        missing.push(baseKey);
                    }
                });

                // 检查基准值中的Clock Speed（GHz之前的数字）
                let baselineClockSpeed = null;
                let clockSpeedMatch = true;
                let clockSpeedMessage = '';
                
                // 从基准值中提取Clock Speed（查找GHz之前的数字）
                const clockSpeedRegex = /(\d+\.?\d*)\s*GHz/i;
                const clockSpeedMatch_result = baselineValue.match(clockSpeedRegex);
                
                if (clockSpeedMatch_result) {
                    // 基准值包含Clock Speed
                    baselineClockSpeed = parseFloat(clockSpeedMatch_result[1]);
                    
                    if (clockSpeedNumeric !== null) {
                        // 比较Clock Speed
                        if (Math.abs(clockSpeedNumeric - baselineClockSpeed) < 0.01) {
                            // Clock Speed匹配（允许0.01的误差）
                            clockSpeedMatch = true;
                            clockSpeedMessage = `，Clock Speed匹配`;
                        } else {
                            // Clock Speed不匹配
                            clockSpeedMatch = false;
                            clockSpeedMessage = `，Clock Speed不匹配（基准: ${baselineClockSpeed.toFixed(2)} GHz，测试: ${clockSpeedFormatted}）`;
                        }
                    } else {
                        // 基准有Clock Speed但测试值没有
                        clockSpeedMatch = false;
                        clockSpeedMessage = `，缺少Clock Speed数据（基准要求: ${baselineClockSpeed.toFixed(2)} GHz）`;
                    }
                }

                // 构建消息
                let messagePrefix = `Processor检验通过（PROCESSORTYPE: ${processorTypeValue}`;
                
                // 添加PROCCLKSPD信息
                if (clockSpeedFormatted) {
                    messagePrefix += `，PROCCLKSPD: ${clockSpeedFormatted}，PROCCLKSPDUNITS: ${unitValue}`;
                }
                
                messagePrefix += `）`;

                // 判断整体是否匹配
                const overallMatch = missing.length === 0 && clockSpeedMatch;

                if (overallMatch) {
                    return { 
                        isValid: true, 
                        isMatch: true,
                        message: messagePrefix + clockSpeedMessage,
                        processorTypeCell: `${processorTypeCol}2`,
                        processorTypeValue: processorTypeValue,
                        procClkSpdCell: procClkSpdCol ? `${procClkSpdCol}2` : null,
                        procClkSpdValue: clockSpeedFormatted,
                        matchedKeys: matchDetails,
                        clockSpeedMatch: clockSpeedMatch
                    };
                }

                // 构建失败消息
                let failureMessage = '';
                
                if (missing.length > 0) {
                    failureMessage += `处理器类型校验失败:测试字段缺少以下关键字 → ${missing.join(', ')}`;
                }
                
                if (!clockSpeedMatch) {
                    if (missing.length > 0) {
                        failureMessage += `；`;
                    }
                    failureMessage += clockSpeedMessage.replace('，', '');
                }

                return {
                    isValid: true,
                    isMatch: false,
                    message: failureMessage,
                    processorTypeCell: `${processorTypeCol}2`,
                    processorTypeValue: processorTypeValue,
                    procClkSpdCell: procClkSpdCol ? `${procClkSpdCol}2` : null,
                    procClkSpdValue: clockSpeedFormatted,
                    missingKeys: missing,
                    clockSpeedMatch: clockSpeedMatch
                };

            } catch (err) {
                return { isValid: false, message: '处理器检验异常:' + err.message };
            }
        }

        // OS检验函数:
        function checkOS(baselineValue, sheetOS) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准OS数据' };
                }
                
                if (!sheetOS) {
                    return { isValid: false, message: '未找到OS工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准OS值:', baselineStr);
                
                // 找到POSTITLE列和Element列
                let posTitleCol = null;
                let elementNameCol = null;
                
                // 扫描第1行找到列标题
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetOS[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'POSTITLE') posTitleCol = colLetter;
                        // 增加对Element Desc的支持
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!posTitleCol || !elementNameCol) {
                    return { isValid: false, message: `OS工作表中未找到必要的列 (POSTITLE: ${posTitleCol}, Element列: ${elementNameCol})` };
                }
                
                // 读取第2行数据
                const elementNameCell = sheetOS[`${elementNameCol}2`];
                const posTitleCell = sheetOS[`${posTitleCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `OS工作表${elementNameCol}2单元格为空` };
                }
                
                if (!posTitleCell) {
                    return { isValid: false, message: `OS工作表${posTitleCol}2单元格为空` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const posTitleValue = String(posTitleCell.v).trim();
                
                console.log('OS工作表 Element列:', elementNameValue);
                console.log('OS工作表 POSTITLE:', posTitleValue);
                
                // 检查1: Element列最后三个字符是否为MBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OS工作表Element列必须以"MBG"结尾，实际为"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: false,
                        versionMatch: false
                    };
                }
                
                // 检查2: 提取并比较Android版本号
                // 标准化函数:移除符号、MBG、"or later"等无关内容
                function normalizeOSString(str) {
                    return str
                        .replace(/™/g, '')           // 移除™符号
                        .replace(/®/g, '')           // 移除®符号
                        .replace(/\bMBG\b/gi, '')    // 移除MBG
                        .replace(/\bor\s+later\b/gi, '') // 移除"or later"
                        .trim();
                }
                
                // 提取Android版本号（Android后的第一个整数）
                function extractAndroidVersion(str) {
                    const normalized = normalizeOSString(str);
                    console.log('标准化后的字符串:', normalized);
                    
                    // 查找"Android"后的第一个整数
                    const match = normalized.match(/Android\s+(\d+)/i);
                    
                    if (match) {
                        const version = parseInt(match[1], 10);
                        console.log('提取的版本号:', version);
                        return version;
                    }
                    
                    console.log('未找到Android版本号');
                    return null;
                }
                
                const baselineVersion = extractAndroidVersion(baselineStr);
                const testVersion = extractAndroidVersion(posTitleValue);
                
                console.log('基准版本号:', baselineVersion);
                console.log('测试版本号:', testVersion);
                
                // 检查是否成功提取版本号
                if (baselineVersion === null) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OS检验失败:无法从基准值"${baselineStr}"中提取Android版本号`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: endsWithMBG,
                        versionMatch: false,
                        baselineVersion: null,
                        testVersion: testVersion
                    };
                }
                
                if (testVersion === null) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OS检验失败:无法从测试值"${posTitleValue}"中提取Android版本号`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: endsWithMBG,
                        versionMatch: false,
                        baselineVersion: baselineVersion,
                        testVersion: null
                    };
                }
                
                // 严格比较版本号（完全一致）
                const versionMatch = baselineVersion === testVersion;
                const isMatch = endsWithMBG && versionMatch;
                
                let message = '';
                if (isMatch) {
                    message = `OS检验通过（POSTITLE: ${posTitleValue}）`;
                } else if (!versionMatch) {
                    message = `OS检验失败:Android版本号不匹配，基准版本 ${baselineVersion} ≠ 测试版本 ${testVersion}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    posTitleValue: posTitleValue,
                    endsWithMBG: endsWithMBG,
                    versionMatch: versionMatch,
                    baselineVersion: baselineVersion,
                    testVersion: testVersion,
                    osCells: `Element列 (${elementNameCol}2): ${elementNameValue}, POSTITLE (${posTitleCol}2): ${posTitleValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `OS检验错误: ${error.message}` };
            }
        }

        // 解析基准值中的多个显示屏描述
        function parseMultipleDisplays(baselineText) {
            const displays = [];
            
            console.log('解析基准Display文本:', baselineText);
            
            // 常见的显示屏标识关键词
            const displayKeywords = [
                'main display',
                'external display',
                'cover display',
                'inner display',
                'outer display',
                'primary display',
                'secondary display'
            ];
            
            // 将文本按行分割
            const lines = baselineText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // 尝试识别每个显示屏段落
            let currentDisplay = null;
            
            lines.forEach(line => {
                const lineLower = line.toLowerCase();
                
                // 检查是否是新的显示屏开始
                let foundKeyword = null;
                for (const keyword of displayKeywords) {
                    if (lineLower.includes(keyword)) {
                        foundKeyword = keyword;
                        break;
                    }
                }
                
                if (foundKeyword) {
                    // 保存之前的显示屏(如果有)
                    if (currentDisplay) {
                        displays.push(currentDisplay);
                    }
                    
                    // 开始新的显示屏
                    currentDisplay = {
                        name: foundKeyword.replace('display', '').trim() || 'Display',
                        text: line,
                        lines: [line]
                    };
                } else if (currentDisplay) {
                    // 继续当前显示屏的描述
                    currentDisplay.text += '\n' + line;
                    currentDisplay.lines.push(line);
                }
            });
            
            // 保存最后一个显示屏
            if (currentDisplay) {
                displays.push(currentDisplay);
            }
            
            // 如果没有识别到关键词,当作单个显示屏处理
            if (displays.length === 0) {
                displays.push({
                    name: 'Display',
                    text: baselineText,
                    lines: lines
                });
            }
            
            console.log('解析出的显示屏:', displays);
            return displays;
        }

        // Display检验函数
        function checkDisplay(baselineValue, sheetMON) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Display数据' };
                }
                
                if (!sheetMON) {
                    return { isValid: false, message: '未找到MON工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Display值:', baselineStr);
                
                // 找到需要的列
                let nameCol = null;
                let screenSizeCol = null;
                let displayTypeCol = null;
                
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetMON[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'SCREENSIZEVIEW_IN') screenSizeCol = colLetter;
                        if (headerValue === 'DISPLAYTYPE') displayTypeCol = colLetter;
                    }
                }
                
                if (!nameCol || !screenSizeCol || !displayTypeCol) {
                    return { isValid: false, message: `MON工作表中未找到必要的列 (Element NAME: ${nameCol}, SCREENSIZEVIEW_IN: ${screenSizeCol}, DISPLAYTYPE: ${displayTypeCol})` };
                }
                
                const nameValue = String(sheetMON[`${nameCol}2`].v).trim();
                const screenSizeValue = sheetMON[`${screenSizeCol}2`].v;
                const displayTypeValue = String(sheetMON[`${displayTypeCol}2`].v).trim();
                
                // MBG 校验
                const endsWithMBG = nameValue.slice(-3).toUpperCase() === 'MBG';
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MON工作表Name必须以"MBG"结尾，实际为"${nameValue}"`,
                        nameValue,
                        screenSizeValue,
                        displayTypeValue,
                        endsWithMBG: false
                    };
                }
                
                // 屏幕尺寸校验
                const sizeMatch = baselineStr.match(/(\d+(?:\.\d+)?)\s*(?:inch|inches|")/i);
                if (!sizeMatch) {
                    return { isValid: true, isMatch: false, message: '无法从基准值中提取屏幕尺寸' };
                }
                
                const extractedSize = parseFloat(sizeMatch[1]);
                const screenSizeMatches = Math.abs(screenSizeValue - extractedSize) < 0.01;
                if (!screenSizeMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `屏幕尺寸不匹配，基准值${extractedSize}" ≠ 测试值${screenSizeValue}"`
                    };
                }

                // ====== 关键指标提取 ======
                const keyIndicators = {
                    resolution: null,
                    tech: [],
                    refreshRate: null,
                    ppi: null,
                    brightness: null
                };
                
                // 分辨率（支持顺序对调）
                const resMatch = baselineStr.match(/(\d+)\s*[x×]\s*(\d+)/i);
                if (resMatch) {
                    keyIndicators.resolution = {
                        a: resMatch[1],
                        b: resMatch[2]
                    };
                }
                
                const refreshMatch = baselineStr.match(/(\d+)\s*Hz/i);
                if (refreshMatch) keyIndicators.refreshRate = refreshMatch[1] + 'Hz';
                
                const ppiMatch = baselineStr.match(/(\d+)\s*ppi/i);
                if (ppiMatch) keyIndicators.ppi = ppiMatch[1] + 'ppi';
                
                const brightnessMatch = baselineStr.match(/(\d+)\s*nits?/i);
                if (brightnessMatch) keyIndicators.brightness = brightnessMatch[1] + ' nits';
                
                const displayTypeLower = displayTypeValue.toLowerCase();
                const missingIndicators = [];
                const foundIndicators = [];
                
                const normalize = str =>
                    str.toLowerCase().replace(/\s+/g, '').replace(/[×]/g, 'x');

                // ✅ 分辨率判断（顺序可交换）
                if (keyIndicators.resolution) {
                    const { a, b } = keyIndicators.resolution;
                    const res1 = normalize(`${a}x${b}`);
                    const res2 = normalize(`${b}x${a}`);
                    const displayNorm = normalize(displayTypeValue);
                    
                    if (displayNorm.includes(res1) || displayNorm.includes(res2)) {
                        foundIndicators.push(`分辨率: ${a}x${b}`);
                    } else {
                        missingIndicators.push(`分辨率: ${a}x${b}`);
                    }
                }
                
                if (keyIndicators.refreshRate) {
                    if (displayTypeLower.includes(keyIndicators.refreshRate.toLowerCase())) {
                        foundIndicators.push(`刷新率: ${keyIndicators.refreshRate}`);
                    } else {
                        missingIndicators.push(`刷新率: ${keyIndicators.refreshRate}`);
                    }
                }
                
                if (keyIndicators.ppi) {
                    if (normalize(displayTypeValue).includes(normalize(keyIndicators.ppi))) {
                        foundIndicators.push(`PPI: ${keyIndicators.ppi}`);
                    } else {
                        missingIndicators.push(`PPI: ${keyIndicators.ppi}`);
                    }
                }
                
                if (keyIndicators.brightness) {
                    if (displayTypeLower.includes(keyIndicators.brightness.toLowerCase())) {
                        foundIndicators.push(`亮度: ${keyIndicators.brightness}`);
                    } else {
                        missingIndicators.push(`亮度: ${keyIndicators.brightness}`);
                    }
                }
                
                const displayTypeMatches = missingIndicators.length === 0;
                const isMatch = endsWithMBG && screenSizeMatches && displayTypeMatches;
                
                return {
                    isValid: true,
                    isMatch,
                    message: isMatch
                        ? `Display检验通过（SCREENSIZEVIEW_IN: ${extractedSize}，DISPLAYTYPE: ${displayTypeValue}）`
                        : `Display检验失败:DISPLAYTYPE缺少以下关键指标: ${missingIndicators.join(', ')}`,
                    foundIndicators,
                    missingIndicators
                };
                
            } catch (error) {
                return { isValid: false, message: `Display检验错误: ${error.message}` };
            }
        }

        // Storage检验函数
        function checkStorage(baselineValue, sheetHD) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Storage数据' };
                }

                if (!sheetHD) {
                    return { isValid: false, message: '未找到HD工作表' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('基准Storage值:', baselineStr);

                // 找列
                let nameCol = null;
                let capacityCol = null;
                let unitCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetHD[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'HDDCAPACITY') capacityCol = colLetter;
                        if (headerValue === 'HDDCAPACITYUNITS') unitCol = colLetter;
                    }
                }

                if (!nameCol || !capacityCol || !unitCol) {
                    return {
                        isValid: false,
                        message: `HD工作表中未找到必要的列 (Element Desc: ${nameCol}, HDDCAPACITY: ${capacityCol}, HDDCAPACITYUNITS: ${unitCol})`
                    };
                }

                // 读第2行
                const nameCell = sheetHD[`${nameCol}2`];
                const capacityCell = sheetHD[`${capacityCol}2`];
                const unitCell = sheetHD[`${unitCol}2`];

                if (!nameCell || !capacityCell || !unitCell) {
                    return {
                        isValid: false,
                        message: 'HD工作表第2行存在空单元格'
                    };
                }

                const nameValue = String(nameCell.v).trim();
                const capacityValue = Number(capacityCell.v);
                const unitValue = String(unitCell.v).trim();

                console.log('HD Name:', nameValue);
                console.log('HD Capacity:', capacityValue);
                console.log('HD Unit:', unitValue);

                // 检查1:MBG
                const endsWithMBG = nameValue.slice(-3).toUpperCase() === 'MBG';
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD Name必须以"MBG"结尾，实际为"${nameValue}"`,
                        endsWithMBG: false,
                        capacityMatch: false,
                        unitMatch: false
                    };
                }

                // 从基准值提取容量数字（只提数字）
                const capacityMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!capacityMatch) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '无法从基准值中提取存储容量数字',
                        endsWithMBG: endsWithMBG,
                        capacityMatch: false,
                        unitMatch: false
                    };
                }

                const extractedCapacity = Number(capacityMatch[1]);

                // 检查2:容量数字严格相等
                const capacityMatches = capacityValue === extractedCapacity;
                if (!capacityMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `存储容量不匹配，基准值${extractedCapacity} ≠ 测试值${capacityValue}`,
                        endsWithMBG: endsWithMBG,
                        capacityMatch: false,
                        unitMatch: false,
                        extractedCapacity: extractedCapacity
                    };
                }

                // 检查3:单位必须是 GB
                const unitMatches = unitValue.toUpperCase() === 'GB';
                if (!unitMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `存储单位必须为GB，实际为"${unitValue}"`,
                        endsWithMBG: endsWithMBG,
                        capacityMatch: true,
                        unitMatch: false
                    };
                }

                // 全部通过
                return {
                    isValid: true,
                    isMatch: true,
                    message: `Storage检验通过（HDDCAPACITY: ${capacityValue}, HDDCAPACITYUNITS: ${unitValue}）`,
                    nameValue: nameValue,
                    capacityValue: capacityValue,
                    unitValue: unitValue,
                    extractedCapacity: extractedCapacity,
                    endsWithMBG: endsWithMBG,
                    capacityMatch: true,
                    unitMatch: true
                };

            } catch (error) {
                return { isValid: false, message: `Storage检验错误: ${error.message}` };
            }
        }

        // Memory检验函数
        function checkMemory(baselineValue, sheetMEM) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Memory数据' };
                }
                
                if (!sheetMEM) {
                    return { isValid: false, message: '未找到MEM工作表' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('基准Memory值:', baselineStr);

                // 找到需要的列
                let nameCol = null;
                let memCapacityCol = null;
                let memUnitCol = null;
                let memModSpecCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetMEM[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'MEMCAPACITY') memCapacityCol = colLetter;
                        if (headerValue === 'MEMCAPACITYUNITS') memUnitCol = colLetter;
                        if (headerValue === 'MEMMODSPEC') memModSpecCol = colLetter;
                    }
                }

                if (!nameCol || !memCapacityCol || !memUnitCol || !memModSpecCol) {
                    return { 
                        isValid: false, 
                        message: `MEM工作表中未找到必要的列 (Element NAME: ${nameCol}, MEMCAPACITY: ${memCapacityCol}, MEMCAPACITYUNITS: ${memUnitCol}, MEMMODSPEC: ${memModSpecCol})` 
                    };
                }

                // 读取第2行数据
                const nameCell = sheetMEM[`${nameCol}2`];
                const memCapacityCell = sheetMEM[`${memCapacityCol}2`];
                const memUnitCell = sheetMEM[`${memUnitCol}2`];
                const memModSpecCell = sheetMEM[`${memModSpecCol}2`];

                if (!nameCell || !memCapacityCell || !memUnitCell || !memModSpecCell) {
                    return { isValid: false, message: 'MEM工作表第2行有单元格为空' };
                }

                const nameValue = String(nameCell.v).trim();
                const memCapacityValue = parseFloat(memCapacityCell.v); // 数值
                const memUnitValue = String(memUnitCell.v).trim();
                const memModSpecValue = String(memModSpecCell.v).trim();

                console.log('MEM工作表 Name:', nameValue);
                console.log('MEMCAPACITY:', memCapacityValue);
                console.log('MEMCAPACITYUNITS:', memUnitValue);
                console.log('MEMMODSPEC:', memModSpecValue);

                // 检查MBG
                const endsWithMBG = nameValue.slice(-3) === 'MBG';

                // 从基准值提取容量和类型
                const capacityMatch = baselineStr.match(/(\d+)\s*GB/i);
                let extractedCapacity = null;
                if (capacityMatch) {
                    extractedCapacity = parseInt(capacityMatch[1]);
                } else {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '无法从基准值中提取容量',
                        nameValue, memCapacityValue, memUnitValue, memModSpecValue
                    };
                }

                // 检查容量
                const capacityMatches = memCapacityValue === extractedCapacity;

                // 检查单位
                const unitMatches = memUnitValue.toUpperCase() === 'GB';

                // 检查类型信息（MEMMODSPEC）
                let typeMatches = true;
                const typeIndicators = baselineStr.replace(/\d+\s*GB/i, '').trim().split(/\s+/); // 去掉容量剩下的都是类型
                typeIndicators.forEach(ind => {
                    if (ind && !memModSpecValue.toUpperCase().includes(ind.toUpperCase())) {
                        typeMatches = false;
                    }
                });

                const isMatch = endsWithMBG && capacityMatches && unitMatches && typeMatches;

                let message = '';
                const missingIndicators = [];
                if (!endsWithMBG) missingIndicators.push('MBG');
                if (!capacityMatches) missingIndicators.push(`容量: ${extractedCapacity}GB`);
                if (!unitMatches) missingIndicators.push('单位不是GB');
                if (!typeMatches) missingIndicators.push('类型信息与基准不匹配');

                if (isMatch) {
                    message = `Memory检验通过（MEMCAPACITY: ${memCapacityValue}, MEMCAPACITYUNITS: ${memUnitValue}${memModSpecValue ? `, MEMMODSPEC: ${memModSpecValue}` : ''}）`;
                } else {
                    message = `Memory检验失败: ${missingIndicators.join(', ')}`;
                }

                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    nameValue,
                    memCapacityValue,
                    memUnitValue,
                    memModSpecValue,
                    endsWithMBG,
                    capacityMatches,
                    unitMatches,
                    typeMatches,
                    extractedCapacity,
                    missingIndicators
                };

            } catch (error) {
                return { isValid: false, message: `Memory检验错误: ${error.message}` };
            }
        }

        // Graphics检验函数
        function checkGraphics(baselineValue, sheetGRA) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Graphics数据' };
                }
                
                if (!sheetGRA) {
                    return { isValid: false, message: '未找到GRA工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Graphics值:', baselineStr);

                // ====== 工具函数 ======
                function normalizeText(str) {
                    return str
                        .toUpperCase()
                        .replace(/-/g, ' ')        // 统一 - 和空格
                        .replace(/GPU/g, '')       // 去 GPU
                        .replace(/ARM/g, '')       // 去 ARM
                        .replace(/\s+/g, ' ')
                        .trim();
                }

                // ====== 找列 ======
                let graphicDescCol = null;
                let elementNameCol = null;
                
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetGRA[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v)
                            .trim()
                            .toUpperCase()
                            .replace(/\s+/g, '');
                        if (headerValue === 'GRAPHIC_DESC' || headerValue === 'GRAPHICDESC') {
                            graphicDescCol = colLetter;
                        }
                        if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!graphicDescCol || !elementNameCol) {
                    return {
                        isValid: false,
                        message: `GRA工作表中未找到必要的列 (GRAPHIC_DESC: ${graphicDescCol}, Element列: ${elementNameCol})`
                    };
                }

                // ====== 读取数据 ======
                const elementNameValue = String(sheetGRA[`${elementNameCol}2`].v).trim();
                const graphicDescValue = String(sheetGRA[`${graphicDescCol}2`].v).trim();

                console.log('GRA工作表 Element Name:', elementNameValue);
                console.log('GRA工作表 GRAPHIC_DESC:', graphicDescValue);

                // ====== MBG 校验 ======
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `GRA工作表Element Name必须以"MBG"结尾，实际为"${elementNameValue}"`,
                        elementNameValue,
                        graphicDescValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }

                // ====== 内容匹配（增强版） ======
                const baselineNormalized = normalizeText(baselineStr);
                const graphicDescNormalized = normalizeText(graphicDescValue);

                const contentMatch =
                    graphicDescNormalized.includes(baselineNormalized) ||
                    baselineNormalized.includes(graphicDescNormalized);

                const isMatch = endsWithMBG && contentMatch;

                let message = '';
                if (isMatch) {
                    message = `Graphics检验通过（GRAPHIC_DESC: ${graphicDescValue}）`;
                } else {
                    message = `Graphics检验失败:GRAPHIC_DESC不匹配，基准值"${baselineStr}" ≠ 测试值"${graphicDescValue}"`;
                }

                return {
                    isValid: true,
                    isMatch,
                    message,
                    elementNameValue,
                    graphicDescValue,
                    endsWithMBG,
                    contentMatch,
                    graCells: `Element Name (${elementNameCol}2): ${elementNameValue}, GRAPHIC_DESC (${graphicDescCol}2): ${graphicDescValue}`
                };

            } catch (error) {
                return { isValid: false, message: `Graphics检验错误: ${error.message}` };
            }
        }

        // Camera检验函数
        function checkCamera(baselineValue, testValue, objectElementCamValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Camera数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查OBJECT-ELEMENT的C列是否包含 "MBG"（如果提供了该参数）
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementCamValue !== null) {
                    // 从OBJECT-ELEMENT的C列检查MBG
                    const objectElementStr = String(objectElementCamValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT C列';
                } else {
                    // 降级到从CAM工作表的值检查MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'CAM工作表';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`,
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. 提取关键Camera参数的函数
                function extractCameraSpecs(text) {
                    const specs = {};
                    
                    console.log('提取Camera规格，原始文本:', text);
                    
                    // 提取像素 (MP)
                    const mpMatch = text.match(/(\d+)\s*MP/i);
                    if (mpMatch) {
                        specs.pixels = parseInt(mpMatch[1]);
                        console.log('找到像素:', specs.pixels + 'MP');
                    }
                    
                    // 提取光圈 (f/数字)
                    const apertureMatch = text.match(/f\/(\d+\.\d+)/i);
                    if (apertureMatch) {
                        specs.aperture = parseFloat(apertureMatch[1]);
                        console.log('找到光圈:', 'f/' + specs.aperture);
                    }
                    
                    // 提取像素尺寸 (数字µm 或 数字μm)
                    const pixelSizeMatch = text.match(/(\d+(?:\.\d+)?)[µμ]m/i);
                    if (pixelSizeMatch) {
                        specs.pixelSize = parseFloat(pixelSizeMatch[1]);
                        console.log('找到像素尺寸:', specs.pixelSize + 'µm');
                    }
                    
                    console.log('提取的规格:', specs);
                    return specs;
                }
                
                // 3. 提取基准和测试规格
                const baselineSpecs = extractCameraSpecs(baselineStr);
                const testSpecs = extractCameraSpecs(testStr);
                
                // 4. 比较关键参数
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // 检查像素
                if (baselineSpecs.pixels !== undefined) {
                    if (testSpecs.pixels !== undefined) {
                        if (baselineSpecs.pixels === testSpecs.pixels) {
                            foundSpecs.push(`${baselineSpecs.pixels}MP`);
                        } else {
                            mismatchedSpecs.push(`像素不匹配: 基准${baselineSpecs.pixels}MP vs 测试${testSpecs.pixels}MP`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixels}MP`);
                    }
                }
                
                // 检查光圈
                if (baselineSpecs.aperture !== undefined) {
                    if (testSpecs.aperture !== undefined) {
                        if (baselineSpecs.aperture === testSpecs.aperture) {
                            foundSpecs.push(`f/${baselineSpecs.aperture}`);
                        } else {
                            mismatchedSpecs.push(`光圈不匹配: 基准f/${baselineSpecs.aperture} vs 测试f/${testSpecs.aperture}`);
                        }
                    } else {
                        missingSpecs.push(`f/${baselineSpecs.aperture}`);
                    }
                }
                
                // 检查像素尺寸
                if (baselineSpecs.pixelSize !== undefined) {
                    if (testSpecs.pixelSize !== undefined) {
                        if (baselineSpecs.pixelSize === testSpecs.pixelSize) {
                            foundSpecs.push(`${baselineSpecs.pixelSize}µm`);
                        } else {
                            mismatchedSpecs.push(`像素尺寸不匹配: 基准${baselineSpecs.pixelSize}µm vs 测试${testSpecs.pixelSize}µm`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixelSize}µm`);
                    }
                }
                
                // 5. 判断是否匹配
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Camera检验通过（DESCRIPTION: ${testStr}）`;
                } else if (!hasMBG) {
                    message = `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`;
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`未找到: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Camera参数检验失败: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Camera检验错误: ${error.message}` };
            }
        }

        // Audio检验函数
        function checkAudio(baselineValue, sheetAUD, coverageThreshold = 0.9) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Audio数据' };
                }
                
                if (!sheetAUD) {
                    return { isValid: false, message: '未找到AUD工作表' };
                }

                const baselineStr = String(baselineValue).trim();

                // ====== 工具函数 ======
                const STOP_WORDS = new Set([
                    'yes', 'no',
                    'with', 'without',
                    'and', 'or'
                ]);

                function normalizeText(str) {
                    return str
                        .toLowerCase()
                        .replace(/®/g, '')        // 去商标符
                        .replace(/[(),]/g, '')    // 去标点
                        .replace(/\s+/g, ' ')
                        .trim();
                }

                // ====== 找列 ======
                let audioDescCol = null;
                let elementNameCol = null;
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetAUD[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v)
                            .trim()
                            .toUpperCase()
                            .replace(/\s+/g, '');
                        if (headerValue === 'AUDIO_DESC' || headerValue === 'AUDIODESC') {
                            audioDescCol = colLetter;
                        }
                        if (['ELEMENTNAME','ELEMENT_NAME','IELEMENT_NAME','ELEMENTDESC','ELEMENT_DESC']
                            .includes(headerValue)) {
                            elementNameCol = colLetter;
                        }
                    }
                }

                if (!audioDescCol || !elementNameCol) {
                    return {
                        isValid: false,
                        message: `AUD工作表中未找到必要的列 (AUDIO_DESC: ${audioDescCol}, Element列: ${elementNameCol})`
                    };
                }

                // ====== 读取数据 ======
                const elementNameValue = String(sheetAUD[`${elementNameCol}2`].v).trim();
                const audioDescValue = String(sheetAUD[`${audioDescCol}2`].v).trim();

                // ====== MBG 校验 ======
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';

                // ====== 关键词覆盖率校验（增强版） ======
                const baselineNormalized = normalizeText(baselineStr);
                const audioDescNormalized = normalizeText(audioDescValue);

                const baselineKeywords = baselineNormalized
                    .split(' ')
                    .filter(word => word && !STOP_WORDS.has(word));

                let matchedCount = 0;
                baselineKeywords.forEach(keyword => {
                    if (audioDescNormalized.includes(keyword)) {
                        matchedCount++;
                    }
                });

                const coverage = baselineKeywords.length === 0
                    ? 1
                    : matchedCount / baselineKeywords.length;

                const contentMatch = coverage >= coverageThreshold;
                const isMatch = endsWithMBG && contentMatch;

                // ====== 结果信息 ======
                let message = '';
                if (isMatch) {
                    message = `Audio检验通过（AUDIO_DESC: ${audioDescValue}）`;
                } else {
                    const missingKeywords = baselineKeywords.filter(
                        k => !audioDescNormalized.includes(k)
                    );
                    message = `Audio检验失败（关键词覆盖率 ${(coverage * 100).toFixed(1)}%，缺失关键词: ${missingKeywords.join(', ')}）`;
                }

                return {
                    isValid: true,
                    isMatch,
                    message,
                    elementNameValue,
                    audioDescValue,
                    endsWithMBG,
                    coverage
                };

            } catch (error) {
                return { isValid: false, message: `Audio检验错误: ${error.message}` };
            }
        }

        // Fingerprint Reader检验函数 
        function checkFingerprintReader(baselineValue, sheetSEC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Fingerprint Reader数据' };
                }
                
                if (!sheetSEC) {
                    return { isValid: false, message: '未找到SEC工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Fingerprint Reader值:', baselineStr);
                
                // 找到SECTYPE列和Element列
                let secTypeCol = null;
                let elementNameCol = null;
                
                // 扫描第1行找到列标题
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetSEC[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'SECTYPE' || headerValue === 'SEC_TYPE') secTypeCol = colLetter;
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!secTypeCol || !elementNameCol) {
                    return { isValid: false, message: `SEC工作表中未找到必要的列 (SECTYPE: ${secTypeCol}, Element列: ${elementNameCol})` };
                }
                
                // 读取第2行数据
                const elementNameCell = sheetSEC[`${elementNameCol}2`];
                const secTypeCell = sheetSEC[`${secTypeCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `SEC工作表${elementNameCol}2单元格为空` };
                }
                
                if (!secTypeCell) {
                    return { isValid: false, message: `SEC工作表${secTypeCol}2单元格为空` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const secTypeValue = String(secTypeCell.v).trim();
                
                console.log('SEC工作表 Element列:', elementNameValue);
                console.log('SEC工作表 SECTYPE:', secTypeValue);
                
                // 检查1: Element列最后三个字符是否为MBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `SEC工作表Element列必须以"MBG"结尾，实际为"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        secTypeValue: secTypeValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // 检查2: SECTYPE内容与基准表匹配
                const contentMatch = secTypeValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Fingerprint Reader检验通过（SECTYPE: ${secTypeValue}）`;
                } else if (!contentMatch) {
                    message = `Fingerprint Reader检验失败:SECTYPE不匹配，基准值"${baselineStr}" ≠ 测试值"${secTypeValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    secTypeValue: secTypeValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    secCells: `Element列 (${elementNameCol}2): ${elementNameValue}, SECTYPE (${secTypeCol}2): ${secTypeValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Fingerprint Reader检验错误: ${error.message}` };
            }
        }

        // Battery Life 检验函数
        function checkBatteryLife(baselineValue, sheetTI) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少Battery Life基准数据' };
                }

                if (!sheetTI) {
                    return { isValid: false, message: '测试文件中未找到TI工作表' };
                }

                // === 固定列 ===
                const battLifeCell   = sheetTI['E2']; // BATTLIFERANGE
                const elementDescCell = sheetTI['F2']; // Element Desc

                if (!battLifeCell || !elementDescCell) {
                    return { isValid: false, message: 'TI表中缺少E2或F2数据' };
                }

                const baselineStr     = String(baselineValue).trim();
                const battLifeValue   = String(battLifeCell.v || '').trim();
                const elementDescValue = String(elementDescCell.v || '').trim();

                // === 1. Element Desc 必须以 MBG 结尾 ===
                const endsWithMBG =
                    elementDescValue.slice(-3).toUpperCase() === 'MBG';

                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `Battery Life检验失败:Element Desc必须以"MBG"结尾，实际为"${elementDescValue}"`,
                        elementDescValue
                    };
                }

                // === 2. 提取数字函数 ===
                const extractNumbers = (text) =>
                    (text.match(/\d+(?:\.\d+)?/g) || [])
                        .map(Number)
                        .sort((a, b) => a - b);

                const baselineNumbers = extractNumbers(baselineStr);
                const testNumbers     = extractNumbers(battLifeValue);

                // === 3. 数字严格一致 ===
                const numbersMatch =
                    baselineNumbers.length === testNumbers.length &&
                    baselineNumbers.every((num, idx) => num === testNumbers[idx]);

                const isMatch = endsWithMBG && numbersMatch;

                let message = '';
                if (isMatch) {
                    message = `Battery Life检验通过（BATTLIFERANGE: ${battLifeValue}}）`;
                } else {
                    message = `Battery Life检验失败:数字不一致（基准: [${baselineNumbers.join(', ')}]，测试: [${testNumbers.join(', ')}]）`;
                }

                return {
                    isValid: true,
                    isMatch,
                    message,
                    baselineValue: baselineStr,
                    battLifeValue,
                    elementDescValue,
                    baselineNumbers,
                    testNumbers,
                    endsWithMBG
                };

            } catch (error) {
                return { isValid: false, message: `Battery Life检验错误: ${error.message}` };
            }
        }
        
        // Weight检验函数
        function checkWeight(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准重量数据' };
                }

                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }

                // 从基准值中提取重量数字（单位:克）
                const weightMatch = String(baselineValue).match(/(\d+(?:\.\d+)?)g/i);
                if (!weightMatch) {
                    return { isValid: false, message: '基准值格式无效，需要包含"g"单位' };
                }

                // 转换为千克（保持原值，不做 toFixed）
                const weightInKg = parseFloat(weightMatch[1]) / 1000;

                // 查找所有PP行
                const ppRows = [];
                for (let row = 2; row <= 50; row++) {
                    const bCell = sheetPP[`B${row}`]; // Element Desc列
                    if (!bCell || !bCell.v) continue;
                    
                    const desc = String(bCell.v);
                    if (desc.toLowerCase().includes('mbg')) {
                        const zCell = sheetPP[`Z${row}`]; // WEIGHT_MET列
                        let weightValue = '';
                        let weightInKgTest = null;

                        if (zCell && zCell.v != null) {
                            const testWeightValue = zCell.v;
                            if (typeof testWeightValue === 'number') {
                                weightInKgTest = testWeightValue;
                                weightValue = `${weightInKgTest}kg`;
                            } else {
                                const testWeightMatch = String(testWeightValue).match(/(\d+(?:\.\d+)?)/);
                                if (testWeightMatch) {
                                    weightInKgTest = parseFloat(testWeightMatch[1]);
                                    weightValue = `${weightInKgTest}kg`;
                                }
                            }
                        }

                        let state = 'Standard';
                        if (desc.toLowerCase().includes('open')) state = 'Open';
                        else if (desc.toLowerCase().includes('closed') || desc.toLowerCase().includes('close')) state = 'Closed';

                        ppRows.push({
                            row: row,
                            state,
                            desc: desc.substring(0, 60) + (desc.length > 60 ? '...' : ''),
                            weight: weightValue,
                            weightInKg: weightInKgTest
                        });
                    }
                }

                if (ppRows.length === 0) {
                    return { isValid: false, message: 'PP工作表中未找到PP数据（缺少包含MBG的行）' };
                }

                // 检查每个PP重量
                const results = [];
                let allMatch = true;
                const tolerance = 0; // 精确匹配

                for (const ppRow of ppRows) {
                    if (ppRow.weightInKg === null) {
                        results.push({
                            row: ppRow.row,
                            state: ppRow.state,
                            weight: '(未找到)',
                            isMatch: false,
                            error: '缺少重量数据'
                        });
                        allMatch = false;
                    } else {
                        const difference = Math.abs(weightInKg - ppRow.weightInKg);
                        const isMatch = difference <= tolerance;

                        if (!isMatch) allMatch = false;

                        results.push({
                            row: ppRow.row,
                            state: ppRow.state,
                            weight: ppRow.weight,
                            weightInKg: ppRow.weightInKg,
                            isMatch,
                            difference
                        });
                    }
                }

                // 生成消息
                let message = '';
                let ppCellsInfo = '';
                if (allMatch) {
                    if (ppRows.length === 1) {
                        message = '重量匹配';
                        ppCellsInfo = `Z${ppRows[0].row}: ${ppRows[0].weight}`;
                    } else {
                        message = `所有PP的重量都匹配 (共${ppRows.length}个PP)`;
                        ppCellsInfo = ppRows.map(p => `${p.state} (Z${p.row}): ${p.weight} ✓`).join(', ');
                    }
                } else {
                    const failedPPs = results.filter(r => !r.isMatch);
                    const passedPPs = results.filter(r => r.isMatch);

                    message = `部分PP的重量不匹配:\n`;
                    message += `  ✓ 通过 (${passedPPs.length}个): ${passedPPs.map(p => p.state).join(', ')}\n`;
                    message += `  ✗ 失败 (${failedPPs.length}个):\n`;
                    failedPPs.forEach(pp => {
                        if (pp.error) {
                            message += `    - ${pp.state} (行${pp.row}): ${pp.error}\n`;
                        } else {
                            message += `    - ${pp.state} (行${pp.row}): ${pp.weight} (差值: ${pp.difference}kg)\n`;
                        }
                    });

                    ppCellsInfo = ppRows.map((p, idx) => {
                        const result = results[idx];
                        const status = result.isMatch ? '✓' : '✗';
                        return `${status} ${p.state} (Z${p.row}): ${p.weight}`;
                    }).join(', ');
                }

                return {
                    isValid: true,
                    isMatch: allMatch,
                    convertedValue: weightInKg, // 原值，不强制6位小数
                    message,
                    ppRows: results,
                    ppCells: ppCellsInfo
                };

            } catch (error) {
                return { isValid: false, message: `重量检验错误: ${error.message}` };
            }
        }

        // 尺寸检验函数
        function checkDimension(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准尺寸数据' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }
                
                const baselineStr = String(baselineValue);
                console.log('原始基准尺寸值:', baselineStr);
                
                // 检查是否包含Open和Closed状态
                const hasOpenClosed = /open|closed/i.test(baselineStr);
                
                if (hasOpenClosed) {
                    return checkFoldableDimensionWithPPData(baselineStr, sheetPP);
                } else {
                    return checkStandardDimensionWithPPData(baselineStr, sheetPP);
                }
                
            } catch (error) {
                return { isValid: false, message: `尺寸检验错误: ${error.message}` };
            }
        }
        
        function checkStandardDimensionWithPPData(baselineStr, sheetPP) {
            console.log('使用PP数据处理标准设备尺寸');
            
            // 首先从PP工作表提取数据
            const ppRawData = extractPPDimensionData(sheetPP);
            console.log('提取的PP数据:', ppRawData);
            
            // 提取基准值中的尺寸 - 假设格式是 Height x Width x Depth
            const dimensionMatch = baselineStr.match(/(\d+(?:\.\d+)?)\s*[xX×]\s*(\d+(?:\.\d+)?)\s*[xX×]\s*(\d+(?:\.\d+)?)/);
            
            if (!dimensionMatch) {
                return { isValid: false, message: '基准值格式无效，无法提取尺寸' };
            }
            
            const baselineDims = {
                height: parseFloat(dimensionMatch[1]),
                width: parseFloat(dimensionMatch[2]),
                depth: parseFloat(dimensionMatch[3])
            };
            
            console.log('基准尺寸:', baselineDims);
            console.log('PP数据:', ppRawData.standard);
            
            // 检查是否成功提取了standard数据
            if (!ppRawData.standard) {
                return { 
                    isValid: false, 
                    message: '未能从PP工作表提取标准设备尺寸数据' 
                };
            }
            
            const result = compareDimensionsDetailed(baselineDims, ppRawData.standard, 'Standard');
            
            return {
                isValid: true,
                isMatch: result.isMatch,
                message: result.detailMessage || result.message,
                baseline: baselineDims,
                ppData: ppRawData.standard,
                heightMatch: result.heightMatch,
                widthMatch: result.widthMatch,
                depthMatch: result.depthMatch
            };
        }
        
        function checkFoldableDimensionWithPPData(baselineStr, sheetPP) {
            console.log('使用PP数据处理折叠设备尺寸');
            console.log('基准字符串:', baselineStr);
            
            // 首先从PP工作表提取数据
            const ppRawData = extractPPDimensionData(sheetPP);
            console.log('提取的PP原始数据:', ppRawData);

            // 工具:从PP数据对象中提取三个尺寸值并排序
            function extractPPDimensions(ppDataObj) {
                if (!ppDataObj) return null;
                const dims = [ppDataObj.height, ppDataObj.width, ppDataObj.depth].filter(d => d !== null);
                return dims.length === 3 ? dims.sort((a, b) => a - b) : null;
            }

            // 解析基准值 - 格式: "Open 73.99 x 171.30 x 7.25mm Closed 88.08 x 73.99 x 15.85mm"
            // 提取Open部分的三个数字
            const openPattern = /open\s+([\d.]+)\s*x\s*([\d.]+)\s*x\s*([\d.]+)\s*mm/i;
            // 提取Closed部分的三个数字
            const closedPattern = /closed\s+([\d.]+)\s*x\s*([\d.]+)\s*x\s*([\d.]+)\s*mm/i;

            const openMatch = baselineStr.match(openPattern);
            const closedMatch = baselineStr.match(closedPattern);

            console.log('Open匹配结果:', openMatch);
            console.log('Closed匹配结果:', closedMatch);

            let results = [];
            let allMatch = true;

            // ========== 处理 Open ==========
            if (openMatch) {
                if (ppRawData.open) {
                    // 基准值的三个尺寸(排序后)
                    const baseOpenDims = [
                        parseFloat(openMatch[1]),
                        parseFloat(openMatch[2]),
                        parseFloat(openMatch[3])
                    ].sort((a, b) => a - b);

                    // PP数据的三个尺寸(排序后)
                    const ppOpenDims = extractPPDimensions(ppRawData.open);

                    console.log('Open基准尺寸(排序):', baseOpenDims);
                    console.log('Open PP尺寸(排序):', ppOpenDims);

                    if (ppOpenDims) {
                        const isMatch = baseOpenDims.length === ppOpenDims.length &&
                                      baseOpenDims.every((val, idx) => Math.abs(val - ppOpenDims[idx]) < 0.01);

                        results.push({
                            state: 'Open',
                            isMatch: isMatch,
                            detailMessage: isMatch
                                ? `Open匹配 (${baseOpenDims.join(' × ')}mm)`
                                : `Open不匹配 (基准: ${baseOpenDims.join(' × ')}, PP: ${ppOpenDims.join(' × ')})`,
                            baseline: baseOpenDims,
                            pp: ppOpenDims
                        });

                        if (!isMatch) allMatch = false;
                    } else {
                        results.push({
                            state: 'Open',
                            isMatch: false,
                            detailMessage: 'Open PP数据不完整'
                        });
                        allMatch = false;
                    }
                } else {
                    results.push({
                        state: 'Open',
                        isMatch: false,
                        detailMessage: '测试数据中未找到Open尺寸'
                    });
                    allMatch = false;
                }
            }

            // ========== 处理 Closed ==========
            if (closedMatch) {
                if (ppRawData.closed) {
                    // 基准值的三个尺寸(排序后)
                    const baseClosedDims = [
                        parseFloat(closedMatch[1]),
                        parseFloat(closedMatch[2]),
                        parseFloat(closedMatch[3])
                    ].sort((a, b) => a - b);

                    // PP数据的三个尺寸(排序后)
                    const ppClosedDims = extractPPDimensions(ppRawData.closed);

                    console.log('Closed基准尺寸(排序):', baseClosedDims);
                    console.log('Closed PP尺寸(排序):', ppClosedDims);

                    if (ppClosedDims) {
                        const isMatch = baseClosedDims.length === ppClosedDims.length &&
                                      baseClosedDims.every((val, idx) => Math.abs(val - ppClosedDims[idx]) < 0.01);

                        results.push({
                            state: 'Closed',
                            isMatch: isMatch,
                            detailMessage: isMatch
                                ? `Closed匹配 (${baseClosedDims.join(' × ')}mm)`
                                : `Closed不匹配 (基准: ${baseClosedDims.join(' × ')}, PP: ${ppClosedDims.join(' × ')})`,
                            baseline: baseClosedDims,
                            pp: ppClosedDims
                        });

                        if (!isMatch) allMatch = false;
                    } else {
                        results.push({
                            state: 'Closed',
                            isMatch: false,
                            detailMessage: 'Closed PP数据不完整'
                        });
                        allMatch = false;
                    }
                } else {
                    results.push({
                        state: 'Closed',
                        isMatch: false,
                        detailMessage: '测试数据中未找到Closed尺寸'
                    });
                    allMatch = false;
                }
            }

            // ========== 汇总消息 ==========
                let message = '';
                if (allMatch && results.length > 0) {
                    message = '折叠设备尺寸全部匹配: ' + results.map(r => r.detailMessage).join('; ');
                } else {
                    const failures = results.filter(r => !r.isMatch);
                    // if (failures.length > 0) {
                    //    message = '折叠设备尺寸不匹配: ' + failures.map(r => r.detailMessage).join('; ');
                    // } else {
                    //     message = '未找到有效的折叠设备尺寸数据';
                    // }
                }

                console.log('最终检验结果:', { isMatch: allMatch, message, results });

                return {
                    isValid: true,
                    isMatch: allMatch,
                    message: message,
                    originalString: baselineStr,
                    results: results,
                    ppData: ppRawData
                };
            }

        // Port检验函数
        function checkPort(baselineValue, sheetPORT) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Port数据' };
                }

                if (!sheetPORT) {
                    return { isValid: false, message: '未找到PORT工作表' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('基准Port值:', baselineStr);

                function normalizePort(str) {
                    return String(str)
                        .toLowerCase()
                        .replace(/-/g, ' ')
                        .replace(/\(.*?\)/g, '')
                        .replace(/\bport\b/g, '')
                        .replace(/\bmbg\b/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }

                function extractPortFeatures(str) {
                    const raw = String(str).toLowerCase();

                    let usbVersion = null;
                    if (/usb\s*3\.2/.test(raw)) usbVersion = 'usb 3.2';
                    else if (/usb\s*3\.1/.test(raw)) usbVersion = 'usb 3.1';
                    else if (/usb\s*4/.test(raw)) usbVersion = 'usb4';

                    const cleaned = raw
                        .replace(/-/g, ' ')
                        .replace(/\bport\b/g, '')
                        .replace(/\bmbg\b/g, '')
                        .replace(/\(.*?\)/g, '')   
                        .replace(/\s+/g, ' ')
                        .trim();

                    return {
                        isTypeC: /type\s*c/.test(cleaned),
                        usbVersion: usbVersion
                    };
                }

                let portTypeCol = null;
                let elementNameCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetPORT[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v)
                            .trim()
                            .toUpperCase()
                            .replace(/\s+/g, '');
                        if (headerValue === 'PORTTYPE' || headerValue === 'PORT_TYPE') {
                            portTypeCol = colLetter;
                        }
                        if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }

                if (!portTypeCol || !elementNameCol) {
                    return {
                        isValid: false,
                        message: `PORT工作表中未找到必要列 (PORTTYPE: ${portTypeCol}, ELEMENT: ${elementNameCol})`
                    };
                }

                // ===== 读取第2行 =====
                const elementNameCell = sheetPORT[`${elementNameCol}2`];
                const portTypeCell = sheetPORT[`${portTypeCol}2`];

                if (!elementNameCell || !portTypeCell) {
                    return { isValid: false, message: 'PORT工作表第2行数据不完整' };
                }

                const elementNameValue = String(elementNameCell.v).trim();
                const portTypeValue = String(portTypeCell.v).trim();

                console.log('Element Desc:', elementNameValue);
                console.log('PORTTYPE:', portTypeValue);

                // ===== 检查1:Element Desc 以 MBG 结尾 =====
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `PORT工作表Element Desc必须以"MBG"结尾，实际为 "${elementNameValue}"`,
                        elementNameValue,
                        portTypeValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }

                // ===== 检查2:Port语义匹配 =====
                const baselineFeatures = extractPortFeatures(baselineStr);
                const testFeatures = extractPortFeatures(portTypeValue);

                const contentMatch =
                    baselineFeatures.isTypeC === testFeatures.isTypeC &&
                    baselineFeatures.usbVersion === testFeatures.usbVersion;

                const isMatch = endsWithMBG && contentMatch;

                // ===== 生成消息 =====
                let message = '';
                if (isMatch) {
                    message = `Port检验通过（PORTTYPE: ${portTypeValue}）`;
                } else {
                    message = `Port检验失败:语义不匹配
        基准: Type-C=${baselineFeatures.isTypeC}, ${baselineFeatures.usbVersion}
        测试: Type-C=${testFeatures.isTypeC}, ${testFeatures.usbVersion}`;
                }

                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    portTypeValue: portTypeValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    baselineFeatures,
                    testFeatures,
                    portCells: `Element (${elementNameCol}2): ${elementNameValue}, PORTTYPE (${portTypeCol}2): ${portTypeValue}`
                };

            } catch (error) {
                return { isValid: false, message: `Port检验错误: ${error.message}` };
            }
        }

        // Warranty检验函数
        function checkWarranty(baselineValue, sheetWAR) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Warranty数据' };
                }

                if (!sheetWAR) {
                    return { isValid: false, message: '未找到WAR工作表' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('基准Warranty值:', baselineStr);

                /* ---------- 工具函数 ---------- */

                // 提取 Year 数值（支持 years / year / 复杂描述）
                function extractYearNumber(value) {
                    if (!value) return null;
                    const str = String(value).toLowerCase();
                    const match = str.match(/(\d+)\s*year/);
                    return match ? Number(match[1]) : null;
                }

                // WAR 表 WARRANTY_PERIOD 格式校验（严格）
                function isValidWarrantyPeriodFormat(value) {
                    if (!value) return false;
                    return /^\d+\s+Year$/.test(String(value).trim());
                }

                /* ---------- 找列 ---------- */

                let warrantyPeriodCol = null;
                let elementNameCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWAR[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v)
                            .trim()
                            .toUpperCase()
                            .replace(/\s+/g, '');

                        if (headerValue === 'WARRANTY_PERIOD' || headerValue === 'WARRANTYPERIOD') {
                            warrantyPeriodCol = colLetter;
                        }

                        if (
                            headerValue === 'ELEMENTNAME' ||
                            headerValue === 'ELEMENT_NAME' ||
                            headerValue === 'IELEMENT_NAME' ||
                            headerValue === 'ELEMENTDESC' ||
                            headerValue === 'ELEMENT_DESC'
                        ) {
                            elementNameCol = colLetter;
                        }
                    }
                }

                if (!warrantyPeriodCol || !elementNameCol) {
                    return {
                        isValid: false,
                        message: `WAR工作表中未找到必要的列 (WARRANTY_PERIOD: ${warrantyPeriodCol}, Element列: ${elementNameCol})`
                    };
                }

                /* ---------- 读值 ---------- */

                const elementNameCell = sheetWAR[`${elementNameCol}2`];
                const warrantyPeriodCell = sheetWAR[`${warrantyPeriodCol}2`];

                if (!elementNameCell) {
                    return { isValid: false, message: `WAR工作表${elementNameCol}2单元格为空` };
                }

                if (!warrantyPeriodCell) {
                    return { isValid: false, message: `WAR工作表${warrantyPeriodCol}2单元格为空` };
                }

                const elementNameValue = String(elementNameCell.v).trim();
                const warrantyPeriodValue = String(warrantyPeriodCell.v).trim();

                console.log('WAR Element:', elementNameValue);
                console.log('WAR WARRANTY_PERIOD:', warrantyPeriodValue);

                /* ---------- 校验 1:Element 以 MBG 结尾 ---------- */

                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';

                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `WAR工作表 Element 必须以 "MBG" 结尾，实际为 "${elementNameValue}"`,
                        elementNameValue,
                        warrantyPeriodValue,
                        endsWithMBG,
                        contentMatch: false
                    };
                }

                /* ---------- 校验 2:WARRANTY_PERIOD ---------- */

                const baselineYear = extractYearNumber(baselineStr);
                const warYear = extractYearNumber(warrantyPeriodValue);
                const formatValid = isValidWarrantyPeriodFormat(warrantyPeriodValue);

                let contentMatch = false;
                let message = '';

                if (!formatValid) {
                    message = `Warranty检验失败:WARRANTY_PERIOD格式必须为 "数字 + Year"，实际为 "${warrantyPeriodValue}"`;
                } else if (baselineYear === null) {
                    message = `Warranty检验失败:无法从基准值解析Year:"${baselineStr}"`;
                } else if (warYear === null) {
                    message = `Warranty检验失败:无法从WARRANTY_PERIOD解析Year:"${warrantyPeriodValue}"`;
                } else if (baselineYear !== warYear) {
                    message = `Warranty检验失败:Year不一致，基准 ${baselineYear} Year ≠ 测试 ${warYear} Year`;
                } else {
                    contentMatch = true;
                    message = `Warranty检验通过（WARRANTYPERIOD: ${warrantyPeriodValue}）`;
                }

                return {
                    isValid: true,
                    isMatch: endsWithMBG && contentMatch,
                    message,
                    elementNameValue,
                    warrantyPeriodValue,
                    endsWithMBG,
                    contentMatch,
                    baselineYear,
                    warYear,
                    warCells: `Element (${elementNameCol}2): ${elementNameValue}, WARRANTY_PERIOD (${warrantyPeriodCol}2): ${warrantyPeriodValue}`
                };

            } catch (error) {
                return { isValid: false, message: `Warranty检验错误: ${error.message}` };
            }
        }

        // Bluetooth检验函数
        function checkBluetooth(baselineValue, sheetWS) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少Bluetooth基准数据' };
                }
                if (!sheetWS) {
                    return { isValid: false, message: '未找到WS工作表' };
                }

                const baselineStr = String(baselineValue).trim();

                /* ---------- 工具函数 ---------- */

                // 提取 Bluetooth 版本号（6 ≡ 6.0）
                function extractBluetoothVersion(text) {
                    if (!text) return null;
                    const match = text.match(/bluetooth[^0-9]*([\d.]+)/i);
                    return match ? parseFloat(match[1]) : null;
                }

                /* ---------- 1. 找列 ---------- */

                let wsTypeCol = null;
                let wsDescCol = null;
                let elementDescCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWS[`${colLetter}1`];
                    if (!headerCell) continue;

                    const header = String(headerCell.v)
                        .trim()
                        .toUpperCase()
                        .replace(/\s+/g, '');

                    if (header === 'WSTYPE') wsTypeCol = colLetter;
                    if (header === 'WSDESC') wsDescCol = colLetter;
                    if (header === 'ELEMENTDESC') elementDescCol = colLetter;
                }

                if (!wsTypeCol || !wsDescCol || !elementDescCol) {
                    return {
                        isValid: false,
                        message: `WS工作表缺少必要列 (WSTYPE: ${wsTypeCol}, WSDESC: ${wsDescCol}, Element Desc: ${elementDescCol})`
                    };
                }

                /* ---------- 2. 定位 Bluetooth 行（WSTYPE = PAN） ---------- */

                let bluetoothRow = null;
                let wsDescValue = null;
                let elementDescValue = null;

                for (let row = 2; row <= 300; row++) {
                    const typeCell = sheetWS[`${wsTypeCol}${row}`];
                    if (!typeCell) continue;

                    const wsType = String(typeCell.v).trim().toUpperCase();
                    if (wsType === 'PAN') {
                        bluetoothRow = row;
                        wsDescValue = sheetWS[`${wsDescCol}${row}`]
                            ? String(sheetWS[`${wsDescCol}${row}`].v).trim()
                            : '';
                        elementDescValue = sheetWS[`${elementDescCol}${row}`]
                            ? String(sheetWS[`${elementDescCol}${row}`].v).trim()
                            : '';
                        break;
                    }
                }

                if (!bluetoothRow) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '未在WS表中找到 WSTYPE = PAN 的Bluetooth行'
                    };
                }

                /* ---------- 3. Element Desc 必须以 MBG 结尾 ---------- */

                const endsWithMBG = elementDescValue.slice(-3).toUpperCase() === 'MBG';

                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `Bluetooth行 Element Desc 必须以 "MBG" 结尾，实际为 "${elementDescValue}"`,
                        wsRow: bluetoothRow,
                        endsWithMBG: false
                    };
                }

                /* ---------- 4. Bluetooth 版本号比对 ---------- */

                const baselineVersion = extractBluetoothVersion(baselineStr);
                const wsVersion = extractBluetoothVersion(wsDescValue);

                if (baselineVersion === null) {
                    return { isValid: false, message: `无法从基准值解析Bluetooth版本:"${baselineStr}"` };
                }

                if (wsVersion === null) {
                    return { isValid: false, message: `无法从WSDESC解析Bluetooth版本:"${wsDescValue}"` };
                }

                const isMatch = baselineVersion === wsVersion;

                return {
                    isValid: true,
                    isMatch,
                    message: isMatch
                        ? `Bluetooth检验通过（WSDESC: ${wsDescValue}）`
                        : `Bluetooth版本号不匹配，基准 ${baselineVersion} ≠ 测试 ${wsVersion}`,
                    wsRow: bluetoothRow,
                    elementDescValue,
                    wsDescValue,
                    baselineVersion,
                    wsVersion
                };

            } catch (error) {
                return { isValid: false, message: `Bluetooth检验错误: ${error.message}` };
            }
        }

        // Wireless检验函数
        function checkWireless(baselineValue, sheetWS) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Wireless数据' };
                }

                if (!sheetWS) {
                    return { isValid: false, message: '未找到WS工作表' };
                }

                const baselineStr = String(baselineValue).trim();

                /* ---------- 1. 找列 ---------- */
                let wsTypeCol = null;
                let wsDescCol = null;
                let elementDescCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWS[`${colLetter}1`];
                    if (!headerCell) continue;

                    const header = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');

                    if (header === 'WSTYPE') wsTypeCol = colLetter;
                    if (header === 'WSDESC') wsDescCol = colLetter;
                    if (header === 'ELEMENTDESC' || header === 'ELEMENT_DESC') elementDescCol = colLetter;
                }

                if (!wsTypeCol || !wsDescCol || !elementDescCol) {
                    return {
                        isValid: false,
                        message: `WS工作表缺少必要列 (WSTYPE:${wsTypeCol}, WSDESC:${wsDescCol}, Element Desc:${elementDescCol})`
                    };
                }

                /* ---------- 2. 查找 WSTYPE = 'WLAN' 的行 ---------- */
                let wlanRow = null;
                for (let row = 2; row <= 300; row++) { // 扫描前300行，可根据表长度调整
                    const typeCell = sheetWS[`${wsTypeCol}${row}`];
                    if (typeCell && String(typeCell.v).trim().toUpperCase() === 'WLAN') {
                        wlanRow = row;
                        break;
                    }
                }

                if (!wlanRow) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'WS工作表中未找到 WSTYPE = WLAN 的Wireless行'
                    };
                }

                /* ---------- 3. 读取对应行数据 ---------- */
                const elementNameCell = sheetWS[`${elementDescCol}${wlanRow}`];
                const wsDescCell = sheetWS[`${wsDescCol}${wlanRow}`];

                if (!elementNameCell) {
                    return { isValid: false, message: `WS工作表${elementDescCol}${wlanRow}单元格为空` };
                }

                if (!wsDescCell) {
                    return { isValid: false, message: `WS工作表${wsDescCol}${wlanRow}单元格为空` };
                }

                const elementNameValue = String(elementNameCell.v).trim();
                const wsDescValue = String(wsDescCell.v).trim();

                // 检查1: Element Name最后三个字符是否为MBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';

                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `Wireless行 Element Name 必须以 "MBG" 结尾，实际为 "${elementNameValue}"`,
                        elementNameValue,
                        wsDescValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }

                // 检查2: WSDESC内容与基准表匹配
                const protocolPattern = /802\.11[a-z\/\d]*/i; // 匹配 802.11 a/b/g/n/ac/ax/be
                const baselineProtocolMatch = baselineStr.match(protocolPattern);
                const testProtocolMatch = wsDescValue.match(protocolPattern);

                const contentMatch = baselineProtocolMatch && testProtocolMatch &&
                     baselineProtocolMatch[0].toUpperCase() === testProtocolMatch[0].toUpperCase();

                const isMatch = endsWithMBG && contentMatch;

                let message = '';
                if (isMatch) {
                    message = `Wireless检验通过（WSDESC: ${wsDescValue}）`;
                } else if (!contentMatch) {
                    message = `Wireless检验失败:WSDESC不匹配，基准值"${baselineStr}" ≠ 测试值"${wsDescValue}"`;
                }

                return {
                    isValid: true,
                    isMatch,
                    message,
                    elementNameValue,
                    wsDescValue,
                    endsWithMBG,
                    contentMatch,
                    wsCells: `Element Name (${elementDescCol}${wlanRow}): ${elementNameValue}, WSDESC (${wsDescCol}${wlanRow}): ${wsDescValue}`
                };

            } catch (error) {
                return { isValid: false, message: `Wireless检验错误: ${error.message}` };
            }
        }

        // What's in the box检验函数
        function checkWhatsInTheBox(baselineValue, sheetMM, sheetObjectElement, partNumber) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: "缺少What's in the box基准数据" };
                }

                const baselineStr = String(baselineValue).trim();
                console.log("What's in the box检验基准值:", baselineStr);

                // 1️⃣ 特殊情况：No XXX
                if (baselineStr.toUpperCase().startsWith("NO")) {
                    console.log("基准值为No开头，MM表可不存在，直接判定通过");
                    return {
                        isValid: true,
                        isMatch: true,
                        message: `基准值是"${baselineStr}"，无需MM表，匹配成功`,
                        baselineValue: baselineStr,
                        testValue: null
                    };
                }

                // 2️⃣ 基准值不是 No，必须有 MM 表和 OBJECT-ELEMENT 表
                if (!sheetMM) {
                    return { isValid: false, isMatch: false, message: "未找到MM工作表" };
                }
                if (!sheetObjectElement) {
                    return { isValid: false, message: '未找到OBJECT-ELEMENT工作表' };
                }
                if (!partNumber) {
                    return { isValid: false, message: '缺少Part Number' };
                }

                /* ===============================
                3️⃣ 在 OBJECT-ELEMENT 表中查找 PN 列
                =============================== */
                let pnCol = null;
                console.log('开始查找PN列，目标PN:', partNumber);
                
                for (let col = 1; col <= 200; col++) {
                    const colLetter = getColumnLetter(col);
                    const header = sheetObjectElement[`${colLetter}6`];
                    if (!header || !header.v) continue;

                    const headerText = String(header.v).trim().toUpperCase();
                    const match = headerText.match(/\[([^\]]+)\]/);
                    if (match) {
                        if (match[1].toUpperCase() === partNumber.toUpperCase()) {
                            pnCol = colLetter;
                            console.log('✓ 找到PN列:', colLetter);
                            break;
                        }
                    }
                }

                if (!pnCol) {
                    console.log('✗ 未找到匹配的PN列');
                    return {
                        isValid: false,
                        message: `OBJECT-ELEMENT表中未找到PN列: ${partNumber}`
                    };
                }

                /* ===============================
                4️⃣ 查找关联的 MM Elements
                =============================== */
                const linkedMMs = [];

                for (let row = 7; row <= 500; row++) {
                    const typeCell = sheetObjectElement[`B${row}`];
                    const elementIdCell = sheetObjectElement[`A${row}`];
                    const pnCell = sheetObjectElement[`${pnCol}${row}`];

                    if (!typeCell || !elementIdCell || !pnCell) continue;

                    const type = String(typeCell.v).trim().toUpperCase();
                    const pnFlag = String(pnCell.v).trim().toUpperCase();

                    if (type === 'MM' && pnFlag === 'X') {
                        const match = String(elementIdCell.v).match(/\[(\d+)\]/);
                        const elementId = match ? match[1] : null;
                        console.log(`找到MM Element: ${elementIdCell.v} -> ID: ${elementId}`);
                        if (elementId) {
                            linkedMMs.push({
                                row,
                                elementId
                            });
                        }
                    }
                }

                if (linkedMMs.length === 0) {
                    console.log('✗ 未找到关联的MM Elements');
                    return {
                        isValid: false,
                        message: '该PN在OBJECT-ELEMENT表中未关联任何MM'
                    };
                }
                
                console.log(`✓ 找到 ${linkedMMs.length} 个关联的MM Elements:`, linkedMMs.map(p => p.elementId).join(', '));

                /* ===============================
                5️⃣ 在 MM 表中查找列标题
                =============================== */
                let elementDescCol = null;
                let whatInTheBoxCol = null;
                
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetMM[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementDescCol = colLetter;
                        }
                        if (headerValue === 'WHAT_INTHEBOX') {
                            whatInTheBoxCol = colLetter;
                        }
                    }
                }
                
                if (!elementDescCol || !whatInTheBoxCol) {
                    return { 
                        isValid: false, 
                        message: `MM工作表中未找到必要的列 (Element Desc: ${elementDescCol}, WHAT_INTHEBOX: ${whatInTheBoxCol})` 
                    };
                }

                console.log('MM表列标题:', { elementDescCol, whatInTheBoxCol });

                /* ===============================
                6️⃣ 在 MM 表中用 Element ID 验证数据
                =============================== */
                const results = [];
                let allMatch = true;

                linkedMMs.forEach(mm => {
                    let found = false;
                    console.log(`在MM表中查找Element ID: ${mm.elementId}`);

                    for (let row = 2; row <= 1000; row++) {
                        const idCell = sheetMM[`A${row}`]; // Element ID
                        if (!idCell) continue;

                        const id = String(idCell.v).trim();
                        if (id === mm.elementId) {
                            found = true;
                            console.log(`✓ 在MM表第${row}行找到Element ID: ${id}`);

                            const elementDescCell = sheetMM[`${elementDescCol}${row}`];
                            const whatInTheBoxCell = sheetMM[`${whatInTheBoxCol}${row}`];
                            
                            const elementDescValue = elementDescCell ? String(elementDescCell.v || '').trim() : '';
                            const whatInTheBoxValue = whatInTheBoxCell ? String(whatInTheBoxCell.v || '').trim() : '';
                            
                            console.log(`  Element Desc: "${elementDescValue}"`);
                            console.log(`  WHAT_INTHEBOX: "${whatInTheBoxValue}"`);

                            // 检查 Element Desc 是否以 MBG 结尾
                            const endsWithMBG = elementDescValue.slice(-3).toUpperCase() === 'MBG';
                            
                            // 检查 WHAT_INTHEBOX 是否匹配基准
                            const contentMatch = whatInTheBoxValue === baselineStr;
                            
                            const isMatch = endsWithMBG && contentMatch;
                            if (!isMatch) allMatch = false;

                            results.push({
                                elementId: id,
                                row,
                                elementDesc: elementDescValue,
                                whatInTheBox: whatInTheBoxValue,
                                endsWithMBG,
                                contentMatch,
                                isMatch
                            });
                            break;
                        }
                    }

                    if (!found) {
                        allMatch = false;
                        results.push({
                            elementId: mm.elementId,
                            row: null,
                            elementDesc: '',
                            whatInTheBox: '',
                            endsWithMBG: false,
                            contentMatch: false,
                            isMatch: false,
                            error: '未在MM表中找到该Element ID'
                        });
                    }
                });

                /* ===============================
                7️⃣ 生成结果信息
                =============================== */
                let message = '';

                if (allMatch) {
                    const firstResult = results[0];
                    message = `What's in the box匹配成功（WHAT_INTHEBOX: ${firstResult.whatInTheBox}）`;
                    if (results.length > 1) {
                        message += `\n共验证 ${results.length} 个关联的MM Elements`;
                    }
                } else {
                    const failed = results.filter(r => !r.isMatch);
                    message = `What's in the box验证失败:\n`;
                    failed.forEach(r => {
                        if (r.error) {
                            message += `- Element ${r.elementId}: ${r.error}\n`;
                        } else {
                            let issues = [];
                            if (!r.endsWithMBG) {
                                issues.push(`Element Desc不以MBG结尾: "${r.elementDesc}"`);
                            }
                            if (!r.contentMatch) {
                                issues.push(`WHAT_INTHEBOX不匹配基准: "${baselineStr}" ≠ "${r.whatInTheBox}"`);
                            }
                            message += `- Element ${r.elementId}: ${issues.join('；')}\n`;
                        }
                    });
                }

                return {
                    isValid: true,
                    isMatch: allMatch,
                    message: message,
                    baselineValue: baselineStr,
                    results
                };

            } catch (error) {
                return { isValid: false, message: `What's in the box检验错误: ${error.message}` };
            }
        }

        // Color检验函数
        function checkColor(baselineValue, sheetPP, sheetObjectElement, partNumber) {
            try {
                // 添加调试信息
                console.log('checkColor 调用参数:');
                console.log('- baselineValue:', baselineValue);
                console.log('- sheetPP:', sheetPP ? '存在' : '不存在');
                console.log('- sheetObjectElement:', sheetObjectElement ? '存在' : '不存在');
                console.log('- partNumber:', partNumber);
                
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Color数据' };
                }
                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }
                if (!sheetObjectElement) {
                    return { isValid: false, message: '未找到OBJECT-ELEMENT工作表' };
                }
                if (!partNumber) {
                    return { isValid: false, message: '缺少Part Number' };
                }

                const baselineColor = String(baselineValue).trim();

                /* ===============================
                1️⃣ 在 Object–Element 表中
                    找到该 PN 列
                =============================== */
                let pnCol = null;
                console.log('开始查找PN列，目标PN:', partNumber);
                
                for (let col = 1; col <= 200; col++) {
                    const colLetter = getColumnLetter(col);
                    const header = sheetObjectElement[`${colLetter}6`];  // OBJECT-ELEMENT表的标题在第6行
                    if (!header || !header.v) continue;

                    const headerText = String(header.v).trim().toUpperCase();
                    
                    // 输出前10列的内容用于调试
                    if (col <= 10) {
                        console.log(`列${colLetter}6内容:`, headerText);
                    }

                    const match = headerText.match(/\[([^\]]+)\]/);
                    if (match) {
                        console.log(`找到PN: ${match[1]} 在列${colLetter}`);
                        if (match[1].toUpperCase() === partNumber.toUpperCase()) {
                            pnCol = colLetter;
                            console.log('✓ 匹配成功，使用列:', colLetter);
                            break;
                        }
                    }
                }

                if (!pnCol) {
                    console.log('✗ 未找到匹配的PN列');
                    return {
                        isValid: false,
                        message: `OBJECT-ELEMENT表中未找到PN列: ${partNumber}`
                    };
                }

                const linkedPPs = [];

                for (let row = 7; row <= 500; row++) {  // OBJECT-ELEMENT表的数据从第7行开始
                    const typeCell = sheetObjectElement[`B${row}`]; // TYPE
                    const elementIdCell = sheetObjectElement[`A${row}`];
                    const pnCell = sheetObjectElement[`${pnCol}${row}`];

                    if (!typeCell || !elementIdCell || !pnCell) continue;

                    const type = String(typeCell.v).trim().toUpperCase();
                    const pnFlag = String(pnCell.v).trim().toUpperCase();

                    if (type === 'PP' && pnFlag === 'X') {
                        // 从格式 "22[27958115507]" 中提取方括号内的数字
                        const match = String(elementIdCell.v).match(/\[(\d+)\]/);
                        const elementId = match ? match[1] : null;
                        console.log(`找到PP Element: ${elementIdCell.v} -> ID: ${elementId}`);
                        if (elementId) {
                            linkedPPs.push({
                                row,
                                elementId
                            });
                        }
                    }
                }

                if (linkedPPs.length === 0) {
                    console.log('✗ 未找到关联的PP Elements');
                    return {
                        isValid: false,
                        message: '该PN在OBJECT-ELEMENT表中未关联任何PP'
                    };
                }
                
                console.log(`✓ 找到 ${linkedPPs.length} 个关联的PP Elements:`, linkedPPs.map(p => p.elementId).join(', '));

                /* ===============================
                3️⃣ 在 PP 表中用 Element ID
                    精确找到颜色
                =============================== */
                const results = [];
                let allMatch = true;

                linkedPPs.forEach(pp => {
                    let found = false;
                    console.log(`在PP表中查找Element ID: ${pp.elementId}`);

                    for (let row = 2; row <= 500; row++) {
                        const idCell = sheetPP[`A${row}`]; // Element ID
                        if (!idCell) continue;

                        const id = String(idCell.v).trim();
                        if (id === pp.elementId) {
                            found = true;
                            console.log(`✓ 在PP表第${row}行找到Element ID: ${id}`);

                            const colorCell = sheetPP[`T${row}`]; // PKG_COLOR
                            const color = colorCell ? String(colorCell.v || '').trim() : '';
                            console.log(`  PKG_COLOR (列T): "${color}"`);

                            const isMatch = color === baselineColor;
                            if (!isMatch) allMatch = false;

                            results.push({
                                elementId: id,
                                row,
                                color,
                                isMatch
                            });
                            break;
                        }
                    }

                    if (!found) {
                        allMatch = false;
                        results.push({
                            elementId: pp.elementId,
                            row: null,
                            color: '',
                            isMatch: false,
                            error: '未在PP表中找到该Element ID'
                        });
                    }
                });

                /* ===============================
                4️⃣ 生成结果信息
                =============================== */
                let message = '';

                if (allMatch) {
                    const colors = results.map(r => r.color).join(', '); // 拼成逗号分隔
                    message = `Color校验通过（PKG_COLOR: ${colors}）`;
                } else {
                    const failed = results.filter(r => !r.isMatch);
                    message = `部分PP的Color不匹配:\n`;
                    failed.forEach(r => {
                        message += `- Element ${r.elementId}: "${r.color}" ≠ "${baselineColor}"\n`;
                    });
                }

                return {
                    isValid: true,
                    isMatch: allMatch,
                    message,
                    baselineColor,
                    results
                };

            } catch (error) {
                return {
                    isValid: false,
                    message: `Color检验错误: ${error.message}`
                };
            }
        }

        // IMG检验函数
        function checkIMG(baselineColor, sheetIMG, sheetObjectElement, partNumber) {
            try {
                console.log('checkIMG 调用参数:');
                console.log('- baselineColor:', baselineColor);
                console.log('- sheetIMG:', sheetIMG ? '存在' : '不存在');
                console.log('- sheetObjectElement:', sheetObjectElement ? '存在' : '不存在');
                console.log('- partNumber:', partNumber);
                
                if (!baselineColor) {
                    return { isValid: false, message: '缺少基准Color数据' };
                }
                if (!sheetIMG) {
                    return { isValid: false, message: '未找到IMG工作表' };
                }
                if (!sheetObjectElement) {
                    return { isValid: false, message: '未找到OBJECT-ELEMENT工作表' };
                }
                if (!partNumber) {
                    return { isValid: false, message: '缺少Part Number' };
                }

                const baselineColorStr = String(baselineColor).trim();

                /* ===============================
                1️⃣ 在 OBJECT-ELEMENT 表中找到该 PN 列
                =============================== */
                let pnCol = null;
                console.log('开始查找PN列,目标PN:', partNumber);
                
                for (let col = 1; col <= 200; col++) {
                    const colLetter = getColumnLetter(col);
                    const header = sheetObjectElement[`${colLetter}6`];
                    if (!header || !header.v) continue;

                    const headerText = String(header.v).trim().toUpperCase();
                    
                    if (col <= 10) {
                        console.log(`列${colLetter}6内容:`, headerText);
                    }

                    const match = headerText.match(/\[([^\]]+)\]/);
                    if (match) {
                        console.log(`找到PN: ${match[1]} 在列${colLetter}`);
                        if (match[1].toUpperCase() === partNumber.toUpperCase()) {
                            pnCol = colLetter;
                            console.log('✓ 匹配成功,使用列:', colLetter);
                            break;
                        }
                    }
                }

                if (!pnCol) {
                    console.log('✗ 未找到匹配的PN列');
                    return {
                        isValid: false,
                        message: `OBJECT-ELEMENT表中未找到PN列: ${partNumber}`
                    };
                }

                /* ===============================
                2️⃣ 找到所有标记为 X 的 IMG Elements
                =============================== */
                const linkedIMGs = [];

                for (let row = 7; row <= 500; row++) {
                    const typeCell = sheetObjectElement[`B${row}`]; // TYPE列
                    const elementIdCell = sheetObjectElement[`A${row}`]; // Element ID列
                    const pnCell = sheetObjectElement[`${pnCol}${row}`]; // PN列

                    if (!typeCell || !elementIdCell || !pnCell) continue;

                    const type = String(typeCell.v).trim().toUpperCase();
                    const pnFlag = String(pnCell.v).trim().toUpperCase();

                    if (type === 'IMG' && pnFlag === 'X') {
                        // 从格式 "22[27958115507]" 中提取方括号内的数字
                        const match = String(elementIdCell.v).match(/\[(\d+)\]/);
                        const elementId = match ? match[1] : null;
                        console.log(`找到IMG Element: ${elementIdCell.v} -> ID: ${elementId}`);
                        if (elementId) {
                            linkedIMGs.push({
                                row,
                                elementId
                            });
                        }
                    }
                }

                if (linkedIMGs.length === 0) {
                    console.log('✗ 未找到关联的IMG Elements');
                    return {
                        isValid: false,
                        message: '该PN在OBJECT-ELEMENT表中未关联任何IMG'
                    };
                }
                
                console.log(`✓ 找到 ${linkedIMGs.length} 个关联的IMG Elements:`, linkedIMGs.map(p => p.elementId).join(', '));

                /* ===============================
                3️⃣ 在 IMG 表中用 Element ID 精确找到并检查
                =============================== */
                // 先找到IMG表的列位置
                let imgElementIdCol = null;
                let imgElementDescCol = null;
                let mktingImageCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetIMG[`${colLetter}1`];
                    if (!headerCell) continue;

                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    
                    if (headerValue === 'ELEMENTID' || headerValue === 'ELEMENT_ID') {
                        imgElementIdCol = colLetter;
                    }
                    if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                        imgElementDescCol = colLetter;
                    }
                    if (headerValue === 'MKTING_IMAGE' || headerValue === 'MKTINGIMAGE') {
                        mktingImageCol = colLetter;
                    }
                }

                if (!imgElementIdCol || !imgElementDescCol || !mktingImageCol) {
                    return {
                        isValid: false,
                        message: `IMG表中缺少必要的列 (Element ID: ${imgElementIdCol}, Element Desc: ${imgElementDescCol}, MKTING_IMAGE: ${mktingImageCol})`
                    };
                }

                console.log('IMG表列位置:', {
                    elementId: imgElementIdCol,
                    elementDesc: imgElementDescCol,
                    mktingImage: mktingImageCol
                });

                const results = [];
                let allMatch = true;

                linkedIMGs.forEach(img => {
                    let found = false;
                    console.log(`在IMG表中查找Element ID: ${img.elementId}`);

                    for (let row = 2; row <= 500; row++) {
                        const idCell = sheetIMG[`${imgElementIdCol}${row}`];
                        if (!idCell) continue;

                        const id = String(idCell.v).trim();
                        if (id === img.elementId) {
                            found = true;
                            console.log(`✓ 在IMG表第${row}行找到Element ID: ${id}`);

                            const descCell = sheetIMG[`${imgElementDescCol}${row}`];
                            const imageCell = sheetIMG[`${mktingImageCol}${row}`];

                            const desc = descCell ? String(descCell.v || '').trim() : '';
                            const imagePath = imageCell ? String(imageCell.v || '').trim() : '';

                            console.log(`  Element Desc: "${desc}"`);
                            console.log(`  MKTING_IMAGE: "${imagePath}"`);

                            // 检查1: Element Desc必须以MBG结尾
                            const endsWithMBG = desc.slice(-3).toUpperCase() === 'MBG';
                            
                            // 检查2: Element Desc必须包含baselineColor
                            const containsColor = desc.includes(baselineColorStr);
                            
                            // 检查3: MKTING_IMAGE必须以.png结尾
                            const isPNG = imagePath.toLowerCase().endsWith('.png');

                            const isMatch = endsWithMBG && containsColor && isPNG;
                            
                            if (!isMatch) allMatch = false;

                            const issues = [];
                            if (!endsWithMBG) issues.push('未以MBG结尾');
                            if (!containsColor) issues.push(`不包含颜色"${baselineColorStr}"`);
                            if (!isPNG) issues.push('图片非.png格式');

                            results.push({
                                elementId: id,
                                row,
                                desc,
                                imagePath,
                                endsWithMBG,
                                containsColor,
                                isPNG,
                                isMatch,
                                issues: issues.length > 0 ? issues : null
                            });
                            break;
                        }
                    }

                    if (!found) {
                        allMatch = false;
                        results.push({
                            elementId: img.elementId,
                            row: null,
                            desc: '',
                            imagePath: '',
                            isMatch: false,
                            error: '未在IMG表中找到该Element ID'
                        });
                    }
                });

                /* ===============================
                4️⃣ 生成结果信息
                =============================== */
                let message = '';

                if (allMatch) {
                    const images = results.map(r => r.imagePath).join(', ');
                    message = `✓ IMG校验通过（MKTING_IMAGE: ${images}）`;
                } else {
                    const failed = results.filter(r => !r.isMatch);
                    message = `部分IMG不符合要求:\n`;
                    failed.forEach(r => {
                        if (r.error) {
                            message += `- Element ${r.elementId}: ${r.error}\n`;
                        } else if (r.issues) {
                            message += `- Element ${r.elementId}: ${r.issues.join(', ')}\n`;
                        }
                    });
                }

                return {
                    isValid: true,
                    isMatch: allMatch,
                    message,
                    baselineColor: baselineColorStr,
                    results
                };

            } catch (error) {
                return {
                    isValid: false,
                    message: `IMG检验异常: ${error.message}`
                };
            }
        }

        //分产品展示结果
        function displayTechResultsMultiple(allProductResults) {
            const resultsDiv = document.getElementById('techResults');
            const checkResultsDiv = document.getElementById('techCheckResults');
            const summaryDiv = document.getElementById('techSummary');


            // 清空之前的结果
            checkResultsDiv.innerHTML = '';

            // 顶部总览
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background: rgba(227, 242, 253, 0.8);
                border: 2px solid #2196f3;
                border-radius: 16px;
                padding: 18px;
                margin-bottom: 32px;
                font-size: 16px;
                font-weight: 600;
                text-align: center;
                backdrop-filter: blur(8px);
            `;
            totalInfoDiv.innerHTML = `
                共检验 <span style="color:#2196f3;font-size:22px;">${allProductResults.length}</span> 个Part Number
            `;
            checkResultsDiv.appendChild(totalInfoDiv);

            let totalMatchedCount = 0;
            let totalUnmatchedCount = 0;

            allProductResults.forEach((productResult, productIndex) => {
                // 每个产品组
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 40px;
                    border: 2px solid rgba(44, 62, 80, 0.08);
                    border-radius: 24px;
                    background: rgba(255, 255, 255, 0.6);
                    backdrop-filter: blur(10px);
                    overflow: hidden;
                    box-shadow: 0 4px 20px rgba(44, 62, 80, 0.06);
                `;

                // 产品标题
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                    color: white;
                    padding: 24px 32px;
                    font-weight: 600;
                    font-size: 1.1rem;
                `;
                headerDiv.innerHTML = `
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <div>
                            <span style="font-size:1.3rem;">Part Number ${productIndex + 1}: ${productResult.partNumber}</span><br>
                        </div>
                        <div style="background:rgba(255,255,255,0.15);padding:10px 20px;border-radius:20px;">
                            通过率 ${((productResult.matchResults.filter(r => r.isMatched).length / productResult.matchResults.length) * 100).toFixed(1)}%
                        </div>
                    </div>
                `;
                groupDiv.appendChild(headerDiv);

                // 检查项容器
                const checksContainer = document.createElement('div');
                checksContainer.style.cssText = `padding:24px;`;

                productResult.matchResults.forEach(result => {
                    const itemDiv = document.createElement('div');

                    // 判定状态
                    let isPass = result.isMatched;
                    totalMatchedCount += isPass ? 1 : 0;
                    totalUnmatchedCount += isPass ? 0 : 1;

                    let statusClass = isPass ? 'pass' : 'fail';
                    let statusText = isPass ? 'PASS' : 'FAIL';
                    let extraInfo = '';
                    if (result.checkResult && result.checkResult.message) {
                        extraInfo = `<br><small style="color:${isPass ? '#28a745' : '#dc3545'};font-weight:400;font-size:0.85rem;">${isPass ? '✓' : '✗'} ${result.checkResult.message}</small>`;
                    }

                    // 单条卡片风格
                    itemDiv.style.cssText = `
                        display:flex;
                        justify-content:space-between;
                        align-items:center;
                        padding:20px 24px;
                        margin:12px 0;
                        background: rgba(255,255,255,0.9);
                        border-radius:16px;
                        border:1px solid rgba(44,62,80,0.06);
                        box-shadow:0 2px 8px rgba(44,62,80,0.04);
                    `;

                    itemDiv.innerHTML = `
                        <div style="flex:1;font-weight:600;color:#2c3e50;">
                            ${result.attribute || ''}<br>
                            <small style="color:#7f8c8d;font-weight:300;font-size:0.85rem;">(${result.abbreviation || ''})</small>
                        </div>
                        <div style="flex:2;text-align:center;color:#7f8c8d;line-height:1.6;">
                            基准: <span style="color:#7f8c8d;font-weight:500;">${result.baselineValue || '(空)'}</span><br>
                            测试: <span style="color:#7f8c8d;font-weight:500;">${result.testValue || '(空)'}</span>
                            ${extraInfo}
                        </div>
                        <div class="status ${statusClass}" style="padding:10px 20px;border-radius:20px;font-weight:500;min-width:90px;text-align:center;">
                            ${statusText}
                        </div>
                    `;

                    checksContainer.appendChild(itemDiv);
                });

                groupDiv.appendChild(checksContainer);
                checkResultsDiv.appendChild(groupDiv);
            });

            // 汇总区
            const totalCount = totalMatchedCount + totalUnmatchedCount;
            const totalPassRate = totalCount ? ((totalMatchedCount / totalCount) * 100).toFixed(1) : 0;
            const successfulProducts = allProductResults.filter(p => p.matchResults.every(r => r.isMatched)).length;
            const partialProducts = allProductResults.length - successfulProducts;
            const notFoundProducts = allProductResults.filter(p => p.matchResults.length === 0).length;

            summaryDiv.innerHTML = `
                <h4 style="font-size:28px;font-weight:700;color:#2c3e50;margin-bottom:48px;">总体检验汇总</h4>
                <div class="summary-stats" style="display:flex;justify-content:center;gap:80px;flex-wrap:wrap;">
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number" style="font-size:56px;font-weight:700;color:#2c3e50;margin-bottom:16px;display:block;letter-spacing:-2px;">${allProductResults.length}</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">总产品数</div>
                    </div>
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number pass" style="font-size:56px;font-weight:700;color:#27ae60;margin-bottom:16px;display:block;letter-spacing:-2px;">${successfulProducts}</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">完全通过</div>
                    </div>
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number fail" style="font-size:56px;font-weight:700;color:#e74c3c;margin-bottom:16px;display:block;letter-spacing:-2px;">${partialProducts}</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">部分通过</div>
                    </div>
                </div>
                <div style="padding-top:32px;border-top:1px solid rgba(44,62,80,0.08);display:flex;justify-content:center;gap:80px;">
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number pass" style="font-size:56px;font-weight:700;color:#27ae60;margin-bottom:16px;display:block;letter-spacing:-2px;">${totalMatchedCount}</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">总通过项目</div>
                    </div>
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number fail" style="font-size:56px;font-weight:700;color:#e74c3c;margin-bottom:16px;display:block;letter-spacing:-2px;">${totalUnmatchedCount}</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">总失败项目</div>
                    </div>
                    <div class="stat-item" style="text-align:center;padding:20px;">
                        <span class="stat-number" style="font-size:56px;font-weight:700;color:#2c3e50;margin-bottom:16px;display:block;letter-spacing:-2px;">${totalPassRate}%</span>
                        <div class="stat-label" style="color:#7f8c8d;font-size:15px;font-weight:400;letter-spacing:0.3px;">总通过率</div>
                    </div>
                </div>
            `;

            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }
            
    </script>
</body>
</html>
