<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBG表格QC检验工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            background: #f8f9fa;
            display: flex;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 20px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            color: #495057;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #f8f9fa;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab:hover:not(.active) {
            background: #dee2e6;
        }

        .tab-content {
            display: none;
            padding: 40px;
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-box:hover {
            border-color: #764ba2;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .upload-box:hover::before {
            opacity: 1;
        }

        .upload-box > * {
            position: relative;
            z-index: 1;
        }

        .upload-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .upload-box input[type="file"] {
            margin: 15px 0;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            width: 100%;
        }

        .file-info {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #666;
        }

        .check-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .check-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .check-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            margin-top: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .results h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }

        .check-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .check-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .check-item .item-name {
            font-weight: bold;
            color: #333;
            flex: 1;
        }

        .check-item .item-values {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #666;
            margin: 0 20px;
            text-align: center;
            flex: 2;
        }

        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .status.pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .summary {
            margin-top: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            text-align: center;
        }

        .summary h4 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-number.pass {
            color: #28a745;
        }

        .stat-number.fail {
            color: #dc3545;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 40px;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tab-content {
                padding: 20px;
            }

            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 MBG表格QC检验工具</h1>
            <p>支持基准表与检验表的智能数据对比</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('basic-qc', this)">基础数据检验</button>
            <button class="tab" onclick="switchTab('tech-spec', this)">技术规格检验</button>
        </div>

        <!-- 基础QC检验 -->
        <div id="basic-qc" class="tab-content active">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>📋 基准表 (Tech Spec)</h3>
                    <input type="file" id="fileA" accept=".xlsx,.xls" />
                    <p>请上传包含"POR"工作表的Excel文件</p>
                    <div id="fileAInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>🔍 检验表 (Offering)</h3>
                    <input type="file" id="fileB" accept=".xlsx,.xls" />
                    <p>请上传包含"MTM_MMR"工作表的Excel文件</p>
                    <div id="fileBInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnBasic" onclick="performBasicQC()" disabled>
                开始基础数据检验
            </button>
            
            <div id="basicResults" class="results" style="display: none;">
                <h3>🔎 基础数据检验结果</h3>
                <div id="basicCheckResults"></div>
                <div id="basicSummary" class="summary"></div>
            </div>
        </div>

        <!-- 技术规格匹配 -->
        <div id="tech-spec" class="tab-content">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>📋 基准表 (Tech Spec)</h3>
                    <input type="file" id="fileBaseline" accept=".xlsx,.xls" />
                    <p>请上传包含"Tech Spec"工作表的Excel文件</p>
                    <div id="fileBaselineInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>🔍 测试文件 (mtmElement)</h3>
                    <input type="file" id="fileTest" accept=".xlsx,.xls" />
                    <p>请上传包含"OBJECT-ELEMENT"工作表的Excel文件</p>
                    <div id="fileTestInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnTech" onclick="performTechSpecMatch()" disabled>
                开始技术规格匹配
            </button>
            
            <div id="techResults" class="results" style="display: none;">
                <h3>🔎  技术规格匹配结果</h3>
                <div id="productInfo" style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                    <strong>产品名称:</strong> <span id="productName"></span>
                </div>
                <div id="techCheckResults"></div>
                <div id="techSummary" class="summary"></div>
            </div>
        </div>
            
        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        // 全局变量
        let fileAData = null;
        let fileBData = null;
        let fileBaselineData = null;
        let fileTestData = null;

        // 切换标签页
        function switchTab(tabId, element) {
            // 隐藏所有标签内容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 移除所有标签的active类
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示目标标签内容
            document.getElementById(tabId).classList.add('active');
            
            // 激活目标标签
            element.classList.add('active');
            
            // 隐藏错误消息
            hideError();
        }

        // 显示错误消息
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // 隐藏错误消息
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ===================基础QC检验功能===================
        
        // 日期格式标准化函数
        function normalizeDate(value) {
            if (!value) return value;
            
            // 如果是Excel日期数字，转换为日期对象
            if (typeof value === 'number' && value > 25000 && value < 100000) {
                try {
                    // Excel日期转换
                    const date = XLSX.SSF.parse_date_code(value);
                    return `${date.y}-${String(date.m).padStart(2, '0')}-${String(date.d).padStart(2, '0')}`;
                } catch (e) {
                    return value;
                }
            }
            
            // 如果已经是字符串日期，尝试标准化格式
            if (typeof value === 'string') {
                // 匹配 YYYY-MM-DD 格式
                let dateMatch = value.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
                if (dateMatch) {
                    const [, year, month, day] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
                
                // 匹配 MM/DD/YYYY 格式
                dateMatch = value.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (dateMatch) {
                    const [, month, day, year] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
            }
            
            return value;
        }

        // 国家列表比较函数（顺序无关）
        function compareCountryLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // 将字符串转换为国家代码数组
            const countries1 = String(val1).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            const countries2 = String(val2).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            
            // 排序后比较
            countries1.sort();
            countries2.sort();
            
            const isMatch = countries1.length === countries2.length && 
                   countries1.every((country, index) => country === countries2[index]);
            
            // 如果不匹配，计算差异信息
            if (!isMatch) {
                const missing = countries1.filter(c => !countries2.includes(c));
                const extra = countries2.filter(c => !countries1.includes(c));
                
                let diffMessage = '';
                if (missing.length > 0) {
                    diffMessage += `B表缺失: ${missing.join(', ')}`;
                }
                if (extra.length > 0) {
                    if (diffMessage) diffMessage += '; ';
                    diffMessage += `B表多出: ${extra.join(', ')}`;
                }
                
                // 将差异信息存储在全局变量中，供显示时使用
                compareCountryLists.lastDiffMessage = diffMessage;
            } else {
                compareCountryLists.lastDiffMessage = null;
            }
            
            return isMatch;
        }

        // Audience比较函数（分割后匹配）
        function compareAudienceLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // 将字符串转换为Audience数组，支持逗号和空格分隔
            const audience1 = String(val1).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            const audience2 = String(val2).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            
            // 排序后比较
            audience1.sort();
            audience2.sort();
            
            return audience1.length === audience2.length && 
                   audience1.every((audience, index) => audience === audience2[index]);
        }

        // 通用值比较函数
        function compareValues(val1, val2, convertFunc = null, customCompareFunc = null) {
            // 如果提供了自定义比较函数，直接使用
            if (customCompareFunc) {
                return customCompareFunc(val1, val2);
            }
            
            // 应用转换函数（如果提供）
            if (convertFunc) {
                val1 = convertFunc(val1);
                val2 = convertFunc(val2);
            }
            
            // 处理空值
            if (val1 === null || val1 === undefined || val1 === '') {
                val1 = '';
            }
            if (val2 === null || val2 === undefined || val2 === '') {
                val2 = '';
            }
            
            // 转换为字符串进行比较
            return String(val1).trim() === String(val2).trim();
        }

        // 基础QC功能中查找匹配的Part Number行
        function findMatchingRowInPORBasic(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number(基础QC):', testPartNumber);
            
            // 从B2开始向下查找,直到B列为空
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空,停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空,停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    return row;
                }
                
                row++;
                
                // 防止无限循环,最多查找1000行
                if (row > 1000) {
                    console.log('超过最大查找行数,停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        // 在基准表POR中查找匹配的Part Number行(用于技术规格检验)
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number(技术规格):', testPartNumber);
            
            // 从E2开始向下查找,直到E列为空
            let row = 2;
            while (true) {
                const eCell = `E${row}`;
                const partNumber = sheetPOR[eCell] ? String(sheetPOR[eCell].v).trim() : '';
                
                // 如果E列为空,停止查找
                if (!partNumber) {
                    console.log(`行${row}: E列为空,停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    
                    // 获取该行的相关数据
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('匹配行数据:', rowData);
                    return rowData;
                }
                
                row++;
                
                // 防止无限循环,最多查找1000行
                if (row > 1000) {
                    console.log('超过最大查找行数,停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        // 基础QC文件上传处理
        document.getElementById('fileA').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileAData = workbook;
                        
                        document.getElementById('fileAInfo').style.display = 'block';
                        document.getElementById('fileAInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取文件A失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取文件A时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileB').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBData = workbook;
                        
                        document.getElementById('fileBInfo').style.display = 'block';
                        document.getElementById('fileBInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取文件B失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取文件B时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkBasicButtonState() {
            const btn = document.getElementById('checkBtnBasic');
            if (fileAData && fileBData) {
                btn.disabled = false;
            }
        }

        function performBasicQC() {
            try {
                hideError();
                
                if (!fileAData.SheetNames.includes('POR')) {
                    throw new Error('基准表(A表)中未找到"POR"工作表');
                }
                
                if (!fileBData.SheetNames.includes('MTM_MMR')) {
                    throw new Error('检验表(B表)中未找到"MTM_MMR"工作表');
                }
                
                const sheetA = fileAData.Sheets['POR'];
                const sheetB = fileBData.Sheets['MTM_MMR'];
                
                // 1. 遍历检验表的B列,从B7开始,收集所有Part Number
                const testPartNumbers = [];
                let testRow = 7;
                
                console.log('开始遍历检验表B列,收集Part Numbers...');
                
                while (true) {
                    const bCell = `B${testRow}`;
                    const partNumber = sheetB[bCell] ? String(sheetB[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        console.log(`检验表B${testRow}为空,停止遍历`);
                        break;
                    }
                    
                    console.log(`检验表B${testRow}: Part Number = "${partNumber}"`);
                    testPartNumbers.push({
                        partNumber: partNumber,
                        testRow: testRow
                    });
                    
                    testRow++;
                    
                    if (testRow > 1000) {
                        console.log('超过最大查找行数,停止遍历');
                        break;
                    }
                }
                
                console.log(`共找到${testPartNumbers.length}个Part Number需要检验`);
                
                if (testPartNumbers.length === 0) {
                    throw new Error('检验表中未找到任何Part Number(从B7开始)');
                }
                
                // 2. 对每个Part Number进行检验
                let allResults = [];
                let totalPassCount = 0;
                let totalFailCount = 0;
                
                testPartNumbers.forEach((testInfo, index) => {
                    console.log(`\n====== 检验第${index + 1}个Part Number: ${testInfo.partNumber} (检验表第${testInfo.testRow}行) ======`);
                    
                    let matchedRow = null;
                    const foundRow = findMatchingRowInPORBasic(sheetA, testInfo.partNumber);
                    
                    if (foundRow !== null) {
                        matchedRow = foundRow;
                        console.log(`找到匹配的Part Number,使用基准表第${matchedRow}行数据`);
                    } else {
                        console.log(`未找到匹配的Part Number: ${testInfo.partNumber}`);
                        allResults.push({
                            partNumber: testInfo.partNumber,
                            testRow: testInfo.testRow,
                            matchedRow: null,
                            checks: [],
                            notFound: true
                        });
                        totalFailCount++;
                        return;
                    }
                    
                    const checks = [
                        {
                            name: 'Part Number',
                            cellA: `B${matchedRow}`,
                            cellB: `B${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Mkt Description',
                            cellA: `D${matchedRow}`,
                            cellB: `Y${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Audience',
                            cellA: `J${matchedRow}`,
                            cellB: `AB${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareAudienceLists
                        },
                        {
                            name: 'Country',
                            cellA: `G${matchedRow}`,
                            cellB: `AC${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareCountryLists
                        },
                        {
                            name: 'Annc Date',
                            cellA: `H${matchedRow}`,
                            cellB: `AE${testInfo.testRow}`,
                            converter: normalizeDate,
                            customCompareFunc: null
                        },
                        {
                            name: 'WW',
                            cellA: `K${matchedRow}`,
                            cellB: `AI${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        }
                    ];
                    
                    let checkResults = [];
                    let passCount = 0;
                    let failCount = 0;
                    
                    checks.forEach(check => {
                        const valueA = sheetA[check.cellA] ? sheetA[check.cellA].v : '';
                        const valueB = sheetB[check.cellB] ? sheetB[check.cellB].v : '';
                        
                        const isMatch = compareValues(valueA, valueB, check.converter, check.customCompareFunc);
                        
                        let displayValueA = valueA;
                        let displayValueB = valueB;
                        
                        if (check.converter) {
                            displayValueA = check.converter(valueA);
                            displayValueB = check.converter(valueB);
                        }
                        
                        if (check.customCompareFunc === compareCountryLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }

                        if (check.customCompareFunc === compareAudienceLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }
                        
                        checkResults.push({
                            name: check.name,
                            valueA: displayValueA,
                            valueB: displayValueB,
                            cellA: check.cellA,
                            cellB: check.cellB,
                            isMatch: isMatch,
                            diffMessage: check.customCompareFunc === compareCountryLists ? compareCountryLists.lastDiffMessage : null
                        });
                        
                        if (isMatch) {
                            passCount++;
                        } else {
                            failCount++;
                        }
                    });
                    
                    totalPassCount += passCount;
                    totalFailCount += failCount;
                    
                    allResults.push({
                        partNumber: testInfo.partNumber,
                        testRow: testInfo.testRow,
                        matchedRow: matchedRow,
                        checks: checkResults,
                        passCount: passCount,
                        failCount: failCount,
                        notFound: false
                    });
                });
                
                displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount);
                
            } catch (error) {
                showError(`检验过程出错: ${error.message}`);
                console.error('基础QC检验错误:', error);
            }
        }
        
        function displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount) {
            const resultsDiv = document.getElementById('basicResults');
            const checkResultsDiv = document.getElementById('basicCheckResults');
            const summaryDiv = document.getElementById('basicSummary');
            
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    共检验 <span style="color: #2196f3; font-size: 20px;">${allResults.length}</span> 个Part Number
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            allResults.forEach((result, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                if (result.notFound) {
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">📦 Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">检验表第${result.testRow}行</small>
                            </div>
                            <div style="background: #dc3545; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                ❌ 未找到匹配
                            </div>
                        </div>
                    `;
                    
                    const notFoundMsg = document.createElement('div');
                    notFoundMsg.style.cssText = `
                        background: #f8d7da;
                        color: #721c24;
                        padding: 15px;
                        border-radius: 8px;
                        margin-top: 10px;
                        border: 1px solid #f5c6cb;
                    `;
                    notFoundMsg.textContent = `⚠️ 在基准表中未找到Part Number "${result.partNumber}" 的匹配行`;
                    
                    groupDiv.appendChild(headerDiv);
                    groupDiv.appendChild(notFoundMsg);
                } else {
                    const passRate = result.checks.length > 0 ? 
                        ((result.passCount / result.checks.length) * 100).toFixed(1) : 0;
                    
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">📦 Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">检验表第${result.testRow}行 ↔️ 基准表第${result.matchedRow}行</small>
                            </div>
                            <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                通过率: ${passRate}%
                            </div>
                        </div>
                    `;
                    
                    groupDiv.appendChild(headerDiv);
                    
                    const checksContainer = document.createElement('div');
                    checksContainer.style.cssText = `
                        margin-top: 15px;
                    `;
                    
                    result.checks.forEach(check => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'check-item';
                        itemDiv.style.cssText = `
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 15px 20px;
                            margin: 10px 0;
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                            transition: all 0.3s ease;
                        `;
                        
                        const statusClass = check.isMatch ? 'pass' : 'fail';
                        const statusText = check.isMatch ? 'PASS' : 'FAIL';
                        
                        let diffInfo = '';
                        if (!check.isMatch && check.diffMessage) {
                            diffInfo = `<br><small style="color: #dc3545; font-style: italic;">${check.diffMessage}</small>`;
                        }
                        
                        itemDiv.innerHTML = `
                            <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">${check.name}</div>
                            <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                                基准表(${check.cellA}): ${check.valueA || '(空)'}<br>
                                检验表(${check.cellB}): ${check.valueB || '(空)'}${diffInfo}
                            </div>
                            <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                        `;
                        
                        checksContainer.appendChild(itemDiv);
                    });
                    
                    groupDiv.appendChild(checksContainer);
                }
                
                checkResultsDiv.appendChild(groupDiv);
            });
            
            const totalCount = totalPassCount + totalFailCount;
            const totalPassRate = totalCount > 0 ? ((totalPassCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulParts = allResults.filter(r => !r.notFound && r.failCount === 0).length;
            const partialParts = allResults.filter(r => !r.notFound && r.failCount > 0).length;
            const notFoundParts = allResults.filter(r => r.notFound).length;
            
            summaryDiv.innerHTML = `
                <h4>总体检验汇总</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allResults.length}</span>
                        <div class="stat-label">总Part Number数</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulParts}</span>
                        <div class="stat-label">完全通过</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialParts}</span>
                        <div class="stat-label">部分通过</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number fail">${notFoundParts}</span>
                        <div class="stat-label">未找到匹配</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalPassCount}</span>
                            <div class="stat-label">总通过项目</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalFailCount}</span>
                            <div class="stat-label">总失败项目</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">总通过率</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        // ===================技术规格匹配功能===================
        
        // 技术规格映射表
        const techSpecMapping = {
            'Processor': 'PRC',
            'OS': 'OS',
            'Display': 'MON',
            'Storage': 'HD',
            'Memory': 'MEM',
            'Graphics': 'GRA',
            'Front Camera': 'CAM',
            'Back Camera': 'CAM',
            'Back': 'CAM',
            'Audio': 'AUD',
            'Fingerprint Reader': 'SEC',
            'Weight': 'PP',
            'Weight/Dimension': 'PP',
            'Dimension': 'PP',
            'Port': 'PORT',
            'Warranty': 'WAR',
            'Bluetooth': 'WS',
            'Wireless': 'WS',
            'What\'s in the box': 'MM',
            'Color': 'COLOR',
            'Battery Life': 'TI',
            'IMG': 'IMG'
        };

        // 技术规格文件上传处理
        document.getElementById('fileBaseline').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBaselineData = workbook;
                        
                        document.getElementById('fileBaselineInfo').style.display = 'block';
                        document.getElementById('fileBaselineInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取基准文件失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取基准文件时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileTest').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileTestData = workbook;
                        
                        document.getElementById('fileTestInfo').style.display = 'block';
                        document.getElementById('fileTestInfo').innerHTML = `
                            <strong>文件名:</strong> ${file.name}<br>
                            <strong>工作表:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>状态:</strong> ✅ 已加载
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`读取测试文件失败: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('读取测试文件时发生错误');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkTechButtonState() {
            const btn = document.getElementById('checkBtnTech');
            if (fileBaselineData && fileTestData) {
                btn.disabled = false;
            }
        }

        // 从指定列提取基准规格数据
        function extractBaselineSpecsForColumn(sheet, column) {
            const specs = {};
            
            console.log(`开始从列${column}提取基准规格`);
            
            // 从第2行开始读取规格,直到遇到#EOF或超出合理范围
            let row = 2;
            const maxRows = 100;
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${column}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`行${row}: 属性="${attrName}", 值="${attrValue}"`);
                
                // 检查是否遇到#EOF标记
                if (attrName === '#EOF') {
                    console.log('遇到#EOF标记,停止读取');
                    break;
                }
                
                // 只添加techSpecMapping中定义的属性
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`添加规格: ${attrName} = "${attrValue}" (映射到: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`跳过未映射的属性: ${attrName}`);
                }
                
                row++;
            }
            
            console.log(`列${column}基准规格提取完成,总共提取到:`, Object.keys(specs).length, '个规格');
            console.log('规格列表:', Object.keys(specs));
            
            return specs;
        }

        function performTechSpecMatch() {
            try {
                hideError();
                
                // 检查工作表是否存在
                if (!fileBaselineData.SheetNames.includes('Tech Spec')) {
                    throw new Error('基准文件中未找到"Tech Spec"工作表');
                }
                
                if (!fileTestData.SheetNames.includes('OBJECT-ELEMENT')) {
                    throw new Error('测试文件中未找到"OBJECT-ELEMENT"工作表');
                }
                
                // 检查PP工作表是否存在
                let sheetPP = null;
                if (fileTestData.SheetNames.includes('PP')) {
                    sheetPP = fileTestData.Sheets['PP'];
                }
                
                // 检查CAM工作表是否存在
                let sheetCAM = null;
                if (fileTestData.SheetNames.includes('CAM')) {
                    sheetCAM = fileTestData.Sheets['CAM'];
                }
                
                // 检查WS工作表是否存在
                let sheetWS = null;
                if (fileTestData.SheetNames.includes('WS')) {
                    sheetWS = fileTestData.Sheets['WS'];
                }
                
                // 检查POR工作表是否存在
                let sheetPOR = null;
                if (fileBaselineData.SheetNames.includes('POR')) {
                    sheetPOR = fileBaselineData.Sheets['POR'];
                }
                
                // 检查PRC工作表是否存在
                let sheetPRC = null;
                if (fileTestData.SheetNames.includes('PRC')) {
                    sheetPRC = fileTestData.Sheets['PRC'];
                }
                
                // 检查MEM工作表是否存在
                let sheetMEM = null;
                if (fileTestData.SheetNames.includes('MEM')) {
                    sheetMEM = fileTestData.Sheets['MEM'];
                }
                
                // 检查HD工作表是否存在
                let sheetHD = null;
                if (fileTestData.SheetNames.includes('HD')) {
                    sheetHD = fileTestData.Sheets['HD'];
                }
                
                const sheetBaseline = fileBaselineData.Sheets['Tech Spec'];
                const sheetTest = fileTestData.Sheets['OBJECT-ELEMENT'];
                
                // 1. 遍历测试表的OBJECT-ELEMENT工作表,从D6开始横向读取产品,直到遇到#EOF
                const productList = [];
                let col = 'D';
                let colIndex = 4; // D列对应索引4
                
                console.log('开始遍历测试表OBJECT-ELEMENT,从D6开始收集产品列表...');
                
                while (true) {
                    const cellAddr = `${col}6`;
                    const cellValue = sheetTest[cellAddr] ? String(sheetTest[cellAddr].v).trim() : '';
                    
                    console.log(`检查单元格${cellAddr}: "${cellValue}"`);
                    
                    // 检查是否遇到#EOF
                    if (cellValue === '#EOF' || !cellValue) {
                        console.log(`在${cellAddr}遇到#EOF或空值,停止遍历`);
                        break;
                    }
                    
                    // 从产品名称中提取Part Number (格式: [PN]描述)
                    const pnMatch = cellValue.match(/\[([^\]]+)\]/);
                    const partNumber = pnMatch ? pnMatch[1].trim() : '';
                    
                    if (partNumber) {
                        console.log(`列${col}: 找到产品 Part Number="${partNumber}", 完整名称="${cellValue}"`);
                        productList.push({
                            partNumber: partNumber,
                            productName: cellValue,
                            column: col,
                            colIndex: colIndex
                        });
                    } else {
                        console.log(`列${col}: 未能从"${cellValue}"中提取Part Number`);
                    }
                    
                    // 移动到下一列
                    colIndex++;
                    if (colIndex <= 26) {
                        col = String.fromCharCode(64 + colIndex); // A=65, B=66...Z=90
                    } else {
                        // 处理AA, AB等列
                        const firstChar = String.fromCharCode(64 + Math.floor((colIndex - 1) / 26));
                        const secondChar = String.fromCharCode(64 + ((colIndex - 1) % 26) + 1);
                        col = firstChar + secondChar;
                    }
                    
                    // 防止无限循环
                    if (colIndex > 100) {
                        console.log('超过最大列数,停止遍历');
                        break;
                    }
                }
                
                console.log(`共找到${productList.length}个产品需要检验`);
                
                if (productList.length === 0) {
                    throw new Error('测试表中未找到任何产品(从D6开始,格式应为[PN]描述)');
                }
                
                // 2. 对每个产品进行技术规格检验
                let allProductResults = [];
                
                productList.forEach((productInfo, index) => {
                    console.log(`\n====== 检验第${index + 1}个产品: ${productInfo.partNumber} ======`);
                    
                    // 1. 提取产品名称 (基准表始终使用B1/C1)
                    const b1 = sheetBaseline['B1'] ? sheetBaseline['B1'].v : '';
                    const c1 = sheetBaseline['C1'] ? sheetBaseline['C1'].v : '';
                    let baselineProductName = '';
                    
                    if (String(b1).trim() === 'Product Name') {
                        baselineProductName = String(c1).trim();
                    } else if (String(c1).trim() === 'Product Name') {
                        baselineProductName = String(b1).trim();
                    }
                    
                    // 2. 提取基准规格数据(基准表始终使用C列作为值列)
                    const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
                    const baselineSpecs = extractBaselineSpecsForColumn(sheetBaseline, valueColumn);
                    
                    // 3. 如果有Color属性且有POR工作表,从POR读取Color基准值
                    if (sheetPOR && baselineSpecs['Color']) {
                        const porRow = findMatchingRowInPOR(sheetPOR, productInfo.partNumber);
                        if (porRow) {
                            const mCell = sheetPOR[`M${porRow.row}`];
                            if (mCell) {
                                baselineSpecs['Color'] = {
                                    value: String(mCell.v || '').trim(),
                                    cell: `POR M${porRow.row}`
                                };
                            }
                        }
                    }
                    
                    // 4. 提取测试规格数据 (从对应列读取)
                    const testSpecs = extractTestSpecsForColumn(sheetTest, productInfo.column);
                    
                    // 5. 提取Camera数据
                    const cameraSpecs = extractCameraSpecs(sheetCAM);
                    
                    // 6. 提取Wireless数据
                    const wirelessSpecs = extractWirelessSpecs(sheetWS);
                    
                    // 7. 进行匹配对比                   
                    const matchResults = matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetPOR, sheetPRC, sheetMEM, sheetHD, fileTestData, productInfo);

                    allProductResults.push({
                        partNumber: productInfo.partNumber,
                        productName: productInfo.productName,
                        column: productInfo.column,
                        baselineProductName: baselineProductName,
                        matchResults: matchResults
                    });
                });
                
                // 显示所有产品的检验结果
                displayTechResultsMultiple(allProductResults);
                
            } catch (error) {
                showError(`技术规格匹配过程出错: ${error.message}`);
                console.error('技术规格匹配错误:', error);
            }
        }

        function extractProductName(sheet) {
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            if (String(b1).trim() === 'Product Name') {
                return String(c1).trim();
            } else if (String(c1).trim() === 'Product Name') {
                return String(b1).trim();
            } else {
                throw new Error('未找到产品名称，请检查B1和C1单元格');
            }
        }

        // 从测试表中获取Part Number
        function getTestPartNumber(sheet) {
            // 检查OBJECT-ELEMENT表的B6单元格（假设Part Number在这里）
            // 或者从第6行开始查找"PRC"类型对应的值
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                // 如果找到PRC类型，返回其值作为Part Number
                if (typeName === 'PRC') {
                    return typeValue;
                }
                
                row++;
            }
            
            return null;
        }

        // 在基准表POR中查找匹配的Part Number行
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('在POR表中查找Part Number:', testPartNumber);
            
            // 从B2开始向下查找，直到B列为空
            let row = 2;
            while (true) {
                const bCell = `E${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // 如果B列为空，停止查找
                if (!partNumber) {
                    console.log(`行${row}: B列为空，停止查找`);
                    break;
                }
                
                console.log(`行${row}: Part Number = "${partNumber}"`);
                
                // 如果找到匹配的Part Number
                if (partNumber === testPartNumber) {
                    console.log(`找到匹配的行: ${row}`);
                    
                    // 获取该行的相关数据
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('匹配行数据:', rowData);
                    return rowData;
                }
                
                row++;
                
                // 防止无限循环，最多查找100行
                if (row > 100) {
                    console.log('超过最大查找行数，停止查找');
                    break;
                }
            }
            
            console.log('未找到匹配的Part Number');
            return null;
        }

        function extractBaselineSpecs(sheet) {
            const specs = {};
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            // 确定值列（B列还是C列）
            const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
            
            console.log('开始提取基准规格，值列为:', valueColumn);
            
            // 从第2行开始读取规格，直到遇到#EOF或者超出合理范围
            let row = 2;
            const maxRows = 100; // 防止无限循环，设置最大行数
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${valueColumn}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`行${row}: 属性="${attrName}", 值="${attrValue}"`);
                
                // 检查是否遇到#EOF标记
                if (attrName === '#EOF') {
                    console.log('遇到#EOF标记，停止读取');
                    break;
                }
                
                // 只添加techSpecMapping中定义的属性
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`添加规格: ${attrName} = "${attrValue}" (映射到: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`跳过未映射的属性: ${attrName}`);
                }
                // 如果属性名为空，继续读取下一行（跳过空行）
                
                row++;
            }
            
            console.log('基准规格提取完成，总共提取到:', Object.keys(specs).length, '个规格');
            console.log('规格列表:', Object.keys(specs));
            
            return specs;
        }

        function extractTestSpecs(sheet) {
            const specs = {};
            
            // 从第6行开始读取，直到遇到#EOF
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                specs[typeName] = {
                    value: typeValue,
                    cell: valueCell
                };
                
                row++;
            }
            
            return specs;
        }

        // 从指定列提取测试规格数据
        function extractTestSpecsForColumn(sheet, column) {
            const specs = {};
            
            console.log(`开始从列${column}提取测试规格`);
            
            // 从第7行开始读取(第6行是产品名称),直到遇到#EOF
            let row = 7;
            
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`; // 改为始终从C列读取值,而不是从指定列读取
                const markerCell = `${column}${row}`; // 用指定列来判断是否有标记
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                const markerValue = sheet[markerCell] ? String(sheet[markerCell].v).trim() : '';
                
                console.log(`行${row}: 类型="${typeName}", 值="${typeValue}", 标记列${column}="${markerValue}"`);
                
                if (typeName === '#EOF' || !typeName) {
                    console.log('遇到#EOF或空值,停止读取');
                    break;
                }
                
                // 只有当指定列有标记(如X)时,才收集这一行的数据
                if (markerValue) {
                    specs[typeName] = {
                        value: typeValue,
                        cell: valueCell, // 实际值在C列
                        markerCell: markerCell // 标记在指定列
                    };
                    console.log(`收集规格: ${typeName} = "${typeValue}" (标记列${markerCell}="${markerValue}")`);
                }
                
                row++;
                
                // 防止无限循环
                if (row > 1000) {
                    console.log('超过最大行数,停止读取');
                    break;
                }
            }
            
            console.log(`列${column}测试规格提取完成,总共提取到:`, Object.keys(specs).length, '个规格');
            
            return specs;
        }
        function extractCameraSpecs(sheet) {
            const cameraSpecs = {};
            
            if (!sheet) {
                return cameraSpecs; // 返回空对象如果没有CAM工作表
            }
            
            // 检查G2到G10的位置来查找Front和Back camera
            for (let row = 2; row <= 10; row++) {
                const gCell = `G${row}`;
                const bCell = `E${row}`;
                
                const gValue = sheet[gCell] ? String(sheet[gCell].v).trim().toLowerCase() : '';
                const bValue = sheet[bCell] ? String(sheet[bCell].v).trim() : '';
                
                if (gValue === 'front') {
                    cameraSpecs['Front Camera'] = {
                        value: bValue,
                        cell: bCell
                    };
                } else if (gValue === 'back') {
                    cameraSpecs['Back Camera'] = {
                        value: bValue,
                        cell: bCell
                    };
                    // 也添加Back别名支持
                    cameraSpecs['Back'] = {
                        value: bValue,
                        cell: bCell
                    };
                }
            }
            
            return cameraSpecs;
        }

        function extractWirelessSpecs(sheet) {
            const wirelessSpecs = {};
            
            if (!sheet) {
                return wirelessSpecs; // 返回空对象如果没有WS工作表
            }
            
            // 检查R2到R10的位置来查找WLAN和PAN
            for (let row = 2; row <= 10; row++) {
                const rCell = `R${row}`;
                const eCell = `E${row}`;
                const lCell = `L${row}`;
                
                const rValue = sheet[rCell] ? String(sheet[rCell].v).trim().toUpperCase() : '';
                const eValue = sheet[eCell] ? String(sheet[eCell].v).trim() : '';
                const lValue = sheet[lCell] ? String(sheet[lCell].v).trim() : '';
                
                if (rValue === 'WLAN') {
                    wirelessSpecs['Wireless'] = {
                        value: eValue,
                        cell: eCell
                    };
                } else if (rValue === 'PAN') {
                    wirelessSpecs['Bluetooth'] = {
                        value: lValue,
                        cell: lCell
                    };
                }
            }
            
            return wirelessSpecs;
        }

       function matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetPOR, sheetPRC, sheetMEM, sheetHD, testWorkbook, productInfo) {
            const results = [];
            
            // 遍历基准规格
            Object.keys(baselineSpecs).forEach(attrName => {
                const baselineSpec = baselineSpecs[attrName];
                const abbreviation = techSpecMapping[attrName];
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // 跳过What's in the box，因为会在最后处理
                if (attrName === 'What\'s in the box') {
                    return;
                }
                
                // 处理Camera特殊情况 - 从CAM工作表而不是OBJECT-ELEMENT中读取
                if ((attrName === 'Front Camera' || attrName === 'Back Camera' || attrName === 'Back') && cameraSpecs) {
                    if (cameraSpecs[attrName]) {
                        testSpec = cameraSpecs[attrName];
                        isMatched = true;
                        // 对Camera进行特殊检验，同时传递OBJECT-ELEMENT中的CAM值用于MBG检查
                        const objectElementCamValue = testSpecs['CAM'] ? testSpecs['CAM'].value : null;
                        checkResult = checkCamera(baselineSpec.value, testSpec.value, objectElementCamValue);
                    } else {
                        checkResult = { isValid: false, message: '未在CAM工作表中找到对应的Camera数据' };
                    }
                // 处理Bluetooth和Wireless特殊情况 - 从WS工作表而不是OBJECT-ELEMENT中读取
                } else if ((attrName === 'Bluetooth' || attrName === 'Wireless') && wirelessSpecs) {
                    if (wirelessSpecs[attrName]) {
                        testSpec = wirelessSpecs[attrName];
                        isMatched = true;
                        // 对Bluetooth使用专门的检验函数，对Wireless使用专门的检验函数
                        if (attrName === 'Bluetooth') {
                            // 传递OBJECT-ELEMENT中的WS值用于MBG检查
                            const objectElementWsValue = testSpecs['WS'] ? testSpecs['WS'].value : null;
                            checkResult = checkBluetooth(baselineSpec.value, testSpec.value, objectElementWsValue);
                        } else {
                            checkResult = checkWireless(baselineSpec.value, testSpec.value);
                        }
                    } else {
                        checkResult = { isValid: false, message: '未在WS工作表中找到对应的Bluetooth/Wireless数据' };
                    }
                // 处理Color特殊情况 - 从POR的M2和PP的T2比较
                } else if (attrName === 'Color' || attrName.includes('Color')) {
                    if (sheetPP) {
                        checkResult = checkColor(baselineSpec.value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : '未找到',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: '未找到PP工作表，无法进行Color检验' };
                    }
                } else if (abbreviation && testSpecs[abbreviation]) {
                    testSpec = testSpecs[abbreviation];
                    isMatched = true;
                    
                    // 对Weight、Dimension和Processor进行特殊检验
                    if (attrName === 'Weight' || attrName.includes('Weight')) {
                        if (sheetPP) {
                            checkResult = checkWeight(baselineSpec.value, sheetPP);
                        } else {
                            checkResult = { isValid: false, message: '未找到PP工作表，无法进行重量检验' };
                        }
                    } else if (attrName === 'Dimension' || attrName.includes('Dimension')) {
                        if (sheetPP) {
                            checkResult = checkDimension(baselineSpec.value, sheetPP);
                        } else {
                            checkResult = { isValid: false, message: '未找到PP工作表，无法进行尺寸检验' };
                        }
                    } else if (attrName === 'Processor' || attrName.includes('Processor')) {
                        if (sheetPRC) {
                            checkResult = checkProcessor(baselineSpec.value, sheetPRC);
                            // 标记为已匹配，因为我们有专门的PRC工作表检验
                            isMatched = true;
                            testSpec = {
                                value: testSpec.value, // 使用OBJECT-ELEMENT中PRC的值
                                cell: testSpec.cell
                            };
                        } else {
                            checkResult = { isValid: false, message: '未找到PRC工作表，无法进行处理器检验' };
                        }
                    } else if (attrName === 'OS' || attrName.includes('OS')) {
                        checkResult = checkOS(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Display' || attrName.includes('Display')) {
                        checkResult = checkDisplay(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Storage' || attrName.includes('Storage')) {
                        if (sheetHD) {
                            checkResult = checkStorage(baselineSpec.value, testSpec.value, sheetHD);
                        } else {
                            checkResult = { isValid: false, message: '未找到HD工作表，无法进行存储检验' };
                        }
                    } else if (attrName === 'Memory' || attrName.includes('Memory')) {
                        if (sheetMEM) {
                            checkResult = checkMemory(baselineSpec.value, testSpec.value, sheetMEM);
                        } else {
                            checkResult = { isValid: false, message: '未找到MEM工作表，无法进行内存检验' };
                        }
                    } else if (attrName === 'Graphics' || attrName.includes('Graphics')) {
                        checkResult = checkGraphics(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Battery Life' || attrName.includes('Battery Life')) {
                        // 获取测试文件的TI工作表
                        if (testWorkbook && testWorkbook.Sheets && testWorkbook.Sheets['TI']) {
                            const testSheetTI = testWorkbook.Sheets['TI'];
                            checkResult = checkBatteryLife(baselineSpec.value, testSheetTI);
                            
                            // 更新testSpec以显示E2和F2的值
                            if (checkResult.isValid) {
                                testSpec = {
                                    value: `E2: ${checkResult.e2Value || '未找到'} | F2: ${checkResult.f2Value || '未找到'}`,
                                    cell: 'TI E2, F2'
                                };
                                isMatched = checkResult.isMatch;
                            } else {
                                isMatched = false;
                            }
                        } else {
                            checkResult = { isValid: false, message: '未找到TI工作表，无法进行Battery Life检验' };
                            isMatched = false;
                        }
                    } else if (attrName === 'Port' || attrName.includes('Port')) {
                        checkResult = checkPort(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Audio' || attrName.includes('Audio')) {
                        checkResult = checkAudio(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Fingerprint Reader' || attrName.includes('Fingerprint Reader')) {
                        checkResult = checkFingerprintReader(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'Warranty' || attrName.includes('Warranty')) {
                        checkResult = checkWarranty(baselineSpec.value, testSpec.value);
                    } else if (attrName === 'IMG' || attrName.includes('IMG')) {
                        checkResult = checkIMG(baselineSpec.value, testSpec.value, sheetPOR, productInfo.partNumber);
                    }
                }
                
                results.push({
                    attribute: attrName,
                    abbreviation: abbreviation || '未映射',
                    baselineValue: baselineSpec.value,
                    baselineCell: baselineSpec.cell,
                    testValue: testSpec ? testSpec.value : '未找到',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            });
            
        // 最后添加What's in the box的处理（即使不在基准规格中）
        if (sheetPOR) {
            const n2Cell = sheetPOR['N2'];
            if (n2Cell) {
                const n2Value = String(n2Cell.v || '').trim();
                const abbreviation = 'MM';
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // 获取测试值（可能为空）
                const testValue = testSpecs[abbreviation] ? testSpecs[abbreviation].value : null;
                
                // 无论测试值是否存在，都调用检验函数
                checkResult = checkWhatsInTheBox(n2Value, testValue);
                
                // 根据检验结果判断是否匹配
                if (checkResult.isValid && checkResult.isMatch) {
                    isMatched = true;
                    testSpec = testSpecs[abbreviation] || null;
                } else {
                    isMatched = false;
                    testSpec = testSpecs[abbreviation] || null;
                }
                
                results.push({
                    attribute: 'What\'s in the box',
                    abbreviation: 'MM',
                    baselineValue: n2Value,
                    baselineCell: 'POR N2',
                    testValue: testSpec ? testSpec.value : '未找到',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            }
                    
                // 添加Color的处理（从POR M2读取基准值，与PP T2比较）
                const m2Cell = sheetPOR['M2'];
                if (m2Cell && sheetPP) {
                    const m2Value = String(m2Cell.v || '').trim();
                    
                    let testSpec = null;
                    let isMatched = false;
                    let checkResult = null;
                    
                    if (m2Value) {
                        checkResult = checkColor(m2Value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : '未找到',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: 'POR M2单元格为空' };
                    }
                    
                    results.push({
                        attribute: 'Color',
                        abbreviation: 'COLOR',
                        baselineValue: m2Value,
                        baselineCell: 'POR M2',
                        testValue: testSpec ? testSpec.value : '未找到',
                        testCell: testSpec ? testSpec.cell : '-',
                        isMatched: isMatched,
                        checkResult: checkResult
                    });
                }
            }
            
            // 添加IMG的处理（从POR表读取Color作为基准值）
            let imgBaselineValue = '(未找到)';
            let imgBaselineCell = '-';

            // 从POR表中读取Color作为基准值
            if (sheetPOR) {
                // 查找当前产品的Part Number对应的行
                let porRow = null;
                let row = 2;
                
                while (row <= 1000) {
                    const bCell = `B${row}`;
                    const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        break;
                    }
                    
                    if (partNumber === productInfo.partNumber) {
                        porRow = row;
                        break;
                    }
                    
                    row++;
                }
                
                // 如果找到对应行，读取M列的Color值
                if (porRow) {
                    const mCell = `M${porRow}`;
                    const colorValue = sheetPOR[mCell] ? String(sheetPOR[mCell].v).trim() : '';
                    if (colorValue) {
                        imgBaselineValue = colorValue;
                        imgBaselineCell = mCell;
                    }
                }
            }

            // 检查IMG
            if (testSpecs['IMG']) {
                const testSpec = testSpecs['IMG'];
                const checkResult = checkIMG(imgBaselineValue, testSpec.value);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: testSpec.value,
                    testCell: testSpec.cell,
                    isMatched: checkResult.isValid && checkResult.isMatch,
                    checkResult: checkResult
                });
            } else {
                // 如果测试表中没有IMG，添加失败记录
                const checkResult = checkIMG(imgBaselineValue, null);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: '未找到',
                    testCell: '-',
                    isMatched: false,
                    checkResult: checkResult
                });
            }
            
            return results;
        }

        function checkWeight(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准重量数据' };
                }

                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }

                // 从基准值中提取重量数字（单位：克）
                const weightMatch = String(baselineValue).match(/(\d+(?:\.\d+)?)g/i);
                if (!weightMatch) {
                    return { isValid: false, message: '基准值格式无效，需要包含"g"单位' };
                }

                // ✅ 转换为千克，并保留 6 位小数（避免浮点误差）
                const weightInGrams = parseFloat(weightMatch[1]);
                const weightInKg = parseFloat((weightInGrams / 1000).toFixed(6));

                // 从PP工作表的Z2单元格读取重量数据
                const z2Cell = sheetPP['Z2'];
                if (!z2Cell) {
                    return { isValid: false, message: 'PP工作表中未找到Z2单元格' };
                }

                const testWeightValue = z2Cell.v;
                let testWeightInKg;

                if (typeof testWeightValue === 'number') {
                    testWeightInKg = parseFloat(testWeightValue.toFixed(6));
                } else {
                    const testWeightMatch = String(testWeightValue).match(/(\d+(?:\.\d+)?)/);
                    if (!testWeightMatch) {
                        return { isValid: false, message: 'PP工作表Z2单元格格式无效' };
                    }
                    testWeightInKg = parseFloat(parseFloat(testWeightMatch[1]).toFixed(6));
                }

                // ✅ 计算差值（保留6位）
                const difference = parseFloat(Math.abs(weightInKg - testWeightInKg).toFixed(6));
                const tolerance = 0;
                const isMatch = difference <= tolerance;

                // ✅ 返回结果，全部格式化为6位小数
                return {
                    isValid: true,
                    isMatch: isMatch,
                    convertedValue: weightInKg.toFixed(6),
                    testValue: testWeightInKg.toFixed(6),
                    message: isMatch
                        ? '重量匹配'
                        : `重量不匹配 (差值: ${difference.toFixed(6)}kg)`,
                    ppCells: `Z2: ${testWeightInKg.toFixed(6)}kg`
                };

            } catch (error) {
                return { isValid: false, message: `重量检验错误: ${error.message}` };
            }
        }


        // 尺寸检验函数
        function checkDimension(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准尺寸数据' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }
                
                const baselineStr = String(baselineValue);
                console.log('原始基准尺寸值:', baselineStr);
                
                // 检查是否包含Open和Closed状态
                const hasOpenClosed = /open|closed/i.test(baselineStr);
                
                if (hasOpenClosed) {
                    return checkFoldableDimension(baselineStr, sheetPP);
                } else {
                    return checkStandardDimension(baselineStr, sheetPP);
                }
                
            } catch (error) {
                return { isValid: false, message: `尺寸检验错误: ${error.message}` };
            }
        }
        
        // 标准设备尺寸检验函数
        function checkStandardDimension(baselineStr, sheetPP) {
            console.log('处理标准设备尺寸');
            
            // 找到"mm"的位置，只处理mm之前的内容
            let mmIndex = baselineStr.toLowerCase().indexOf('mm');
            let processString = mmIndex !== -1 ? baselineStr.substring(0, mmIndex + 2) : baselineStr;
            console.log('处理的字符串（到mm为止）:', processString);
            
            // 从处理后的字符串中提取尺寸（格式：数字 x 数字 x 数字 mm）
            const dimensionMatch = processString.match(/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)\s*mm/i);
            if (!dimensionMatch) {
                // 如果没找到完整格式，尝试只匹配数字部分
                const numbersMatch = processString.match(/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)/i);
                if (!numbersMatch) {
                    return { isValid: false, message: `基准值格式无效，需要"长 x 宽 x 厚"格式。当前值: "${processString}"` };
                }
                // 使用数字匹配的结果
                var [, length, width, thickness] = numbersMatch;
                console.log('使用数字匹配模式');
            } else {
                var [, length, width, thickness] = dimensionMatch;
                console.log('使用完整mm匹配模式');
            }
            
            const lengthValue = parseFloat(length);
            const widthValue = parseFloat(width);
            const thicknessValue = parseFloat(thickness);
            
            console.log(`提取的尺寸: 长=${lengthValue}, 宽=${widthValue}, 厚=${thicknessValue}`);
            
            // 从PP工作表读取N2, AD2, I2的值
            const n2Cell = sheetPP['N2'];
            const ad2Cell = sheetPP['AD2'];
            const i2Cell = sheetPP['I2'];
            
            let ppValues = {
                length: n2Cell ? (typeof n2Cell.v === 'number' ? n2Cell.v : parseFloat(String(n2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null,
                width: ad2Cell ? (typeof ad2Cell.v === 'number' ? ad2Cell.v : parseFloat(String(ad2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null,
                thickness: i2Cell ? (typeof i2Cell.v === 'number' ? i2Cell.v : parseFloat(String(i2Cell.v).match(/(\d+(?:\.\d+)?)/)?.[1] || 0)) : null
            };
            
            console.log('PP工作表的值:', ppValues);
            
            // 检查匹配情况
            const lengthMatch = ppValues.length !== null && Math.abs(lengthValue - ppValues.length) <= 0.1;
            const widthMatch = ppValues.width !== null && Math.abs(widthValue - ppValues.width) <= 0.1;
            const thicknessMatch = ppValues.thickness !== null && Math.abs(thicknessValue - ppValues.thickness) <= 0.1;
            
            const allMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (allMatch) {
                message = `尺寸全部匹配 (提取自: "${processString}")`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`长度(${lengthValue} vs ${ppValues.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`宽度(${widthValue} vs ${ppValues.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`厚度(${thicknessValue} vs ${ppValues.thickness || 'N/A'})`);
                message = `尺寸不匹配: ${mismatches.join(', ')} (提取自: "${processString}")`;
            }
            
            return {
                isValid: true,
                isMatch: allMatch,
                convertedValues: {
                    length: lengthValue,
                    width: widthValue,
                    thickness: thicknessValue
                },
                ppValues: ppValues,
                message: message,
                processedString: processString,
                originalString: baselineStr,
                ppCells: `N2: ${ppValues.length || 'N/A'}mm, AD2: ${ppValues.width || 'N/A'}mm, I2: ${ppValues.thickness || 'N/A'}mm`
            };
        }
        
        // 折叠设备尺寸检验函数
        function checkFoldableDimension(baselineStr, sheetPP) {
            console.log('处理折叠设备尺寸');
            
            // 解析Open和Closed尺寸
            const openPattern = /open\s*([\d\s.×x]+mm)/i;
            const closedPattern = /closed\s*([\d\s.×x]+mm)/i;
            
            const openMatch = baselineStr.match(openPattern);
            const closedMatch = baselineStr.match(closedPattern);
            
            console.log('Open匹配:', openMatch);
            console.log('Closed匹配:', closedMatch);
            
            // 查找PP工作表中的Open PP和Close PP数据
            const ppData = findPPData(sheetPP);
            console.log('找到的PP数据:', ppData);
            
            let results = [];
            let allMatch = true;
            
            // 检查Open尺寸
            if (openMatch && ppData.open) {
                const openDimensions = extractDimensionsFromString(openMatch[1]);
                if (openDimensions) {
                    const openResult = compareDimensions(openDimensions, ppData.open, 'Open');
                    results.push(openResult);
                    if (!openResult.isMatch) allMatch = false;
                } else {
                    results.push({ state: 'Open', isMatch: false, message: 'Open尺寸格式无效' });
                    allMatch = false;
                }
            } else if (openMatch && !ppData.open) {
                results.push({ state: 'Open', isMatch: false, message: '未找到Open PP数据' });
                allMatch = false;
            } else if (!openMatch && ppData.open) {
                results.push({ state: 'Open', isMatch: false, message: '基准值中未找到Open尺寸' });
                allMatch = false;
            }
            
            // 检查Closed尺寸
            if (closedMatch && ppData.closed) {
                const closedDimensions = extractDimensionsFromString(closedMatch[1]);
                if (closedDimensions) {
                    const closedResult = compareDimensions(closedDimensions, ppData.closed, 'Closed');
                    results.push(closedResult);
                    if (!closedResult.isMatch) allMatch = false;
                } else {
                    results.push({ state: 'Closed', isMatch: false, message: 'Closed尺寸格式无效' });
                    allMatch = false;
                }
            } else if (closedMatch && !ppData.closed) {
                results.push({ state: 'Closed', isMatch: false, message: '未找到Close PP数据' });
                allMatch = false;
            } else if (!closedMatch && ppData.closed) {
                results.push({ state: 'Closed', isMatch: false, message: '基准值中未找到Closed尺寸' });
                allMatch = false;
            }
            
            // 生成汇总消息
            let message = '';
            if (allMatch && results.length > 0) {
                message = `折叠设备尺寸全部匹配: ${results.map(r => r.state).join(', ')}状态`;
            } else {
                const failures = results.filter(r => !r.isMatch);
                if (failures.length > 0) {
                    message = `折叠设备尺寸不匹配: ${failures.map(r => `${r.state}(${r.message})`).join(', ')}`;
                } else {
                    message = '未找到有效的折叠设备尺寸数据';
                }
            }
            
            return {
                isValid: true,
                isMatch: allMatch,
                message: message,
                originalString: baselineStr,
                results: results,
                ppData: ppData
            };
        }
        
        // 在PP工作表中查找Open PP和Close PP数据
        function findPPData(sheetPP) {
            const ppData = { open: null, closed: null };
            
            // 扫描PP工作表，查找包含"Open PP"和"Close PP"的行
            for (let row = 1; row <= 50; row++) {
                for (let col of ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']) {
                    const cell = sheetPP[`${col}${row}`];
                    if (cell && cell.v) {
                        const cellValue = String(cell.v).toLowerCase();
                        
                        if (cellValue.includes('open pp') || cellValue.includes('open')) {
                            // 找到Open PP，读取同行的N, AD, I列数据
                            ppData.open = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        } else if (cellValue.includes('close pp') || cellValue.includes('closed') || cellValue.includes('close')) {
                            // 找到Close PP，读取同行的N, AD, I列数据
                            ppData.closed = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        }
                    }
                }
            }
            
            return ppData;
        }
        
        // 从字符串中提取数字
        function extractNumber(value) {
            if (typeof value === 'number') return value;
            const match = String(value).match(/(\d+(?:\.\d+)?)/);
            return match ? parseFloat(match[1]) : null;
        }
        
        // 从尺寸字符串中提取长宽高
        function extractDimensionsFromString(dimensionStr) {
            const match = dimensionStr.match(/(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)\s*[x×]\s*(\d+(?:\.\d+)?)/i);
            if (match) {
                return {
                    length: parseFloat(match[1]),
                    width: parseFloat(match[2]),
                    thickness: parseFloat(match[3])
                };
            }
            return null;
        }
        
        // 比较基准尺寸和PP数据
        function compareDimensions(baseline, ppData, state) {
            const tolerance = 0.1;
            
            const lengthMatch = ppData.length !== null && Math.abs(baseline.length - ppData.length) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const thicknessMatch = ppData.thickness !== null && Math.abs(baseline.thickness - ppData.thickness) <= tolerance;
            
            const isMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (isMatch) {
                message = `${state}状态尺寸匹配`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`长度(${baseline.length} vs ${ppData.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`宽度(${baseline.width} vs ${ppData.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`厚度(${baseline.thickness} vs ${ppData.thickness || 'N/A'})`);
                message = `${state}状态不匹配: ${mismatches.join(', ')}`;
            }
            
            return {
                state: state,
                isMatch: isMatch,
                message: message,
                baseline: baseline,
                ppData: ppData,
                ppCells: `行${ppData.row}: N${ppData.row}=${ppData.length || 'N/A'}mm, AD${ppData.row}=${ppData.width || 'N/A'}mm, I${ppData.row}=${ppData.thickness || 'N/A'}mm`
            };
        }

        // 处理器检验函数
        function checkProcessor(baselineValue, sheetPRC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准处理器数据' };
                }
                
                if (!sheetPRC) {
                    return { isValid: false, message: '未找到PRC工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Processor值:', baselineStr);
                
                // 需要检查的字段配置
                const checkFields = [
                    { name: 'PROCMFR (制造商)', cellKey: 'W1', cellValue: 'W2' },
                    { name: 'SERIES (系列)', cellKey: 'F1', cellValue: 'F2' },
                    { name: 'SKU', cellKey: 'E1', cellValue: 'E2' },
                    { name: 'PROCCLKSPD (时钟速度)', cellKey: 'T1', cellValue: 'T2' },
                    { name: 'BRANDCODEF (品牌代码)', cellKey: 'K1', cellValue: 'K2' }
                ];
                
                let allChecks = [];
                let allPassed = true;
                
                // 检查每个字段
                checkFields.forEach(field => {
                    const keyCell = sheetPRC[field.cellKey];
                    const valueCell = sheetPRC[field.cellValue];
                    
                    const keyText = keyCell ? String(keyCell.v || '').trim() : '';
                    const valueText = valueCell ? String(valueCell.v || '').trim() : '';
                    
                    console.log(`检查${field.name}: ${field.cellKey}="${keyText}", ${field.cellValue}="${valueText}"`);
                    
                    let checkResult = {
                        fieldName: field.name,
                        keyCell: field.cellKey,
                        valueCell: field.cellValue,
                        keyText: keyText,
                        valueText: valueText,
                        isValid: false,
                        found: false
                    };
                    
                    // 检查key是否匹配预期值
                    let expectedKey = '';
                    if (field.cellKey === 'W1') expectedKey = 'PROCMFR';
                    else if (field.cellKey === 'F1') expectedKey = 'SERIES';
                    else if (field.cellKey === 'E1') expectedKey = 'SKU';
                    else if (field.cellKey === 'T1') expectedKey = 'PROCCLKSPD';
                    else if (field.cellKey === 'K1') expectedKey = 'BRANDCODEF';
                    
                    if (keyText.toUpperCase() !== expectedKey) {
                        checkResult.isValid = false;
                        checkResult.message = `${field.cellKey}单元格应为"${expectedKey}"，实际为"${keyText}"`;
                        allPassed = false;
                    } else if (!valueText) {
                        checkResult.isValid = false;
                        checkResult.message = `${field.cellValue}单元格为空`;
                        allPassed = false;
                    } else {
                        // 特殊处理BRANDCODEF字段：K2的值必须是MBG
                        if (field.cellKey === 'K1') {
                            const found = valueText.toUpperCase() === 'MBG';
                            checkResult.isValid = true;
                            checkResult.found = found;
                            
                            if (found) {
                                checkResult.message = `✓ "${valueText}" 匹配要求的"MBG"`;
                            } else {
                                checkResult.message = `✗ "${valueText}" 不匹配要求的"MBG"`;
                                allPassed = false;
                            }
                        } else {
                            // 其他字段：使用严格匹配而不是包含匹配
                            let found = false;
                            
                            // 将基准值按空格、逗号、斜杠等分隔符分割成tokens
                            const baselineTokens = baselineStr.split(/[\s,/\-_()]+/).map(t => t.trim().toLowerCase()).filter(t => t.length > 0);
                            const testValueLower = valueText.toLowerCase().trim();
                            
                            console.log(`处理器字段检验 - 字段: ${field.name}, 测试值: "${valueText}", 基准tokens: [${baselineTokens.join(', ')}]`);
                            
                            // 检查测试值是否与任何基准token完全匹配
                            found = baselineTokens.includes(testValueLower);
                            
                            // 如果严格匹配失败，对于SKU字段不进行数字标准化匹配，其他数字字段才进行
                            if (!found && /^\d+(\.\d+)?$/.test(valueText) && field.cellKey !== 'E1') {
                                // 提取所有数字（包括小数）
                                const baselineNumbers = baselineStr.match(/\d+\.?\d*/g) || [];
                                const testNumbers = valueText.match(/\d+\.?\d*/g) || [];
                                
                                // 标准化数字格式（去除末尾的0）
                                const normalizeNumber = (num) => {
                                    const parsed = parseFloat(num);
                                    return parsed.toString();
                                };
                                
                                const normalizedBaselineNumbers = baselineNumbers.map(normalizeNumber);
                                const normalizedTestNumbers = testNumbers.map(normalizeNumber);
                                
                                // 检查测试值中的数字是否在基准值的数字中存在
                                found = normalizedTestNumbers.length > 0 && 
                                       normalizedTestNumbers.every(testNum => 
                                           normalizedBaselineNumbers.includes(testNum)
                                       );
                                
                                console.log(`数字标准化匹配 - 基准数字: [${normalizedBaselineNumbers.join(', ')}], 测试数字: [${normalizedTestNumbers.join(', ')}], 匹配结果: ${found}`);
                            }
                            
                            checkResult.isValid = true;
                            checkResult.found = found;
                            
                            if (found) {
                                checkResult.message = `✓ "${valueText}" 严格匹配基准Processor中的token`;
                            } else {
                                checkResult.message = `✗ "${valueText}" 在基准Processor中未找到严格匹配 (基准tokens: [${baselineTokens.join(', ')}])`;
                                allPassed = false;
                            }
                        }
                    }
                    
                    allChecks.push(checkResult);
                });
                
                // 生成详细报告
                let detailMessage = allChecks.map(check => 
                    `${check.fieldName}(${check.keyCell}→${check.valueCell}): ${check.message}`
                ).join('; ');
                
                let summaryMessage = '';
                if (allPassed) {
                    summaryMessage = '处理器检验通过：所有字段都在基准值中找到匹配';
                } else {
                    const failedCount = allChecks.filter(check => !check.found || !check.isValid).length;
                    summaryMessage = `处理器检验失败：${failedCount}/${checkFields.length}个字段未通过检验`;
                }
                
                return {
                    isValid: true,
                    isMatch: allPassed,
                    message: summaryMessage,
                    detailMessage: detailMessage,
                    checkResults: allChecks,
                    baselineValue: baselineStr
                };
                
            } catch (error) {
                return { isValid: false, message: `处理器检验错误: ${error.message}` };
            }
        }

        // OS检验函数
        function checkOS(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少OS数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 清理和标准化OS token的函数
                function cleanAndNormalizeOSToken(token) {
                    // 移除特殊符号（™、®等）和标点、括号
                    let cleaned = token.replace(/[^\w.]/g, '');
                    
                    // 如果清理后为空，返回null
                    if (!cleaned) {
                        return null;
                    }
                    
                    // 忽略的额外说明词汇
                    const ignoreWords = ['or', 'later', 'above', 'plus', 'and'];
                    if (ignoreWords.includes(cleaned.toLowerCase())) {
                        return null; // 返回null表示忽略此token
                    }
                    
                    return cleaned.toLowerCase();
                }
                
                // 3. 处理baseline和test tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 清理和标准化tokens
                const baselineTokens = rawBaselineTokens
                    .map(cleanAndNormalizeOSToken)
                    .filter(token => token !== null);
                    
                const testTokens = rawTestTokens
                    .map(cleanAndNormalizeOSToken)
                    .filter(token => token !== null);
                
                // 4. 检查测试表的每个token是否都能在基准表中找到
                const missingTokens = [];
                const foundTokens = [];
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                rawTestTokens.forEach(originalToken => {
                    const cleanedToken = cleanAndNormalizeOSToken(originalToken);
                    
                    // 如果是被忽略的token，跳过
                    if (cleanedToken === null) {
                        return;
                    }
                    
                    // 检查是否在baseline中找到
                    const found = baselineTokens.includes(cleanedToken);
                    
                    if (found) {
                        foundTokens.push(cleanedToken);
                        originalFoundTokens.push(originalToken);
                    } else {
                        missingTokens.push(cleanedToken);
                        originalMissingTokens.push(originalToken);
                    }
                });
                
                const allTokensFound = missingTokens.length === 0;
                const isMatch = hasMBG && allTokensFound;
                
                let message = '';
                if (isMatch) {
                    message = 'OS信息完全匹配：包含MBG且所有关键token都找到';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else if (!allTokensFound) {
                    message = `OS token不匹配，未找到: ${originalMissingTokens.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineTokens,
                    cleanedTestTokens: testTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `OS检验错误: ${error.message}` };
            }
        }

        // Display检验函数
        function checkDisplay(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Display数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false
                    };
                }
                
                // 2. 提取Display关键参数的函数
                function extractDisplaySpecs(text) {
                    const specs = {};
                    
                    console.log('提取Display规格，原始文本:', text);
                    
                    // 提取屏幕大小 (英寸)
                    const sizeMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:inch|inches|")/i);
                    if (sizeMatch) {
                        specs.size = parseFloat(sizeMatch[1]);
                        console.log('找到屏幕大小:', specs.size + ' inch');
                    }
                    
                    // 提取分辨率 (宽x高)
                    const resolutionMatch = text.match(/(\d+)\s*[x×]\s*(\d+)/i);
                    if (resolutionMatch) {
                        specs.resolutionWidth = parseInt(resolutionMatch[1]);
                        specs.resolutionHeight = parseInt(resolutionMatch[2]);
                        // 将分辨率存储为排序后的数组，用于宽松比较
                        specs.resolutionValues = [specs.resolutionWidth, specs.resolutionHeight].sort((a, b) => a - b);
                        specs.resolution = `${specs.resolutionWidth}x${specs.resolutionHeight}`;
                        console.log('找到分辨率:', specs.resolution, '排序值:', specs.resolutionValues);
                    }
                    
                    // 提取刷新率 (Hz)
                    const refreshRateMatch = text.match(/(\d+(?:\.\d+)?)\s*Hz/i);
                    if (refreshRateMatch) {
                        specs.refreshRate = parseFloat(refreshRateMatch[1]);
                        console.log('找到刷新率:', specs.refreshRate + 'Hz');
                    }
                    
                    console.log('提取的Display规格:', specs);
                    return specs;
                }
                
                // 3. 提取基准和测试规格
                const baselineSpecs = extractDisplaySpecs(baselineStr);
                const testSpecs = extractDisplaySpecs(testStr);
                
                // 4. 比较关键参数
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // 检查屏幕大小
                if (baselineSpecs.size !== undefined) {
                    if (testSpecs.size !== undefined) {
                        if (baselineSpecs.size === testSpecs.size) {
                            foundSpecs.push(`${baselineSpecs.size}"`);
                        } else {
                            mismatchedSpecs.push(`屏幕大小不匹配: 基准${baselineSpecs.size}" vs 测试${testSpecs.size}"`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.size}"`);
                    }
                }
                
                // 检查分辨率 - 使用宽松比较（排序后的数值集合）
                if (baselineSpecs.resolutionValues !== undefined) {
                    if (testSpecs.resolutionValues !== undefined) {
                        // 比较排序后的分辨率数值
                        const baselineSorted = baselineSpecs.resolutionValues;
                        const testSorted = testSpecs.resolutionValues;
                        const resolutionMatch = baselineSorted.length === testSorted.length && 
                                              baselineSorted.every((val, index) => val === testSorted[index]);
                        
                        if (resolutionMatch) {
                            foundSpecs.push(`${baselineSpecs.resolutionValues.join('x')}像素`);
                        } else {
                            mismatchedSpecs.push(`分辨率不匹配: 基准${baselineSpecs.resolution} vs 测试${testSpecs.resolution}`);
                        }
                    } else {
                        missingSpecs.push(baselineSpecs.resolution);
                    }
                }
                
                // 检查刷新率
                if (baselineSpecs.refreshRate !== undefined) {
                    if (testSpecs.refreshRate !== undefined) {
                        if (baselineSpecs.refreshRate === testSpecs.refreshRate) {
                            foundSpecs.push(`${baselineSpecs.refreshRate}Hz`);
                        } else {
                            mismatchedSpecs.push(`刷新率不匹配: 基准${baselineSpecs.refreshRate}Hz vs 测试${testSpecs.refreshRate}Hz`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.refreshRate}Hz`);
                    }
                }
                
                // 5. 判断是否匹配
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Display关键参数完全匹配: ${foundSpecs.join(', ')} (已忽略其他显示特性)`;
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`未找到: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Display参数检验失败: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG
                };
                
            } catch (error) {
                return { isValid: false, message: `Display检验错误: ${error.message}` };
            }
        }

        // Storage检验函数
        function checkStorage(baselineValue, testValue, sheetHD) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Storage数据' };
                }
                
                if (!sheetHD) {
                    return { isValid: false, message: '未找到HD工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Storage值:', baselineStr);
                
                // 从基准值中提取数字（存储容量）
                const baselineMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!baselineMatch) {
                    return { isValid: false, message: `基准Storage值格式无效，无法提取数字。当前值: "${baselineStr}"` };
                }
                
                const baselineCapacity = parseFloat(baselineMatch[1]);
                console.log('基准存储容量:', baselineCapacity);
                
                // 检查HD工作表的M1、M2、E1、E2、N1、N2单元格
                const m1Cell = sheetHD['M1'];
                const m2Cell = sheetHD['M2'];
                const e1Cell = sheetHD['E1'];
                const e2Cell = sheetHD['E2'];
                const n1Cell = sheetHD['N1'];
                const n2Cell = sheetHD['N2'];
                
                const m1Value = m1Cell ? String(m1Cell.v || '').trim() : '';
                const m2Value = m2Cell ? m2Cell.v : '';
                const e1Value = e1Cell ? String(e1Cell.v || '').trim() : '';
                const e2Value = e2Cell ? String(e2Cell.v || '').trim() : '';
                const n1Value = n1Cell ? String(n1Cell.v || '').trim() : '';
                const n2Value = n2Cell ? String(n2Cell.v || '').trim() : '';
                
                console.log('HD工作表 M1:', m1Value);
                console.log('HD工作表 M2:', m2Value);
                console.log('HD工作表 E1:', e1Value);
                console.log('HD工作表 E2:', e2Value);
                console.log('HD工作表 N1:', n1Value);
                console.log('HD工作表 N2:', n2Value);
                
                // 检查M1是否为HDDCAPACITY
                if (m1Value.toUpperCase() !== 'HDDCAPACITY') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD工作表M1应为"HDDCAPACITY"，实际为"${m1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // 检查E1是否为BRANDCODEF
                if (e1Value.toUpperCase() !== 'BRANDCODEF') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD工作表E1应为"BRANDCODEF"，实际为"${e1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // 检查E2是否为MBG
                if (e2Value.toUpperCase() !== 'MBG') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD工作表E2应为"MBG"，实际为"${e2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // 检查N1是否为HDDCAPACITYUNITS
                if (n1Value.toUpperCase() !== 'HDDCAPACITYUNITS') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD工作表N1应为"HDDCAPACITYUNITS"，实际为"${n1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // 检查N2是否为GB
                if (n2Value.toUpperCase() !== 'GB') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD工作表N2应为"GB"，实际为"${n2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                    };
                }
                
                // 检查M2是否为数字
                let testCapacity;
                if (typeof m2Value === 'number') {
                    testCapacity = m2Value;
                } else {
                    const m2Match = String(m2Value).match(/(\d+(?:\.\d+)?)/);
                    if (!m2Match) {
                        return {
                            isValid: true,
                            isMatch: false,
                            message: `HD工作表M2应为数字，实际为"${m2Value}"`,
                            baselineCapacity: baselineCapacity,
                            testCapacity: null,
                            hdCells: `M1: ${m1Value}, M2: ${m2Value}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                        };
                    }
                    testCapacity = parseFloat(m2Match[1]);
                }
                
                console.log('测试存储容量:', testCapacity);
                
                // 使用数字标准化进行比较
                const baselineNormalized = parseFloat(baselineCapacity.toString());
                const testNormalized = parseFloat(testCapacity.toString());
                
                const isMatch = baselineNormalized === testNormalized;
                
                let message = '';
                if (isMatch) {
                    message = `存储容量匹配: ${baselineCapacity} = ${testCapacity}，BRANDCODEF验证通过，单位为GB`;
                } else {
                    message = `存储容量不匹配: 基准值${baselineCapacity} ≠ 测试值${testCapacity}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineCapacity: baselineCapacity,
                    testCapacity: testCapacity,
                    hdCells: `M1: ${m1Value}, M2: ${testCapacity}, E1: ${e1Value}, E2: ${e2Value}, N1: ${n1Value}, N2: ${n2Value}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Storage检验错误: ${error.message}` };
            }
        }

        // Memory检验函数
        function checkMemory(baselineValue, testValue, sheetMEM) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Memory数据' };
                }
                
                if (!sheetMEM) {
                    return { isValid: false, message: '未找到MEM工作表' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('基准Memory值:', baselineStr);
                
                // 从基准值中提取数字（内存容量）
                const baselineMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!baselineMatch) {
                    return { isValid: false, message: `基准Memory值格式无效，无法提取数字。当前值: "${baselineStr}"` };
                }
                
                const baselineCapacity = parseFloat(baselineMatch[1]);
                console.log('基准内存容量:', baselineCapacity);
                
                // 检查MEM工作表的G1和G2单元格
                const g1Cell = sheetMEM['G1'];
                const g2Cell = sheetMEM['G2'];
                
                const g1Value = g1Cell ? String(g1Cell.v || '').trim() : '';
                const g2Value = g2Cell ? g2Cell.v : '';
                
                // 检查MEM工作表的E1和E2单元格（BRANDCODEF）
                const e1Cell = sheetMEM['E1'];
                const e2Cell = sheetMEM['E2'];
                
                const e1Value = e1Cell ? String(e1Cell.v || '').trim() : '';
                const e2Value = e2Cell ? String(e2Cell.v || '').trim() : '';
                
                console.log('MEM工作表 G1:', g1Value);
                console.log('MEM工作表 G2:', g2Value);
                console.log('MEM工作表 E1:', e1Value);
                console.log('MEM工作表 E2:', e2Value);
                
                // 检查G1是否为MEMCAPACITY
                if (g1Value.toUpperCase() !== 'MEMCAPACITY') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEM工作表G1应为"MEMCAPACITY"，实际为"${g1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // 检查E1是否为BRANDCODEF
                if (e1Value.toUpperCase() !== 'BRANDCODEF') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEM工作表E1应为"BRANDCODEF"，实际为"${e1Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // 检查E2是否为MBG
                if (e2Value.toUpperCase() !== 'MBG') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MEM工作表E2应为"MBG"，实际为"${e2Value}"`,
                        baselineCapacity: baselineCapacity,
                        testCapacity: null,
                        g1Value: g1Value,
                        g2Value: g2Value,
                        e1Value: e1Value,
                        e2Value: e2Value,
                        memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                    };
                }
                
                // 检查G2是否为数字
                let testCapacity;
                if (typeof g2Value === 'number') {
                    testCapacity = g2Value;
                } else {
                    const g2Match = String(g2Value).match(/(\d+(?:\.\d+)?)/);
                    if (!g2Match) {
                        return {
                            isValid: true,
                            isMatch: false,
                            message: `MEM工作表G2应为数字，实际为"${g2Value}"`,
                            baselineCapacity: baselineCapacity,
                            testCapacity: null,
                            g1Value: g1Value,
                            g2Value: g2Value,
                            e1Value: e1Value,
                            e2Value: e2Value,
                            memCells: `G1: ${g1Value}, G2: ${g2Value}, E1: ${e1Value}, E2: ${e2Value}`
                        };
                    }
                    testCapacity = parseFloat(g2Match[1]);
                }
                
                console.log('测试内存容量:', testCapacity);
                
                // 使用数字标准化进行比较
                const baselineNormalized = parseFloat(baselineCapacity.toString());
                const testNormalized = parseFloat(testCapacity.toString());
                
                const isMatch = baselineNormalized === testNormalized;
                
                let message = '';
                if (isMatch) {
                    message = `内存容量匹配: ${baselineCapacity} = ${testCapacity}，BRANDCODEF验证通过`;
                } else {
                    message = `内存容量不匹配: 基准值${baselineCapacity} ≠ 测试值${testCapacity}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineCapacity: baselineCapacity,
                    testCapacity: testCapacity,
                    g1Value: g1Value,
                    g2Value: g2Value,
                    e1Value: e1Value,
                    e2Value: e2Value,
                    memCells: `G1: ${g1Value}, G2: ${testCapacity}, E1: ${e1Value}, E2: ${e2Value}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Memory检验错误: ${error.message}` };
            }
        }

        // Graphics检验函数
        function checkGraphics(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Graphics数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 清理和标准化Graphics token的函数
                function cleanAndNormalizeGraphicsToken(token) {
                    // 统一转换为大写
                    let cleaned = token.toUpperCase();
                    
                    // 将 - 替换为空格
                    cleaned = cleaned.replace(/-/g, ' ');
                    
                    // 移除多余的空格并分割
                    return cleaned.trim().split(/\s+/).filter(t => t.length > 0);
                }
                
                // 3. 处理baseline和test tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 清理和标准化tokens
                const baselineTokens = [];
                rawBaselineTokens.forEach(token => {
                    const cleaned = cleanAndNormalizeGraphicsToken(token);
                    baselineTokens.push(...cleaned);
                });
                
                const testTokens = [];
                rawTestTokens.forEach(token => {
                    if (token.toUpperCase() !== 'MBG') {
                        const cleaned = cleanAndNormalizeGraphicsToken(token);
                        testTokens.push(...cleaned);
                    }
                });
                
                // 4. 检查基准表的每个token是否都能在测试表中找到
                const missingTokens = [];
                const foundTokens = [];
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                baselineTokens.forEach(baselineToken => {
                    const found = testTokens.includes(baselineToken);
                    
                    if (found) {
                        foundTokens.push(baselineToken);
                        // 找到原始token
                        const originalToken = rawBaselineTokens.find(token => 
                            cleanAndNormalizeGraphicsToken(token).includes(baselineToken)
                        );
                        if (originalToken && !originalFoundTokens.includes(originalToken)) {
                            originalFoundTokens.push(originalToken);
                        }
                    } else {
                        missingTokens.push(baselineToken);
                        // 找到原始token
                        const originalToken = rawBaselineTokens.find(token => 
                            cleanAndNormalizeGraphicsToken(token).includes(baselineToken)
                        );
                        if (originalToken && !originalMissingTokens.includes(originalToken)) {
                            originalMissingTokens.push(originalToken);
                        }
                    }
                });
                
                const allTokensFound = missingTokens.length === 0;
                const isMatch = hasMBG && allTokensFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Graphics信息完全匹配：包含MBG且所有基准token都找到';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else if (!allTokensFound) {
                    message = `Graphics token不匹配，未找到: ${missingTokens.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineTokens,
                    cleanedTestTokens: testTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `Graphics检验错误: ${error.message}` };
            }
        }

        // Wireless检验函数
        function checkWireless(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Wireless数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 提取数字的函数
                function extractNumbers(text) {
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. 提取字母token的函数（替换标点为空格后提取）
                function extractLetterTokens(text) {
                    // 移除MBG和数字，将所有标点符号替换为空格
                    let cleanText = text.replace(/MBG/gi, '').replace(/\d+(?:\.\d+)?/g, '');
                    // 将所有标点符号替换为空格
                    cleanText = cleanText.replace(/[^\w\s]/g, ' ');
                    // 按空格分割，提取包含字母的部分
                    const tokens = cleanText.split(/\s+/).map(token => token.trim()).filter(token => token.length > 0 && /[a-zA-Z]/.test(token));
                    return tokens.map(token => token.toLowerCase());
                }
                
                // 4. 处理baseline和test数据
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 提取数字
                const baselineNumbers = extractNumbers(baselineStr);
                const testNumbers = extractNumbers(testStr.replace(/MBG/gi, ''));
                
                // 提取字母tokens
                const baselineLetterTokens = extractLetterTokens(baselineStr);
                const testLetterTokens = extractLetterTokens(testStr);
                
                // 5. 检查字母匹配 - 测试中的字母能在基准中找到
                const missingLetters = [];
                const foundLetters = [];
                
                testLetterTokens.forEach(testLetter => {
                    if (baselineLetterTokens.includes(testLetter)) {
                        foundLetters.push(testLetter);
                    } else {
                        missingLetters.push(testLetter);
                    }
                });
                
                const allLettersFound = missingLetters.length === 0;
                
                // 6. 检查数字匹配 - 测试中的数字能在基准中找到
                const missingNumbers = [];
                const foundNumbers = [];
                
                testNumbers.forEach(testNum => {
                    if (baselineNumbers.includes(testNum)) {
                        foundNumbers.push(testNum);
                    } else {
                        missingNumbers.push(testNum);
                    }
                });
                
                const allNumbersFound = missingNumbers.length === 0;
                const isMatch = hasMBG && allNumbersFound && allLettersFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Wireless信息完全匹配：包含MBG、数字匹配且字母token都找到';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else if (!allNumbersFound) {
                    message = `Wireless数字不匹配，测试中未在基准中找到: ${missingNumbers.join(', ')}`;
                } else if (!allLettersFound) {
                    message = `Wireless字母不匹配，测试中未在基准中找到: ${missingLetters.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: [...foundNumbers.map(n => n.toString()), ...foundLetters],
                    missingTokens: [...missingNumbers.map(n => n.toString()), ...missingLetters],
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: {
                        numbers: baselineNumbers,
                        letterTokens: baselineLetterTokens
                    },
                    cleanedTestTokens: {
                        numbers: testNumbers,
                        letterTokens: testLetterTokens
                    }
                };
                
            } catch (error) {
                return { isValid: false, message: `Wireless检验错误: ${error.message}` };
            }
        }

        // Bluetooth检验函数
        function checkBluetooth(baselineValue, testValue, objectElementWsValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Bluetooth数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查OBJECT-ELEMENT的C列是否包含 "MBG"（如果提供了该参数）
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementWsValue !== null) {
                    // 从OBJECT-ELEMENT的C列检查MBG
                    const objectElementStr = String(objectElementWsValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT C列';
                } else {
                    // 降级到从WS工作表的值检查MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'WS工作表';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`,
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. 智能提取数字token的函数 - 避免协议名称中的数字
                function extractBluetoothNumbers(text) {
                    // 已知的Bluetooth协议名称，包含数字但不应该被提取
                    const protocolPatterns = [
                        /A2DP/gi,
                        /HFP/gi,
                        /HSP/gi,
                        /AVRCP/gi,
                        /HID/gi,
                        /OPP/gi,
                        /FTP/gi,
                        /BIP/gi,
                        /PBAP/gi,
                        /MAP/gi,
                        /DUN/gi,
                        /PAN/gi,
                        /SPP/gi
                    ];
                    
                    // 首先移除已知的协议名称，防止提取其中的数字
                    let cleanedText = text;
                    protocolPatterns.forEach(pattern => {
                        cleanedText = cleanedText.replace(pattern, ' ');
                    });
                    
                    console.log('Bluetooth原始文本:', text);
                    console.log('移除协议后的文本:', cleanedText);
                    
                    // 从清理后的文本中提取独立的数字（前后必须是空格、标点或字符串开始/结束）
                    const numbers = [];
                    const numberMatches = cleanedText.match(/(?:^|[\s,;])(\d+(?:\.\d+)?)(?=[\s,;]|$)/g);
                    
                    if (numberMatches) {
                        numberMatches.forEach(match => {
                            const num = parseFloat(match.trim());
                            if (!isNaN(num)) {
                                numbers.push(num);
                            }
                        });
                    }
                    
                    console.log('提取的数字:', numbers);
                    return numbers;
                }
                
                // 3. 处理baseline和test tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 提取数字tokens（避免协议名称中的数字）
                const baselineNumbers = extractBluetoothNumbers(baselineStr);
                const testNumbers = extractBluetoothNumbers(testStr.replace(/MBG/gi, '')); // 移除MBG后提取数字
                
                // 4. 检查数字是否相同（顺序无关）
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);
                
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);
                
                const isMatch = hasMBG && numbersMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Bluetooth信息完全匹配：包含MBG且版本号相同 (MBG检查来源: ${mbgCheckSource}, 已排除协议名称中的数字)`;
                } else if (!hasMBG) {
                    message = `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`;
                } else if (!numbersMatch) {
                    message = `Bluetooth版本号不匹配，基准: [${sortedBaselineNumbers.join(', ')}], 测试: [${sortedTestNumbers.join(', ')}] (MBG检查来源: ${mbgCheckSource})`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: isMatch ? sortedTestNumbers.map(n => n.toString()) : [],
                    missingTokens: !numbersMatch ? sortedBaselineNumbers.filter(n => !sortedTestNumbers.includes(n)).map(n => n.toString()) : [],
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineNumbers,
                    cleanedTestTokens: testNumbers,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Bluetooth检验错误: ${error.message}` };
            }
        }

        // Camera检验函数
        function checkCamera(baselineValue, testValue, objectElementCamValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Camera数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查OBJECT-ELEMENT的C列是否包含 "MBG"（如果提供了该参数）
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementCamValue !== null) {
                    // 从OBJECT-ELEMENT的C列检查MBG
                    const objectElementStr = String(objectElementCamValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT C列';
                } else {
                    // 降级到从CAM工作表的值检查MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'CAM工作表';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`,
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. 提取关键Camera参数的函数
                function extractCameraSpecs(text) {
                    const specs = {};
                    
                    console.log('提取Camera规格，原始文本:', text);
                    
                    // 提取像素 (MP)
                    const mpMatch = text.match(/(\d+)\s*MP/i);
                    if (mpMatch) {
                        specs.pixels = parseInt(mpMatch[1]);
                        console.log('找到像素:', specs.pixels + 'MP');
                    }
                    
                    // 提取光圈 (f/数字)
                    const apertureMatch = text.match(/f\/(\d+\.\d+)/i);
                    if (apertureMatch) {
                        specs.aperture = parseFloat(apertureMatch[1]);
                        console.log('找到光圈:', 'f/' + specs.aperture);
                    }
                    
                    // 提取像素尺寸 (数字µm 或 数字μm)
                    const pixelSizeMatch = text.match(/(\d+(?:\.\d+)?)[µμ]m/i);
                    if (pixelSizeMatch) {
                        specs.pixelSize = parseFloat(pixelSizeMatch[1]);
                        console.log('找到像素尺寸:', specs.pixelSize + 'µm');
                    }
                    
                    console.log('提取的规格:', specs);
                    return specs;
                }
                
                // 3. 提取基准和测试规格
                const baselineSpecs = extractCameraSpecs(baselineStr);
                const testSpecs = extractCameraSpecs(testStr);
                
                // 4. 比较关键参数
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // 检查像素
                if (baselineSpecs.pixels !== undefined) {
                    if (testSpecs.pixels !== undefined) {
                        if (baselineSpecs.pixels === testSpecs.pixels) {
                            foundSpecs.push(`${baselineSpecs.pixels}MP`);
                        } else {
                            mismatchedSpecs.push(`像素不匹配: 基准${baselineSpecs.pixels}MP vs 测试${testSpecs.pixels}MP`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixels}MP`);
                    }
                }
                
                // 检查光圈
                if (baselineSpecs.aperture !== undefined) {
                    if (testSpecs.aperture !== undefined) {
                        if (baselineSpecs.aperture === testSpecs.aperture) {
                            foundSpecs.push(`f/${baselineSpecs.aperture}`);
                        } else {
                            mismatchedSpecs.push(`光圈不匹配: 基准f/${baselineSpecs.aperture} vs 测试f/${testSpecs.aperture}`);
                        }
                    } else {
                        missingSpecs.push(`f/${baselineSpecs.aperture}`);
                    }
                }
                
                // 检查像素尺寸
                if (baselineSpecs.pixelSize !== undefined) {
                    if (testSpecs.pixelSize !== undefined) {
                        if (baselineSpecs.pixelSize === testSpecs.pixelSize) {
                            foundSpecs.push(`${baselineSpecs.pixelSize}µm`);
                        } else {
                            mismatchedSpecs.push(`像素尺寸不匹配: 基准${baselineSpecs.pixelSize}µm vs 测试${testSpecs.pixelSize}µm`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixelSize}µm`);
                    }
                }
                
                // 5. 判断是否匹配
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Camera关键参数完全匹配: ${foundSpecs.join(', ')} (MBG检查来源: ${mbgCheckSource}, 已忽略焦距、传感器等其他参数)`;
                } else if (!hasMBG) {
                    message = `测试表内容必须包含"MBG" (检查来源: ${mbgCheckSource})`;
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`未找到: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Camera参数检验失败: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Camera检验错误: ${error.message}` };
            }
        }

        // Battery Life检验函数（修改版）
        function checkBatteryLife(baselineValue, testSheetTI) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少Battery Life基准数据' };
                }
                
                if (!testSheetTI) {
                    return { isValid: false, message: '测试文件中未找到TI工作表' };
                }
                
                // 获取TI表的E2和F2单元格
                const e2Cell = testSheetTI['E2'];
                const f2Cell = testSheetTI['F2'];
                
                if (!e2Cell) {
                    return { isValid: false, message: '测试文件TI表中未找到E2单元格数据' };
                }
                
                if (!f2Cell) {
                    return { isValid: false, message: '测试文件TI表中未找到F2单元格数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const e2Value = String(e2Cell.v || '').trim();
                const f2Value = String(f2Cell.v || '').trim();
                
                console.log('Battery Life检验:');
                console.log('基准值:', baselineStr);
                console.log('TI-E2值:', e2Value);
                console.log('TI-F2值:', f2Value);
                
                // 1. 检查F2单元格是否包含"MBG"
                const hasMBG = f2Value.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'TI表F2单元格内容必须包含"MBG"',
                        baselineValue: baselineStr,
                        e2Value: e2Value,
                        f2Value: f2Value,
                        hasMBG: false,
                        baselineNumbers: [],
                        testNumbers: []
                    };
                }
                
                // 2. 提取所有数字的函数
                function extractNumericTokens(text) {
                    // 使用正则表达式提取所有数字（包括小数）
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. 从基准值和E2单元格中提取数字
                const baselineNumbers = extractNumericTokens(baselineStr);
                const testNumbers = extractNumericTokens(e2Value);
                
                console.log('基准值数字:', baselineNumbers);
                console.log('E2单元格数字:', testNumbers);
                
                // 4. 检查数字是否相同或部分匹配
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);

                // 检查严格匹配
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);

                // 检查宽松匹配（测试值是基准的子集）
                const subsetMatch = sortedTestNumbers.every(num => sortedBaselineNumbers.includes(num));

                // 5. 判断整体匹配状态
                let isMatch = hasMBG && (numbersMatch || subsetMatch);
                let message = '';

                if (isMatch && numbersMatch) {
                    message = `Battery Life完全匹配：F2包含MBG，E2数字 [${sortedTestNumbers.join(', ')}] 与基准值 [${sortedBaselineNumbers.join(', ')}] 相同`;
                } else if (isMatch && subsetMatch) {
                    message = `Battery Life部分匹配：F2包含MBG，E2数字 [${sortedTestNumbers.join(', ')}] 是基准值 [${sortedBaselineNumbers.join(', ')}] 的子集`;
                } else if (!hasMBG) {
                    message = 'TI表F2单元格内容必须包含"MBG"';
                } else {
                    message = `Battery Life数字不匹配，基准值数字: [${sortedBaselineNumbers.join(', ')}], E2数字: [${sortedTestNumbers.join(', ')}]`;
                }

                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineStr,
                    e2Value: e2Value,
                    f2Value: f2Value,
                    hasMBG: hasMBG,
                    baselineNumbers: sortedBaselineNumbers,
                    testNumbers: sortedTestNumbers,
                    numbersMatch: numbersMatch
                };
                
            } catch (error) {
                return { isValid: false, message: `Battery Life检验错误: ${error.message}` };
            }
        }

        // Fingerprint Reader检验函数
        function checkFingerprintReader(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Fingerprint Reader数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 定义位置映射关系（忽略大小写）
                const positionMapping = {
                    'on-screen': 'display',
                    'back': 'back',
                    'side': 'side'
                };
                
                // 3. 检查基准中的位置token
                function extractPositionTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundPositions = [];
                    
                    Object.keys(positionMapping).forEach(baselinePos => {
                        if (cleanText.includes(baselinePos)) {
                            foundPositions.push(baselinePos);
                        }
                    });
                    
                    return foundPositions;
                }
                
                // 4. 检查测试中的位置token
                function extractTestPositionTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundPositions = [];
                    
                    Object.values(positionMapping).forEach(testPos => {
                        if (cleanText.includes(testPos)) {
                            foundPositions.push(testPos);
                        }
                    });
                    
                    return foundPositions;
                }
                
                // 5. 处理baseline和test数据
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 提取位置tokens
                const baselinePositions = extractPositionTokens(baselineStr);
                const testPositions = extractTestPositionTokens(testStr.replace(/MBG/gi, '')); // 移除MBG后提取
                
                // 6. 检查匹配规则
                const missingMappings = [];
                const extraPositions = [];
                const foundMappings = [];
                
                // 检查基准中的位置是否在测试中有对应的映射
                baselinePositions.forEach(baselinePos => {
                    const expectedTestPos = positionMapping[baselinePos];
                    if (testPositions.includes(expectedTestPos)) {
                        foundMappings.push(`${baselinePos} -> ${expectedTestPos}`);
                    } else {
                        missingMappings.push(`${baselinePos} -> ${expectedTestPos}`);
                    }
                });
                
                // 检查测试中是否有基准没有要求的位置
                const allExpectedTestPositions = baselinePositions.map(pos => positionMapping[pos]);
                testPositions.forEach(testPos => {
                    if (!allExpectedTestPositions.includes(testPos)) {
                        extraPositions.push(testPos);
                    }
                });
                
                const isMatch = hasMBG && missingMappings.length === 0 && extraPositions.length === 0;
                
                let message = '';
                if (isMatch) {
                    if (foundMappings.length > 0) {
                        message = `Fingerprint Reader信息完全匹配：包含MBG且位置映射正确 (${foundMappings.join(', ')})`;
                    } else {
                        message = 'Fingerprint Reader信息完全匹配：包含MBG且无位置要求';
                    }
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else {
                    const issues = [];
                    if (missingMappings.length > 0) {
                        issues.push(`缺少位置映射: ${missingMappings.join(', ')}`);
                    }
                    if (extraPositions.length > 0) {
                        issues.push(`多余的位置: ${extraPositions.join(', ')}`);
                    }
                    message = `Fingerprint Reader位置不匹配 - ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundMappings,
                    missingTokens: missingMappings,
                    extraTokens: extraPositions,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselinePositions,
                    cleanedTestTokens: testPositions
                };
                
            } catch (error) {
                return { isValid: false, message: `Fingerprint Reader检验错误: ${error.message}` };
            }
        }

        // Audio检验函数
        function checkAudio(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Audio数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 定义关键token（忽略大小写）
                const keyTokens = ['dual', 'dolby atmos'];
                
                // 3. 提取关键token的函数（忽略大小写）
                function extractKeyTokens(text) {
                    const cleanText = text.toLowerCase();
                    const foundTokens = [];
                    
                    keyTokens.forEach(token => {
                        if (cleanText.includes(token.toLowerCase())) {
                            foundTokens.push(token);
                        }
                    });
                    
                    return foundTokens;
                }
                
                // 4. 处理baseline和test数据
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 提取关键tokens
                const baselineKeyTokens = extractKeyTokens(baselineStr);
                const testKeyTokens = extractKeyTokens(testStr.replace(/MBG/gi, '')); // 移除MBG后提取
                
                // 5. 检查规则：如果基准有，测试一定要有；如果基准没有，测试就不能有
                const missingTokens = [];
                const extraTokens = [];
                const foundTokens = [];
                
                // 检查基准中的token是否在测试中存在
                baselineKeyTokens.forEach(baselineToken => {
                    if (testKeyTokens.includes(baselineToken)) {
                        foundTokens.push(baselineToken);
                    } else {
                        missingTokens.push(baselineToken);
                    }
                });
                
                // 检查测试中是否有基准没有的token
                testKeyTokens.forEach(testToken => {
                    if (!baselineKeyTokens.includes(testToken)) {
                        extraTokens.push(testToken);
                    }
                });
                
                const isMatch = hasMBG && missingTokens.length === 0 && extraTokens.length === 0;
                
                let message = '';
                if (isMatch) {
                    message = 'Audio信息完全匹配：包含MBG且关键token一致';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else {
                    const issues = [];
                    if (missingTokens.length > 0) {
                        issues.push(`缺少关键token: ${missingTokens.join(', ')}`);
                    }
                    if (extraTokens.length > 0) {
                        issues.push(`多余的关键token: ${extraTokens.join(', ')}`);
                    }
                    message = `Audio关键token不匹配 - ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundTokens,
                    missingTokens: missingTokens,
                    extraTokens: extraTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineKeyTokens,
                    cleanedTestTokens: testKeyTokens
                };
                
            } catch (error) {
                return { isValid: false, message: `Audio检验错误: ${error.message}` };
            }
        }

        // Warranty检验函数
        function checkWarranty(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Warranty数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 提取所有数字的函数
                function extractNumbers(text) {
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. 处理baseline和test数据
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // 提取数字
                const baselineNumbers = extractNumbers(baselineStr);
                const testNumbers = extractNumbers(testStr.replace(/MBG/gi, '')); // 移除MBG后提取数字
                
                // 4. 检查基准中的数字能在测试中找到
                const missingNumbers = [];
                const foundNumbers = [];
                
                baselineNumbers.forEach(baselineNum => {
                    if (testNumbers.includes(baselineNum)) {
                        foundNumbers.push(baselineNum);
                    } else {
                        missingNumbers.push(baselineNum);
                    }
                });
                
                const allNumbersFound = missingNumbers.length === 0;
                const isMatch = hasMBG && allNumbersFound;
                
                let message = '';
                if (isMatch) {
                    message = 'Warranty信息完全匹配：包含MBG且基准中所有数字都在测试中找到';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else if (!allNumbersFound) {
                    message = `Warranty数字不匹配，基准中未在测试中找到: ${missingNumbers.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens,
                    foundTokens: foundNumbers.map(n => n.toString()),
                    missingTokens: missingNumbers.map(n => n.toString()),
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineNumbers,
                    cleanedTestTokens: testNumbers
                };
                
            } catch (error) {
                return { isValid: false, message: `Warranty检验错误: ${error.message}` };
            }
        }

        // IMG检验函数
        function checkIMG(baselineColorValue, testValue) {
            try {
                console.log('IMG检验 - 基准颜色值:', baselineColorValue);
                console.log('IMG检验 - 测试值:', testValue);
                
                // 检查是否有基准颜色值
                if (!baselineColorValue || baselineColorValue === '(未找到)') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMG检验失败：未能从POR表中获取颜色信息',
                        baselineValue: baselineColorValue || '(未找到)',
                        testValue: testValue || '(空)'
                    };
                }
                
                // 检查测试值是否存在
                if (!testValue || String(testValue).trim() === '') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMG检验失败：测试表中未找到IMG值',
                        baselineValue: baselineColorValue,
                        testValue: '(空)'
                    };
                }
                
                const testStr = String(testValue).trim();
                
                // 规则1：检查是否以MBG结尾
                const endsWithMBG = /\bMBG\s*$/i.test(testStr);
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMG检验失败：测试值必须以"MBG"结尾',
                        baselineValue: baselineColorValue,
                        testValue: testStr,
                        endsWithMBG: false,
                        colorMatch: false
                    };
                }
                
                // 规则2：检查测试值是否包含基准颜色值
                // 标准化处理（不区分大小写）
                const normalizedTest = testStr.toLowerCase();
                const normalizedColor = baselineColorValue.toLowerCase();
                
                const colorMatch = normalizedTest.includes(normalizedColor);
                
                console.log('IMG检验 - 以MBG结尾:', endsWithMBG);
                console.log('IMG检验 - 颜色匹配:', colorMatch);
                
                // 两个条件都满足才通过
                const isMatch = endsWithMBG && colorMatch;
                
                let message = '';
                if (isMatch) {
                    message = `IMG检验通过：以MBG结尾且包含颜色 "${baselineColorValue}"`;
                } else if (!colorMatch) {
                    message = `IMG检验失败：测试值中未包含基准颜色 "${baselineColorValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineColorValue,
                    testValue: testStr,
                    endsWithMBG: endsWithMBG,
                    colorMatch: colorMatch
                };
                
            } catch (error) {
                return { 
                    isValid: false, 
                    message: `IMG检验错误: ${error.message}`,
                    baselineValue: baselineColorValue || '(未知)',
                    testValue: testValue || '(未知)'
                };
            }
        }

        // Port检验函数
        function checkPort(baselineValue, testValue) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: '缺少Port数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 处理基准值：将标点符号转换为空格
                const normalizedBaseline = baselineStr.replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
                
                // 3. 分离数字和非数字token的函数
                function separateTokens(text) {
                    const tokens = text.split(/\s+/).filter(token => token.length > 0);
                    const numbers = [];
                    const words = [];
                    
                    tokens.forEach(token => {
                        // 检查是否为数字
                        const numberMatch = token.match(/^\d+(?:\.\d+)?$/);
                        if (numberMatch) {
                            numbers.push(parseFloat(token));
                        } else {
                            // 如果token包含数字，提取数字部分
                            const numbersInToken = token.match(/\d+(?:\.\d+)?/g);
                            if (numbersInToken) {
                                numbersInToken.forEach(num => {
                                    numbers.push(parseFloat(num));
                                });
                            }
                            
                            // 提取非数字部分作为word
                            const wordPart = token.replace(/\d+(?:\.\d+)?/g, '').replace(/[^\w]/g, '');
                            if (wordPart) {
                                words.push(wordPart.toLowerCase());
                            }
                        }
                    });
                    
                    return { numbers, words, originalTokens: tokens };
                }
                
                // 4. 处理baseline和test tokens
                const baselineProcessed = separateTokens(normalizedBaseline);
                const testProcessed = separateTokens(testStr.replace(/MBG/gi, '').trim());
                
                // 5. 检查数字匹配
                const missingNumbers = [];
                const foundNumbers = [];
                
                testProcessed.numbers.forEach(testNum => {
                    const found = baselineProcessed.numbers.includes(testNum);
                    if (found) {
                        foundNumbers.push(testNum);
                    } else {
                        missingNumbers.push(testNum);
                    }
                });
                
                // 6. 检查单词匹配
                const missingWords = [];
                const foundWords = [];
                const rawTestTokens = testStr.split(/\s+/)
                    .filter(token => token.length > 0 && token.toUpperCase() !== 'MBG');
                
                testProcessed.words.forEach(testWord => {
                    const found = baselineProcessed.words.includes(testWord);
                    if (found) {
                        foundWords.push(testWord);
                    } else {
                        missingWords.push(testWord);
                    }
                });
                
                // 7. 计算匹配结果
                const allNumbersFound = missingNumbers.length === 0;
                const allWordsFound = missingWords.length === 0;
                const allTokensFound = allNumbersFound && allWordsFound;
                const isMatch = hasMBG && allTokensFound;
                
                // 8. 构造原始missing tokens用于显示
                const originalMissingTokens = [];
                const originalFoundTokens = [];
                
                rawTestTokens.forEach(originalToken => {
                    const tokenNumbers = originalToken.match(/\d+(?:\.\d+)?/g) || [];
                    const tokenWords = originalToken.replace(/\d+(?:\.\d+)?/g, '').replace(/[^\w]/g, '').toLowerCase();
                    
                    let tokenFound = true;
                    
                    // 检查token中的数字
                    tokenNumbers.forEach(numStr => {
                        const num = parseFloat(numStr);
                        if (!baselineProcessed.numbers.includes(num)) {
                            tokenFound = false;
                        }
                    });
                    
                    // 检查token中的单词
                    if (tokenWords && !baselineProcessed.words.includes(tokenWords)) {
                        tokenFound = false;
                    }
                    
                    if (tokenFound) {
                        originalFoundTokens.push(originalToken);
                    } else {
                        originalMissingTokens.push(originalToken);
                    }
                });
                
                let message = '';
                if (isMatch) {
                    message = 'Port信息完全匹配：包含MBG且测试中所有token都在基准中找到';
                } else if (!hasMBG) {
                    message = '测试表内容必须包含"MBG"';
                } else {
                    const missingParts = [];
                    if (missingNumbers.length > 0) {
                        missingParts.push(`数字: ${missingNumbers.join(', ')}`);
                    }
                    if (missingWords.length > 0) {
                        missingParts.push(`单词: ${missingWords.join(', ')}`);
                    }
                    message = `Port token不匹配，测试中未在基准中找到 ${missingParts.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: baselineProcessed.originalTokens,
                    testTokens: rawTestTokens,
                    foundTokens: originalFoundTokens,
                    missingTokens: originalMissingTokens,
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: {
                        numbers: baselineProcessed.numbers,
                        words: baselineProcessed.words
                    },
                    cleanedTestTokens: {
                        numbers: testProcessed.numbers,
                        words: testProcessed.words
                    },
                    normalizedBaseline: normalizedBaseline
                };
                
            } catch (error) {
                return { isValid: false, message: `Port检验错误: ${error.message}` };
            }
        }

        // Color检验函数
        function checkColor(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: '缺少基准Color数据' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: '未找到PP工作表' };
                }
                
                // 从PP工作表的T2单元格读取Color数据
                const t2Cell = sheetPP['T2'];
                if (!t2Cell) {
                    return { isValid: false, message: 'PP工作表中未找到T2单元格' };
                }
                
                const testColorValue = String(t2Cell.v || '').trim();
                const baselineColorValue = String(baselineValue).trim();
                
                // 清理和标准化颜色值的函数
                function normalizeColorValue(colorValue) {
                    // 移除PANTONE前缀（不区分大小写）
                    let cleaned = colorValue.replace(/^PANTONE\s+/i, '').trim();
                    
                    // 如果还有其他品牌前缀，也可以在这里添加
                    // 例如：cleaned = cleaned.replace(/^RAL\s+/i, '').trim();
                    
                    return cleaned;
                }
                
                // 标准化两个颜色值
                const normalizedBaseline = normalizeColorValue(baselineColorValue);
                const normalizedTest = normalizeColorValue(testColorValue);
                
                // 比较标准化后的Color值
                const isMatch = normalizedBaseline === normalizedTest;
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: isMatch ? 'Color匹配（已忽略PANTONE前缀）' : `Color不匹配 (基准: "${normalizedBaseline}", 测试: "${normalizedTest}")`,
                    baselineValue: baselineColorValue,
                    testValue: testColorValue,
                    normalizedBaseline: normalizedBaseline,
                    normalizedTest: normalizedTest,
                    ppCells: `T2: ${testColorValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Color检验错误: ${error.message}` };
            }
        }

        // What's in the box检验函数
        function checkWhatsInTheBox(baselineValue, testValue) {
            try {
                // 检查基准值是否存在
                if (!baselineValue) {
                    return { isValid: false, message: '缺少What\'s in the box基准数据' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = testValue ? String(testValue).trim() : '';
                
                console.log('What\'s in the box检验:');
                console.log('基准值:', baselineStr);
                console.log('测试值:', testStr || '(空)');
                
                // 【新增】特殊处理：如果基准值只包含"No"且没有逗号，测试值为空是合理的
                const baselineUpper = baselineStr.toUpperCase();
                const hasNoInBaseline = baselineUpper.includes('NO');
                const hasComma = baselineStr.includes(',');
                
                if (hasNoInBaseline && !hasComma && !testStr) {
                    // 基准值纯粹是"No xxx"，测试值为空 = 匹配成功
                    console.log('基准值要求无内容，测试值为空，判定为匹配成功');
                    return {
                        isValid: true,
                        isMatch: true,
                        message: '基准值要求无内容，测试值为空，匹配成功',
                        hasNoInBaseline: true,
                        noItemsPart: baselineStr,
                        positiveItemsPart: '',
                        noItemsViolation: false,
                        positiveItemsMatch: true,
                        hasMBG: false,
                        baselineValue: baselineStr,
                        testValue: testStr || '(空)'
                    };
                }
                
                // 对于其他情况，测试值不能为空
                if (!testValue) {
                    return { isValid: false, message: '缺少What\'s in the box测试数据' };
                }
                
                // 1. 首先检查测试表内容是否包含 "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: '测试表内容必须包含"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. 检查基准值是否包含"No"，如果包含则进行特殊处理
                let processedBaselineStr = baselineStr;
                let shouldCheckNoItems = false;
                let noItemsPart = '';
                let positiveItemsPart = '';
                
                if (hasNoInBaseline) {
                    console.log('基准值包含"No"，进行特殊处理');
                    
                    // 查找逗号分隔符
                    const commaIndex = baselineStr.indexOf(',');
                    if (commaIndex !== -1) {
                        // 分割为No部分和正面部分
                        noItemsPart = baselineStr.substring(0, commaIndex).trim();
                        positiveItemsPart = baselineStr.substring(commaIndex + 1).trim();
                        
                        console.log('No部分:', noItemsPart);
                        console.log('正面部分:', positiveItemsPart);
                        
                        // 使用正面部分进行比较
                        processedBaselineStr = positiveItemsPart;
                        shouldCheckNoItems = true;
                    } else {
                        // 没有逗号，整个都是No部分
                        noItemsPart = baselineStr;
                        positiveItemsPart = '';
                        processedBaselineStr = '';
                        shouldCheckNoItems = true;
                        
                        console.log('整个基准值都是No部分，无正面内容');
                    }
                }
                
                console.log('处理后的基准值:', processedBaselineStr);
                
                // 2.5. 提取和清理token的函数
                function extractAndCleanTokens(text, removeMBG = false) {
                    let cleanedText = text;
                    
                    // 如果需要，移除MBG
                    if (removeMBG) {
                        cleanedText = cleanedText.replace(/\bMBG\b/gi, '');
                    }
                    
                    // 需要忽略的常见连接词和介词
                    const stopWords = [
                        'and', 'or', 'with', 'without', 'the', 'a', 'an', 
                        'in', 'on', 'at', 'for', 'of', 'to', 'from',
                        '&', '+', ',', '-'
                    ];
                    
                    // 分割为tokens并清理
                    const tokens = cleanedText
                        .split(/\s+/)
                        .map(token => {
                            // 移除标点符号
                            const cleaned = token.replace(/[^\w]/g, '').trim();
                            return cleaned.toLowerCase();
                        })
                        .filter(token => token.length > 0)
                        .filter(token => !stopWords.includes(token)); // 过滤停用词
                    
                    console.log('原始文本:', text);
                    console.log('清理后的tokens:', tokens);
                    return tokens;
                }
                
                // 3. 如果需要检查No项目，验证测试值中不应包含No部分的关键词
                let noItemsViolation = false;
                let noItemsViolationDetails = '';
                
                if (shouldCheckNoItems && noItemsPart) {
                    // 提取No部分的关键词（排除"No"本身）
                    const noItemsTokens = extractAndCleanTokens(noItemsPart, false)
                        .filter(token => token.toLowerCase() !== 'no');
                    
                    console.log('No部分的关键词:', noItemsTokens);
                    
                    // 检查测试值中是否包含这些不应该出现的关键词
                    const testTokensForNoCheck = extractAndCleanTokens(testStr, true); // 移除MBG
                    const foundNoItems = noItemsTokens.filter(token => 
                        testTokensForNoCheck.some(testToken => 
                            testToken.includes(token) || token.includes(testToken)
                        )
                    );
                    
                    if (foundNoItems.length > 0) {
                        noItemsViolation = true;
                        noItemsViolationDetails = `测试值中不应包含以下项目: ${foundNoItems.join(', ')}`;
                        console.log('发现违规项目:', foundNoItems);
                    }
                }
                
                // 4. 处理正面部分的匹配（如果有）
                let positiveItemsMatch = true;
                let positiveMatchDetails = '';
                
                if (processedBaselineStr) {
                    // 提取正面部分的tokens
                    const baselineTokens = extractAndCleanTokens(processedBaselineStr, false);
                    const testTokens = extractAndCleanTokens(testStr, true); // 移除MBG
                    
                    console.log('正面部分基准tokens:', baselineTokens);
                    console.log('测试tokens (移除MBG后):', testTokens);
                    
                    // 进行模糊匹配：检查基准中的每个token是否在测试值中存在
                    const missingTokens = baselineTokens.filter(baseToken => 
                        !testTokens.some(testToken => 
                            testToken.includes(baseToken) || baseToken.includes(testToken)
                        )
                    );
                    
                    positiveItemsMatch = missingTokens.length === 0;
                    
                    if (!positiveItemsMatch) {
                        positiveMatchDetails = `缺少关键词: ${missingTokens.join(', ')}`;
                    }
                } else {
                    // 如果没有正面部分，则认为正面匹配成功
                    positiveMatchDetails = '无需检查正面内容';
                }
                
                // 5. 生成最终结果
                const isMatch = hasMBG && !noItemsViolation && positiveItemsMatch;
                
                let message = '';
                if (isMatch) {
                    if (hasNoInBaseline) {
                        message = `What's in the box匹配成功：包含MBG，未发现禁止项目${positiveItemsPart ? '，正面内容匹配' : ''}`;
                    } else {
                        message = 'What\'s in the box完全匹配：包含MBG且关键词相同（已忽略连接词如and、with等）';
                    }
                } else {
                    let issues = [];
                    if (!hasMBG) issues.push('测试表内容必须包含"MBG"');
                    if (noItemsViolation) issues.push(noItemsViolationDetails);
                    if (!positiveItemsMatch && positiveMatchDetails) issues.push(positiveMatchDetails);
                    message = `What's in the box验证失败: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    hasNoInBaseline: hasNoInBaseline,
                    noItemsPart: noItemsPart,
                    positiveItemsPart: positiveItemsPart,
                    noItemsViolation: noItemsViolation,
                    noItemsViolationDetails: noItemsViolationDetails,
                    positiveItemsMatch: positiveItemsMatch,
                    positiveMatchDetails: positiveMatchDetails,
                    hasMBG: hasMBG,
                    baselineValue: baselineStr,
                    testValue: testStr
                };
                
            } catch (error) {
                return { isValid: false, message: `What's in the box检验错误: ${error.message}` };
            }
        }

        function displayTechResultsMultiple(allProductResults) {
            const resultsDiv = document.getElementById('techResults');
            const productNameSpan = document.getElementById('productName');
            const checkResultsDiv = document.getElementById('techCheckResults');
            const summaryDiv = document.getElementById('techSummary');
            
            // 显示产品总数
            productNameSpan.textContent = `共 ${allProductResults.length} 个产品`;
            
            // 清空之前的结果
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    共检验 <span style="color: #2196f3; font-size: 20px;">${allProductResults.length}</span> 个产品的技术规格
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            let totalMatchedCount = 0;
            let totalUnmatchedCount = 0;
            
            // 显示每个产品的检验结果
            allProductResults.forEach((productResult, productIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                let matchedCount = 0;
                let unmatchedCount = 0;
                
                productResult.matchResults.forEach(result => {
                    if (result.checkResult) {
                        if (result.checkResult.isMatch === true) {
                            matchedCount++;
                        } else if (result.checkResult.isMatch === false) {
                            unmatchedCount++;
                        } else {
                            matchedCount++; // 手动检验也算通过
                        }
                    } else {
                        if (result.isMatched) {
                            matchedCount++;
                        } else {
                            unmatchedCount++;
                        }
                    }
                });
                
                totalMatchedCount += matchedCount;
                totalUnmatchedCount += unmatchedCount;
                
                const totalCount = matchedCount + unmatchedCount;
                const passRate = totalCount > 0 ? ((matchedCount / totalCount) * 100).toFixed(1) : 0;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                headerDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 1.2rem;">📦 产品 ${productIndex + 1}: ${productResult.partNumber}</span>
                            <br>
                            <small style="opacity: 0.9;">${productResult.productName}</small>
                            <br>
                            <small style="opacity: 0.9;">基准表列: ${productResult.column}</small>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                            通过率: ${passRate}%
                        </div>
                    </div>
                `;
                
                groupDiv.appendChild(headerDiv);
                
                const checksContainer = document.createElement('div');
                checksContainer.style.cssText = `
                    margin-top: 15px;
                `;
                
                // 显示每项规格对比结果
                productResult.matchResults.forEach(result => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'check-item';
                    itemDiv.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 15px 20px;
                        margin: 10px 0;
                        background: white;
                        border-radius: 10px;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                        transition: all 0.3s ease;
                    `;
                    
                    let statusClass = result.isMatched ? 'pass' : 'fail';
                    let statusText = result.isMatched ? '已匹配' : '未匹配';
                    
                    // 处理特殊检验结果
                    let extraInfo = '';
                    if (result.checkResult) {
                        const checkResult = result.checkResult;
                        if (checkResult.isValid) {
                            if (checkResult.isMatch === true) {
                                statusClass = 'pass';
                                statusText = 'PASS';
                                extraInfo = `<br><small style="color: #28a745;">✓ ${checkResult.message}</small>`;
                            } else if (checkResult.isMatch === false) {
                                statusClass = 'fail';
                                statusText = 'FAIL';
                                extraInfo = `<br><small style="color: #dc3545;">✗ ${checkResult.message}</small>`;
                            } else {
                                statusClass = 'pass';
                                statusText = '需手动检验';
                                extraInfo = `<br><small style="color: #ffc107;">⚠ ${checkResult.message}</small>`;
                            }
                            
                            // 添加转换后的值信息
                            if (checkResult.convertedValue) {
                                extraInfo += `<br><small style="color: #666;">转换值: ${checkResult.convertedValue}kg</small>`;
                            }
                            if (checkResult.convertedValues) {
                                const cv = checkResult.convertedValues;
                                extraInfo += `<br><small style="color: #666;">转换值: 长=${cv.length}mm, 宽=${cv.width}mm, 厚=${cv.thickness}mm</small>`;
                            }
                            if (checkResult.ppCells) {
                                extraInfo += `<br><small style="color: #007bff;">PP工作表: ${checkResult.ppCells}</small>`;
                            }
                            
                            // // 添加Processor检验的详细信息
                            // if (checkResult.detailMessage) {
                            //     extraInfo += `<br><small style="color: #666;">详细信息: ${checkResult.detailMessage}</small>`;
                            // }
                        } else {
                            statusClass = 'fail';
                            statusText = 'ERROR';
                            extraInfo = `<br><small style="color: #dc3545;">✗ ${checkResult.message}</small>`;
                        }
                    }
                    
                    itemDiv.innerHTML = `
                        <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">
                            ${result.attribute}<br>
                            <small style="color: #666;">(${result.abbreviation})</small>
                        </div>
                        <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                            基准(${result.baselineCell}): ${result.baselineValue || '(空)'}<br>
                            测试(${result.testCell}): ${result.testValue || '(空)'}${extraInfo}
                        </div>
                        <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                    `;
                    
                    checksContainer.appendChild(itemDiv);
                });
                
                groupDiv.appendChild(checksContainer);
                checkResultsDiv.appendChild(groupDiv);
            });
            
            // 显示汇总信息
            const totalCount = totalMatchedCount + totalUnmatchedCount;
            const totalPassRate = totalCount > 0 ? ((totalMatchedCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulProducts = allProductResults.filter(p => {
                const total = p.matchResults.length;
                const passed = p.matchResults.filter(r => {
                    if (r.checkResult) {
                        return r.checkResult.isMatch === true || r.checkResult.isMatch === undefined;
                    }
                    return r.isMatched;
                }).length;
                return passed === total;
            }).length;
            
            const partialProducts = allProductResults.length - successfulProducts;
            
            summaryDiv.innerHTML = `
                <h4>总体检验汇总</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allProductResults.length}</span>
                        <div class="stat-label">总产品数</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulProducts}</span>
                        <div class="stat-label">完全通过</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialProducts}</span>
                        <div class="stat-label">部分通过</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalMatchedCount}</span>
                            <div class="stat-label">总通过项目</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalUnmatchedCount}</span>
                            <div class="stat-label">总失败项目</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">总通过率</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }
        
    </script>
</body>
</html>