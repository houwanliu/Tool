<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBGè¡¨æ ¼QCæ£€éªŒå·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tabs {
            background: #f8f9fa;
            display: flex;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 20px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            color: #495057;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #f8f9fa;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab:hover:not(.active) {
            background: #dee2e6;
        }

        .tab-content {
            display: none;
            padding: 40px;
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .upload-box:hover {
            border-color: #764ba2;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .upload-box:hover::before {
            opacity: 1;
        }

        .upload-box > * {
            position: relative;
            z-index: 1;
        }

        .upload-box h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .upload-box input[type="file"] {
            margin: 15px 0;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            width: 100%;
        }

        .file-info {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #666;
        }

        .check-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .check-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .check-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results {
            margin-top: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .results h3 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }

        .check-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .check-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .check-item .item-name {
            font-weight: bold;
            color: #333;
            flex: 1;
        }

        .check-item .item-values {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #666;
            margin: 0 20px;
            text-align: center;
            flex: 2;
        }

        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .status.pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .summary {
            margin-top: 30px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 15px;
            text-align: center;
        }

        .summary h4 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-number.pass {
            color: #28a745;
        }

        .stat-number.fail {
            color: #dc3545;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 40px;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tab-content {
                padding: 20px;
            }

            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š MBGè¡¨æ ¼QCæ£€éªŒå·¥å…·</h1>
            <p>æ”¯æŒåŸºå‡†è¡¨ä¸æ£€éªŒè¡¨çš„æ™ºèƒ½æ•°æ®å¯¹æ¯”</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('basic-qc', this)">åŸºç¡€æ•°æ®æ£€éªŒ</button>
            <button class="tab" onclick="switchTab('tech-spec', this)">æŠ€æœ¯è§„æ ¼æ£€éªŒ</button>
        </div>

        <!-- åŸºç¡€QCæ£€éªŒ -->
        <div id="basic-qc" class="tab-content active">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>ğŸ“‹ åŸºå‡†è¡¨ (Tech Spec)</h3>
                    <input type="file" id="fileA" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"POR"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileAInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>ğŸ” æ£€éªŒè¡¨ (Offering)</h3>
                    <input type="file" id="fileB" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"MTM_MMR"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileBInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnBasic" onclick="performBasicQC()" disabled>
                å¼€å§‹åŸºç¡€æ•°æ®æ£€éªŒ
            </button>
            
            <div id="basicResults" class="results" style="display: none;">
                <h3>ğŸ” åŸºç¡€æ•°æ®æ£€éªŒç»“æœ</h3>
                <div id="basicCheckResults"></div>
                <div id="basicSummary" class="summary"></div>
            </div>
        </div>

        <!-- æŠ€æœ¯è§„æ ¼åŒ¹é… -->
        <div id="tech-spec" class="tab-content">
            <div class="upload-section">
                <div class="upload-box">
                    <h3>ğŸ“‹ åŸºå‡†è¡¨ (Tech Spec)</h3>
                    <input type="file" id="fileBaseline" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"Tech Spec"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileBaselineInfo" class="file-info" style="display: none;"></div>
                </div>
                
                <div class="upload-box">
                    <h3>ğŸ” æµ‹è¯•æ–‡ä»¶ (mtmElement)</h3>
                    <input type="file" id="fileTest" accept=".xlsx,.xls" />
                    <p>è¯·ä¸Šä¼ åŒ…å«"OBJECT-ELEMENT"å·¥ä½œè¡¨çš„Excelæ–‡ä»¶</p>
                    <div id="fileTestInfo" class="file-info" style="display: none;"></div>
                </div>
            </div>
            
            <button class="check-button" id="checkBtnTech" onclick="performTechSpecMatch()" disabled>
                å¼€å§‹æŠ€æœ¯è§„æ ¼åŒ¹é…
            </button>
            
            <div id="techResults" class="results" style="display: none;">
                <h3>ğŸ”  æŠ€æœ¯è§„æ ¼åŒ¹é…ç»“æœ</h3>
                <div id="productInfo" style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
                    <strong>äº§å“åç§°:</strong> <span id="productName"></span>
                </div>
                <div id="techCheckResults"></div>
                <div id="techSummary" class="summary"></div>
            </div>
        </div>
            
        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let fileAData = null;
        let fileBData = null;
        let fileBaselineData = null;
        let fileTestData = null;

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId, element) {
            // éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„activeç±»
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ˜¾ç¤ºç›®æ ‡æ ‡ç­¾å†…å®¹
            document.getElementById(tabId).classList.add('active');
            
            // æ¿€æ´»ç›®æ ‡æ ‡ç­¾
            element.classList.add('active');
            
            // éšè—é”™è¯¯æ¶ˆæ¯
            hideError();
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // éšè—é”™è¯¯æ¶ˆæ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // ===================åŸºç¡€QCæ£€éªŒåŠŸèƒ½===================
        
        // æ—¥æœŸæ ¼å¼æ ‡å‡†åŒ–å‡½æ•°
        function normalizeDate(value) {
            if (!value) return value;
            
            // å¦‚æœæ˜¯Excelæ—¥æœŸæ•°å­—ï¼Œè½¬æ¢ä¸ºæ—¥æœŸå¯¹è±¡
            if (typeof value === 'number' && value > 25000 && value < 100000) {
                try {
                    // Excelæ—¥æœŸè½¬æ¢
                    const date = XLSX.SSF.parse_date_code(value);
                    return `${date.y}-${String(date.m).padStart(2, '0')}-${String(date.d).padStart(2, '0')}`;
                } catch (e) {
                    return value;
                }
            }
            
            // å¦‚æœå·²ç»æ˜¯å­—ç¬¦ä¸²æ—¥æœŸï¼Œå°è¯•æ ‡å‡†åŒ–æ ¼å¼
            if (typeof value === 'string') {
                // åŒ¹é… YYYY-MM-DD æ ¼å¼
                let dateMatch = value.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})/);
                if (dateMatch) {
                    const [, year, month, day] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
                
                // åŒ¹é… MM/DD/YYYY æ ¼å¼
                dateMatch = value.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (dateMatch) {
                    const [, month, day, year] = dateMatch;
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
            }
            
            return value;
        }

        // å›½å®¶åˆ—è¡¨æ¯”è¾ƒå‡½æ•°ï¼ˆé¡ºåºæ— å…³ï¼‰
        function compareCountryLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå›½å®¶ä»£ç æ•°ç»„
            const countries1 = String(val1).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            const countries2 = String(val2).split(/[,/]/).map(c => c.trim().toUpperCase()).filter(c => c.length > 0);
            
            // æ’åºåæ¯”è¾ƒ
            countries1.sort();
            countries2.sort();
            
            const isMatch = countries1.length === countries2.length && 
                   countries1.every((country, index) => country === countries2[index]);
            
            // å¦‚æœä¸åŒ¹é…ï¼Œè®¡ç®—å·®å¼‚ä¿¡æ¯
            if (!isMatch) {
                const missing = countries1.filter(c => !countries2.includes(c));
                const extra = countries2.filter(c => !countries1.includes(c));
                
                let diffMessage = '';
                if (missing.length > 0) {
                    diffMessage += `Bè¡¨ç¼ºå¤±: ${missing.join(', ')}`;
                }
                if (extra.length > 0) {
                    if (diffMessage) diffMessage += '; ';
                    diffMessage += `Bè¡¨å¤šå‡º: ${extra.join(', ')}`;
                }
                
                // å°†å·®å¼‚ä¿¡æ¯å­˜å‚¨åœ¨å…¨å±€å˜é‡ä¸­ï¼Œä¾›æ˜¾ç¤ºæ—¶ä½¿ç”¨
                compareCountryLists.lastDiffMessage = diffMessage;
            } else {
                compareCountryLists.lastDiffMessage = null;
            }
            
            return isMatch;
        }

        // Audienceæ¯”è¾ƒå‡½æ•°ï¼ˆåˆ†å‰²ååŒ¹é…ï¼‰
        function compareAudienceLists(val1, val2) {
            if (!val1 && !val2) return true;
            if (!val1 || !val2) return false;
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºAudienceæ•°ç»„ï¼Œæ”¯æŒé€—å·å’Œç©ºæ ¼åˆ†éš”
            const audience1 = String(val1).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            const audience2 = String(val2).split(/[,\s]+/).map(a => a.trim()).filter(a => a.length > 0);
            
            // æ’åºåæ¯”è¾ƒ
            audience1.sort();
            audience2.sort();
            
            return audience1.length === audience2.length && 
                   audience1.every((audience, index) => audience === audience2[index]);
        }

        // é€šç”¨å€¼æ¯”è¾ƒå‡½æ•°
        function compareValues(val1, val2, convertFunc = null, customCompareFunc = null) {
            // å¦‚æœæä¾›äº†è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨
            if (customCompareFunc) {
                return customCompareFunc(val1, val2);
            }
            
            // åº”ç”¨è½¬æ¢å‡½æ•°ï¼ˆå¦‚æœæä¾›ï¼‰
            if (convertFunc) {
                val1 = convertFunc(val1);
                val2 = convertFunc(val2);
            }
            
            // å¤„ç†ç©ºå€¼
            if (val1 === null || val1 === undefined || val1 === '') {
                val1 = '';
            }
            if (val2 === null || val2 === undefined || val2 === '') {
                val2 = '';
            }
            
            // è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒ
            return String(val1).trim() === String(val2).trim();
        }

        // åŸºç¡€QCåŠŸèƒ½ä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ
        function findMatchingRowInPORBasic(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number(åŸºç¡€QC):', testPartNumber);
            
            // ä»B2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾,ç›´åˆ°Båˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const bCell = `B${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // å¦‚æœBåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Båˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    return row;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯,æœ€å¤šæŸ¥æ‰¾1000è¡Œ
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        // åœ¨åŸºå‡†è¡¨PORä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ(ç”¨äºæŠ€æœ¯è§„æ ¼æ£€éªŒ)
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number(æŠ€æœ¯è§„æ ¼):', testPartNumber);
            
            // ä»E2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾,ç›´åˆ°Eåˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const eCell = `E${row}`;
                const partNumber = sheetPOR[eCell] ? String(sheetPOR[eCell].v).trim() : '';
                
                // å¦‚æœEåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Eåˆ—ä¸ºç©º,åœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    
                    // è·å–è¯¥è¡Œçš„ç›¸å…³æ•°æ®
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('åŒ¹é…è¡Œæ•°æ®:', rowData);
                    return rowData;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯,æœ€å¤šæŸ¥æ‰¾1000è¡Œ
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        // åŸºç¡€QCæ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('fileA').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileAData = workbook;
                        
                        document.getElementById('fileAInfo').style.display = 'block';
                        document.getElementById('fileAInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æ–‡ä»¶Aå¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æ–‡ä»¶Aæ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileB').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBData = workbook;
                        
                        document.getElementById('fileBInfo').style.display = 'block';
                        document.getElementById('fileBInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkBasicButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æ–‡ä»¶Bå¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æ–‡ä»¶Bæ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkBasicButtonState() {
            const btn = document.getElementById('checkBtnBasic');
            if (fileAData && fileBData) {
                btn.disabled = false;
            }
        }

        function performBasicQC() {
            try {
                hideError();
                
                if (!fileAData.SheetNames.includes('POR')) {
                    throw new Error('åŸºå‡†è¡¨(Aè¡¨)ä¸­æœªæ‰¾åˆ°"POR"å·¥ä½œè¡¨');
                }
                
                if (!fileBData.SheetNames.includes('MTM_MMR')) {
                    throw new Error('æ£€éªŒè¡¨(Bè¡¨)ä¸­æœªæ‰¾åˆ°"MTM_MMR"å·¥ä½œè¡¨');
                }
                
                const sheetA = fileAData.Sheets['POR'];
                const sheetB = fileBData.Sheets['MTM_MMR'];
                
                // 1. éå†æ£€éªŒè¡¨çš„Båˆ—,ä»B7å¼€å§‹,æ”¶é›†æ‰€æœ‰Part Number
                const testPartNumbers = [];
                let testRow = 7;
                
                console.log('å¼€å§‹éå†æ£€éªŒè¡¨Båˆ—,æ”¶é›†Part Numbers...');
                
                while (true) {
                    const bCell = `B${testRow}`;
                    const partNumber = sheetB[bCell] ? String(sheetB[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        console.log(`æ£€éªŒè¡¨B${testRow}ä¸ºç©º,åœæ­¢éå†`);
                        break;
                    }
                    
                    console.log(`æ£€éªŒè¡¨B${testRow}: Part Number = "${partNumber}"`);
                    testPartNumbers.push({
                        partNumber: partNumber,
                        testRow: testRow
                    });
                    
                    testRow++;
                    
                    if (testRow > 1000) {
                        console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°,åœæ­¢éå†');
                        break;
                    }
                }
                
                console.log(`å…±æ‰¾åˆ°${testPartNumbers.length}ä¸ªPart Numberéœ€è¦æ£€éªŒ`);
                
                if (testPartNumbers.length === 0) {
                    throw new Error('æ£€éªŒè¡¨ä¸­æœªæ‰¾åˆ°ä»»ä½•Part Number(ä»B7å¼€å§‹)');
                }
                
                // 2. å¯¹æ¯ä¸ªPart Numberè¿›è¡Œæ£€éªŒ
                let allResults = [];
                let totalPassCount = 0;
                let totalFailCount = 0;
                
                testPartNumbers.forEach((testInfo, index) => {
                    console.log(`\n====== æ£€éªŒç¬¬${index + 1}ä¸ªPart Number: ${testInfo.partNumber} (æ£€éªŒè¡¨ç¬¬${testInfo.testRow}è¡Œ) ======`);
                    
                    let matchedRow = null;
                    const foundRow = findMatchingRowInPORBasic(sheetA, testInfo.partNumber);
                    
                    if (foundRow !== null) {
                        matchedRow = foundRow;
                        console.log(`æ‰¾åˆ°åŒ¹é…çš„Part Number,ä½¿ç”¨åŸºå‡†è¡¨ç¬¬${matchedRow}è¡Œæ•°æ®`);
                    } else {
                        console.log(`æœªæ‰¾åˆ°åŒ¹é…çš„Part Number: ${testInfo.partNumber}`);
                        allResults.push({
                            partNumber: testInfo.partNumber,
                            testRow: testInfo.testRow,
                            matchedRow: null,
                            checks: [],
                            notFound: true
                        });
                        totalFailCount++;
                        return;
                    }
                    
                    const checks = [
                        {
                            name: 'Part Number',
                            cellA: `B${matchedRow}`,
                            cellB: `B${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Mkt Description',
                            cellA: `D${matchedRow}`,
                            cellB: `Y${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        },
                        {
                            name: 'Audience',
                            cellA: `J${matchedRow}`,
                            cellB: `AB${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareAudienceLists
                        },
                        {
                            name: 'Country',
                            cellA: `G${matchedRow}`,
                            cellB: `AC${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: compareCountryLists
                        },
                        {
                            name: 'Annc Date',
                            cellA: `H${matchedRow}`,
                            cellB: `AE${testInfo.testRow}`,
                            converter: normalizeDate,
                            customCompareFunc: null
                        },
                        {
                            name: 'WW',
                            cellA: `K${matchedRow}`,
                            cellB: `AI${testInfo.testRow}`,
                            converter: null,
                            customCompareFunc: null
                        }
                    ];
                    
                    let checkResults = [];
                    let passCount = 0;
                    let failCount = 0;
                    
                    checks.forEach(check => {
                        const valueA = sheetA[check.cellA] ? sheetA[check.cellA].v : '';
                        const valueB = sheetB[check.cellB] ? sheetB[check.cellB].v : '';
                        
                        const isMatch = compareValues(valueA, valueB, check.converter, check.customCompareFunc);
                        
                        let displayValueA = valueA;
                        let displayValueB = valueB;
                        
                        if (check.converter) {
                            displayValueA = check.converter(valueA);
                            displayValueB = check.converter(valueB);
                        }
                        
                        if (check.customCompareFunc === compareCountryLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }

                        if (check.customCompareFunc === compareAudienceLists) {
                            displayValueA = valueA;
                            displayValueB = valueB;
                        }
                        
                        checkResults.push({
                            name: check.name,
                            valueA: displayValueA,
                            valueB: displayValueB,
                            cellA: check.cellA,
                            cellB: check.cellB,
                            isMatch: isMatch,
                            diffMessage: check.customCompareFunc === compareCountryLists ? compareCountryLists.lastDiffMessage : null
                        });
                        
                        if (isMatch) {
                            passCount++;
                        } else {
                            failCount++;
                        }
                    });
                    
                    totalPassCount += passCount;
                    totalFailCount += failCount;
                    
                    allResults.push({
                        partNumber: testInfo.partNumber,
                        testRow: testInfo.testRow,
                        matchedRow: matchedRow,
                        checks: checkResults,
                        passCount: passCount,
                        failCount: failCount,
                        notFound: false
                    });
                });
                
                displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount);
                
            } catch (error) {
                showError(`æ£€éªŒè¿‡ç¨‹å‡ºé”™: ${error.message}`);
                console.error('åŸºç¡€QCæ£€éªŒé”™è¯¯:', error);
            }
        }
        
        function displayBasicResultsMultiple(allResults, totalPassCount, totalFailCount) {
            const resultsDiv = document.getElementById('basicResults');
            const checkResultsDiv = document.getElementById('basicCheckResults');
            const summaryDiv = document.getElementById('basicSummary');
            
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    å…±æ£€éªŒ <span style="color: #2196f3; font-size: 20px;">${allResults.length}</span> ä¸ªPart Number
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            allResults.forEach((result, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                if (result.notFound) {
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">ğŸ“¦ Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">æ£€éªŒè¡¨ç¬¬${result.testRow}è¡Œ</small>
                            </div>
                            <div style="background: #dc3545; padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                âŒ æœªæ‰¾åˆ°åŒ¹é…
                            </div>
                        </div>
                    `;
                    
                    const notFoundMsg = document.createElement('div');
                    notFoundMsg.style.cssText = `
                        background: #f8d7da;
                        color: #721c24;
                        padding: 15px;
                        border-radius: 8px;
                        margin-top: 10px;
                        border: 1px solid #f5c6cb;
                    `;
                    notFoundMsg.textContent = `âš ï¸ åœ¨åŸºå‡†è¡¨ä¸­æœªæ‰¾åˆ°Part Number "${result.partNumber}" çš„åŒ¹é…è¡Œ`;
                    
                    groupDiv.appendChild(headerDiv);
                    groupDiv.appendChild(notFoundMsg);
                } else {
                    const passRate = result.checks.length > 0 ? 
                        ((result.passCount / result.checks.length) * 100).toFixed(1) : 0;
                    
                    headerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2rem;">ğŸ“¦ Part Number ${index + 1}: ${result.partNumber}</span>
                                <br>
                                <small style="opacity: 0.9;">æ£€éªŒè¡¨ç¬¬${result.testRow}è¡Œ â†”ï¸ åŸºå‡†è¡¨ç¬¬${result.matchedRow}è¡Œ</small>
                            </div>
                            <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                                é€šè¿‡ç‡: ${passRate}%
                            </div>
                        </div>
                    `;
                    
                    groupDiv.appendChild(headerDiv);
                    
                    const checksContainer = document.createElement('div');
                    checksContainer.style.cssText = `
                        margin-top: 15px;
                    `;
                    
                    result.checks.forEach(check => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'check-item';
                        itemDiv.style.cssText = `
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                            padding: 15px 20px;
                            margin: 10px 0;
                            background: white;
                            border-radius: 10px;
                            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                            transition: all 0.3s ease;
                        `;
                        
                        const statusClass = check.isMatch ? 'pass' : 'fail';
                        const statusText = check.isMatch ? 'PASS' : 'FAIL';
                        
                        let diffInfo = '';
                        if (!check.isMatch && check.diffMessage) {
                            diffInfo = `<br><small style="color: #dc3545; font-style: italic;">${check.diffMessage}</small>`;
                        }
                        
                        itemDiv.innerHTML = `
                            <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">${check.name}</div>
                            <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                                åŸºå‡†è¡¨(${check.cellA}): ${check.valueA || '(ç©º)'}<br>
                                æ£€éªŒè¡¨(${check.cellB}): ${check.valueB || '(ç©º)'}${diffInfo}
                            </div>
                            <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                        `;
                        
                        checksContainer.appendChild(itemDiv);
                    });
                    
                    groupDiv.appendChild(checksContainer);
                }
                
                checkResultsDiv.appendChild(groupDiv);
            });
            
            const totalCount = totalPassCount + totalFailCount;
            const totalPassRate = totalCount > 0 ? ((totalPassCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulParts = allResults.filter(r => !r.notFound && r.failCount === 0).length;
            const partialParts = allResults.filter(r => !r.notFound && r.failCount > 0).length;
            const notFoundParts = allResults.filter(r => r.notFound).length;
            
            summaryDiv.innerHTML = `
                <h4>æ€»ä½“æ£€éªŒæ±‡æ€»</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allResults.length}</span>
                        <div class="stat-label">æ€»Part Numberæ•°</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulParts}</span>
                        <div class="stat-label">å®Œå…¨é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialParts}</span>
                        <div class="stat-label">éƒ¨åˆ†é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number fail">${notFoundParts}</span>
                        <div class="stat-label">æœªæ‰¾åˆ°åŒ¹é…</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalPassCount}</span>
                            <div class="stat-label">æ€»é€šè¿‡é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalFailCount}</span>
                            <div class="stat-label">æ€»å¤±è´¥é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">æ€»é€šè¿‡ç‡</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        // ===================æŠ€æœ¯è§„æ ¼åŒ¹é…åŠŸèƒ½===================
        
        // æŠ€æœ¯è§„æ ¼æ˜ å°„è¡¨
        const techSpecMapping = {
            'Processor': 'PRC',
            'OS': 'OS',
            'Display': 'MON',
            'Storage': 'HD',
            'Memory': 'MEM',
            'Graphics': 'GRA',
            'Front Camera': 'CAM',
            'Back Camera': 'CAM',
            'Back': 'CAM',
            'Audio': 'AUD',
            'Fingerprint Reader': 'SEC',
            'Weight': 'PP',
            'Weight/Dimension': 'PP',
            'Dimension': 'PP',
            'Port': 'PORT',
            'Warranty': 'WAR',
            'Bluetooth': 'WS',
            'Wireless': 'WS',
            'What\'s in the box': 'MM',
            'Color': 'COLOR',
            'Battery Life': 'TI',
            'IMG': 'IMG'
        };

        // æŠ€æœ¯è§„æ ¼æ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('fileBaseline').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileBaselineData = workbook;
                        
                        document.getElementById('fileBaselineInfo').style.display = 'block';
                        document.getElementById('fileBaselineInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–åŸºå‡†æ–‡ä»¶å¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–åŸºå‡†æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('fileTest').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        fileTestData = workbook;
                        
                        document.getElementById('fileTestInfo').style.display = 'block';
                        document.getElementById('fileTestInfo').innerHTML = `
                            <strong>æ–‡ä»¶å:</strong> ${file.name}<br>
                            <strong>å·¥ä½œè¡¨:</strong> ${workbook.SheetNames.join(', ')}<br>
                            <strong>çŠ¶æ€:</strong> âœ… å·²åŠ è½½
                        `;
                        checkTechButtonState();
                        hideError();
                    } catch (error) {
                        showError(`è¯»å–æµ‹è¯•æ–‡ä»¶å¤±è´¥: ${error.message}`);
                    }
                };
                reader.onerror = function() {
                    showError('è¯»å–æµ‹è¯•æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯');
                };
                reader.readAsArrayBuffer(file);
            }
        });

        function checkTechButtonState() {
            const btn = document.getElementById('checkBtnTech');
            if (fileBaselineData && fileTestData) {
                btn.disabled = false;
            }
        }

        // ä»æŒ‡å®šåˆ—æå–åŸºå‡†è§„æ ¼æ•°æ®
        function extractBaselineSpecsForColumn(sheet, column) {
            const specs = {};
            
            let row = 2;
            const maxRows = 100;
            let lastAttrName = null;  // è®°å½•ä¸Šä¸€è¡Œçš„å±æ€§å
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${column}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: å±æ€§="${attrName}", å€¼="${attrValue}"`);
                
                if (attrName === '#EOF') {
                    console.log('é‡åˆ°#EOFæ ‡è®°,åœæ­¢è¯»å–');
                    break;
                }
                
                // æƒ…å†µ1: Aåˆ—æœ‰å±æ€§åï¼Œä¸”åœ¨mappingä¸­
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell,
                        cells: [valueCell]
                    };
                    lastAttrName = attrName;
                    console.log(`æ·»åŠ è§„æ ¼: ${attrName} = "${attrValue}"`);
                }
                // æƒ…å†µ2: Aåˆ—ä¸ºç©ºï¼Œä½†æœ‰å€¼ï¼Œä¸”ä¸Šä¸€è¡Œæ˜¯æœ‰æ•ˆå±æ€§ - è¿™æ˜¯å¤šè¡Œæ•°æ®çš„å»¶ç»­
                else if (!attrName && attrValue && lastAttrName && specs[lastAttrName]) {
                    // è¿½åŠ åˆ°ä¸Šä¸€ä¸ªå±æ€§
                    const existingValue = specs[lastAttrName].value;
                    specs[lastAttrName].value = existingValue + '\n' + attrValue;
                    specs[lastAttrName].cells.push(valueCell);
                    console.log(`è¿½åŠ åˆ°${lastAttrName}: "${attrValue}"`);
                }
                // æƒ…å†µ3: Aåˆ—ä¸ºç©ºï¼Œå€¼ä¹Ÿä¸ºç©º - é‡ç½®lastAttrName
                else if (!attrName && !attrValue) {
                    lastAttrName = null;
                }
                
                row++;
            }
            
            console.log('åŸºå‡†è§„æ ¼æå–å®Œæˆ,æ€»å…±æå–åˆ°:', Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            console.log('è§„æ ¼åˆ—è¡¨:', Object.keys(specs));
            
            return specs;
        }

        function performTechSpecMatch() {
            try {
                hideError();
                
                // æ£€æŸ¥å·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                if (!fileBaselineData.SheetNames.includes('Tech Spec')) {
                    throw new Error('åŸºå‡†æ–‡ä»¶ä¸­æœªæ‰¾åˆ°"Tech Spec"å·¥ä½œè¡¨');
                }
                
                if (!fileTestData.SheetNames.includes('OBJECT-ELEMENT')) {
                    throw new Error('æµ‹è¯•æ–‡ä»¶ä¸­æœªæ‰¾åˆ°"OBJECT-ELEMENT"å·¥ä½œè¡¨');
                }
                
                // æ£€æŸ¥PPå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPP = null;
                if (fileTestData.SheetNames.includes('PP')) {
                    sheetPP = fileTestData.Sheets['PP'];
                }
                
                // æ£€æŸ¥CAMå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetCAM = null;
                if (fileTestData.SheetNames.includes('CAM')) {
                    sheetCAM = fileTestData.Sheets['CAM'];
                }
                
                // æ£€æŸ¥WSå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetWS = null;
                if (fileTestData.SheetNames.includes('WS')) {
                    sheetWS = fileTestData.Sheets['WS'];
                }
                
                // æ£€æŸ¥PORå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPOR = null;
                if (fileBaselineData.SheetNames.includes('POR')) {
                    sheetPOR = fileBaselineData.Sheets['POR'];
                }
                
                // æ£€æŸ¥PRCå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPRC = null;
                if (fileTestData.SheetNames.includes('PRC')) {
                    sheetPRC = fileTestData.Sheets['PRC'];
                }
                
                // æ£€æŸ¥MEMå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetMEM = null;
                if (fileTestData.SheetNames.includes('MEM')) {
                    sheetMEM = fileTestData.Sheets['MEM'];
                }
                
                // æ£€æŸ¥HDå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetHD = null;
                if (fileTestData.SheetNames.includes('HD')) {
                    sheetHD = fileTestData.Sheets['HD'];
                }

                let sheetOS = null;
                if (fileTestData.SheetNames.includes('OS')) {
                    sheetOS = fileTestData.Sheets['OS'];
                }

                // æ£€æŸ¥GRAå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetGRA = null;
                if (fileTestData.SheetNames.includes('GRA')) {
                    sheetGRA = fileTestData.Sheets['GRA'];
                }
                
                // æ£€æŸ¥AUDå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetAUD = null;
                if (fileTestData.SheetNames.includes('AUD')) {
                    sheetAUD = fileTestData.Sheets['AUD'];
                }

                // æ£€æŸ¥WARå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetWAR = null;
                if (fileTestData.SheetNames.includes('WAR')) {
                    sheetWAR = fileTestData.Sheets['WAR'];
                }

                // æ£€æŸ¥PORTå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetPORT = null;
                if (fileTestData.SheetNames.includes('PORT')) {
                    sheetPORT = fileTestData.Sheets['PORT'];
                }

                // æ£€æŸ¥SECå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetSEC = null;
                if (fileTestData.SheetNames.includes('SEC')) {
                    sheetSEC = fileTestData.Sheets['SEC'];
                }

                // æ£€æŸ¥MMå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetMM = null;
                if (fileTestData.SheetNames.includes('MM')) {
                    sheetMM = fileTestData.Sheets['MM'];
                }

                // æ£€æŸ¥MONå·¥ä½œè¡¨æ˜¯å¦å­˜åœ¨
                let sheetMON = null;
                if (fileTestData.SheetNames.includes('MON')) {
                    sheetMON = fileTestData.Sheets['MON'];
                }

                const sheetBaseline = fileBaselineData.Sheets['Tech Spec'];
                const sheetTest = fileTestData.Sheets['OBJECT-ELEMENT'];
                
                // 1. éå†æµ‹è¯•è¡¨çš„OBJECT-ELEMENTå·¥ä½œè¡¨,ä»D6å¼€å§‹æ¨ªå‘è¯»å–äº§å“,ç›´åˆ°é‡åˆ°#EOF
                const productList = [];
                let col = 'D';
                let colIndex = 4; // Dåˆ—å¯¹åº”ç´¢å¼•4
                
                console.log('å¼€å§‹éå†æµ‹è¯•è¡¨OBJECT-ELEMENT,ä»D6å¼€å§‹æ”¶é›†äº§å“åˆ—è¡¨...');
                
                while (true) {
                    const cellAddr = `${col}6`;
                    const cellValue = sheetTest[cellAddr] ? String(sheetTest[cellAddr].v).trim() : '';
                    
                    console.log(`æ£€æŸ¥å•å…ƒæ ¼${cellAddr}: "${cellValue}"`);
                    
                    // æ£€æŸ¥æ˜¯å¦é‡åˆ°#EOF
                    if (cellValue === '#EOF' || !cellValue) {
                        console.log(`åœ¨${cellAddr}é‡åˆ°#EOFæˆ–ç©ºå€¼,åœæ­¢éå†`);
                        break;
                    }
                    
                    // ä»äº§å“åç§°ä¸­æå–Part Number (æ ¼å¼: [PN]æè¿°)
                    const pnMatch = cellValue.match(/\[([^\]]+)\]/);
                    const partNumber = pnMatch ? pnMatch[1].trim() : '';
                    
                    if (partNumber) {
                        console.log(`åˆ—${col}: æ‰¾åˆ°äº§å“ Part Number="${partNumber}", å®Œæ•´åç§°="${cellValue}"`);
                        productList.push({
                            partNumber: partNumber,
                            productName: cellValue,
                            column: col,
                            colIndex: colIndex
                        });
                    } else {
                        console.log(`åˆ—${col}: æœªèƒ½ä»"${cellValue}"ä¸­æå–Part Number`);
                    }
                    
                    // ç§»åŠ¨åˆ°ä¸‹ä¸€åˆ—
                    colIndex++;
                    if (colIndex <= 26) {
                        col = String.fromCharCode(64 + colIndex); // A=65, B=66...Z=90
                    } else {
                        // å¤„ç†AA, ABç­‰åˆ—
                        const firstChar = String.fromCharCode(64 + Math.floor((colIndex - 1) / 26));
                        const secondChar = String.fromCharCode(64 + ((colIndex - 1) % 26) + 1);
                        col = firstChar + secondChar;
                    }
                    
                    // é˜²æ­¢æ— é™å¾ªç¯
                    if (colIndex > 100) {
                        console.log('è¶…è¿‡æœ€å¤§åˆ—æ•°,åœæ­¢éå†');
                        break;
                    }
                }
                
                console.log(`å…±æ‰¾åˆ°${productList.length}ä¸ªäº§å“éœ€è¦æ£€éªŒ`);
                
                if (productList.length === 0) {
                    throw new Error('æµ‹è¯•è¡¨ä¸­æœªæ‰¾åˆ°ä»»ä½•äº§å“(ä»D6å¼€å§‹,æ ¼å¼åº”ä¸º[PN]æè¿°)');
                }
                
                // 2. å¯¹æ¯ä¸ªäº§å“è¿›è¡ŒæŠ€æœ¯è§„æ ¼æ£€éªŒ
                let allProductResults = [];
                
                productList.forEach((productInfo, index) => {
                    console.log(`\n====== æ£€éªŒç¬¬${index + 1}ä¸ªäº§å“: ${productInfo.partNumber} ======`);
                    
                    // 1. æå–äº§å“åç§° (åŸºå‡†è¡¨å§‹ç»ˆä½¿ç”¨B1/C1)
                    const b1 = sheetBaseline['B1'] ? sheetBaseline['B1'].v : '';
                    const c1 = sheetBaseline['C1'] ? sheetBaseline['C1'].v : '';
                    let baselineProductName = '';
                    let valueColumn = 'C'; // é»˜è®¤å€¼åˆ—
                    
                    console.log('ğŸ” åŸºå‡†è¡¨ç¬¬ä¸€è¡Œæ£€æŸ¥:');
                    console.log('  B1 åŸå§‹å€¼:', b1);
                    console.log('  B1 å¤„ç†å:', String(b1).trim());
                    console.log('  C1 åŸå§‹å€¼:', c1);
                    console.log('  C1 å¤„ç†å:', String(c1).trim());
                    
                    if (String(b1).trim() === 'Product Name') {
                        baselineProductName = String(c1).trim();
                        valueColumn = 'C'; // B1æ˜¯Product Nameï¼Œå€¼åœ¨Cåˆ—
                        console.log('  âœ… æ£€æµ‹åˆ°B1æ˜¯Product Nameï¼Œå€¼åˆ—è®¾ä¸ºC');
                    } else if (String(c1).trim() === 'Product Name') {
                        baselineProductName = String(b1).trim();
                        valueColumn = 'B'; // C1æ˜¯Product Nameï¼Œå€¼åœ¨Båˆ—
                        console.log('  âœ… æ£€æµ‹åˆ°C1æ˜¯Product Nameï¼Œå€¼åˆ—è®¾ä¸ºB');
                    } else {
                        console.log('  âš ï¸ è­¦å‘Šï¼šB1å’ŒC1éƒ½ä¸æ˜¯Product Nameï¼');
                        console.log('  B1 === "Product Name"?', String(b1).trim() === 'Product Name');
                        console.log('  C1 === "Product Name"?', String(c1).trim() === 'Product Name');
                        // é»˜è®¤ä½¿ç”¨Cåˆ—
                        valueColumn = 'C';
                    }
                    
                    console.log('  ğŸ“ æœ€ç»ˆå€¼åˆ—:', valueColumn);
                    console.log('  ğŸ“ äº§å“åç§°:', baselineProductName);
                    
                    // 2. æå–åŸºå‡†è§„æ ¼æ•°æ®
                    const baselineSpecs = extractBaselineSpecsForColumn(sheetBaseline, valueColumn);
                    
                    // 3. å¦‚æœæœ‰Colorå±æ€§ä¸”æœ‰PORå·¥ä½œè¡¨,ä»PORè¯»å–ColoråŸºå‡†å€¼
                    if (sheetPOR && baselineSpecs['Color']) {
                        const porRow = findMatchingRowInPOR(sheetPOR, productInfo.partNumber);
                        if (porRow) {
                            const mCell = sheetPOR[`M${porRow.row}`];
                            if (mCell) {
                                baselineSpecs['Color'] = {
                                    value: String(mCell.v || '').trim(),
                                    cell: `POR M${porRow.row}`
                                };
                            }
                        }
                    }
                    
                    // 4. æå–æµ‹è¯•è§„æ ¼æ•°æ® (ä»å¯¹åº”åˆ—è¯»å–)
                    const testSpecs = extractTestSpecsForColumn(sheetTest, productInfo.column, sheetPP);

                    // 5. æå–Cameraæ•°æ®
                    const cameraSpecs = extractCameraSpecs(sheetCAM);
                    
                    // 6. æå–Wirelessæ•°æ®
                    const wirelessSpecs = extractWirelessSpecs(sheetWS);
                    
                    // 7. è¿›è¡ŒåŒ¹é…å¯¹æ¯”                   
                    const matchResults = matchTechSpecs(
                    baselineSpecs, 
                    testSpecs, 
                    sheetPP, 
                    cameraSpecs, 
                    wirelessSpecs, 
                    sheetWS,   // ä¼ å…¥WSå·¥ä½œè¡¨
                    sheetPOR, 
                    sheetPRC, 
                    sheetMEM, 
                    sheetHD, 
                    fileTestData, 
                    productInfo,
                    sheetOS,     // æ–°å¢
                    sheetGRA,    // æ–°å¢
                    sheetAUD,    // æ–°å¢
                    sheetWAR,    // æ–°å¢
                    sheetPORT,   // æ–°å¢
                    sheetSEC,    // æ–°å¢
                    sheetMM,     // æ–°å¢
                    sheetMON     // æ–°å¢
                );

                    allProductResults.push({
                        partNumber: productInfo.partNumber,
                        productName: productInfo.productName,
                        column: productInfo.column,
                        baselineProductName: baselineProductName,
                        matchResults: matchResults
                    });
                });
                
                // æ˜¾ç¤ºæ‰€æœ‰äº§å“çš„æ£€éªŒç»“æœ
                displayTechResultsMultiple(allProductResults);
                
            } catch (error) {
                showError(`æŠ€æœ¯è§„æ ¼åŒ¹é…è¿‡ç¨‹å‡ºé”™: ${error.message}`);
                console.error('æŠ€æœ¯è§„æ ¼åŒ¹é…é”™è¯¯:', error);
            }
        }

        // æ£€æŸ¥OSå·¥ä½œè¡¨
        let sheetOS = null;
        if (fileTestData.SheetNames.includes('OS')) {
            sheetOS = fileTestData.Sheets['OS'];
        }

        // æ£€æŸ¥GRAå·¥ä½œè¡¨
        let sheetGRA = null;
        if (fileTestData.SheetNames.includes('GRA')) {
            sheetGRA = fileTestData.Sheets['GRA'];
        }

        // æ£€æŸ¥AUDå·¥ä½œè¡¨
        let sheetAUD = null;
        if (fileTestData.SheetNames.includes('AUD')) {
            sheetAUD = fileTestData.Sheets['AUD'];
        }

        // æ£€æŸ¥WARå·¥ä½œè¡¨
        let sheetWAR = null;
        if (fileTestData.SheetNames.includes('WAR')) {
            sheetWAR = fileTestData.Sheets['WAR'];
        }

        // æ£€æŸ¥PORTå·¥ä½œè¡¨
        let sheetPORT = null;
        if (fileTestData.SheetNames.includes('PORT')) {
            sheetPORT = fileTestData.Sheets['PORT'];
        }

        // æ£€æŸ¥SECå·¥ä½œè¡¨
        let sheetSEC = null;
        if (fileTestData.SheetNames.includes('SEC')) {
            sheetSEC = fileTestData.Sheets['SEC'];
        }

        // æ£€æŸ¥MMå·¥ä½œè¡¨
        let sheetMM = null;
        if (fileTestData.SheetNames.includes('MM')) {
            sheetMM = fileTestData.Sheets['MM'];
        }

        // æ£€æŸ¥MONå·¥ä½œè¡¨
        let sheetMON = null;
        if (fileTestData.SheetNames.includes('MON')) {
            sheetMON = fileTestData.Sheets['MON'];
        }

        function extractProductName(sheet) {
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            if (String(b1).trim() === 'Product Name') {
                return String(c1).trim();
            } else if (String(c1).trim() === 'Product Name') {
                return String(b1).trim();
            } else {
                throw new Error('æœªæ‰¾åˆ°äº§å“åç§°ï¼Œè¯·æ£€æŸ¥B1å’ŒC1å•å…ƒæ ¼');
            }
        }

        // ä»æµ‹è¯•è¡¨ä¸­è·å–Part Number
        function getTestPartNumber(sheet) {
            // æ£€æŸ¥OBJECT-ELEMENTè¡¨çš„B6å•å…ƒæ ¼ï¼ˆå‡è®¾Part Numberåœ¨è¿™é‡Œï¼‰
            // æˆ–è€…ä»ç¬¬6è¡Œå¼€å§‹æŸ¥æ‰¾"PRC"ç±»å‹å¯¹åº”çš„å€¼
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                // å¦‚æœæ‰¾åˆ°PRCç±»å‹ï¼Œè¿”å›å…¶å€¼ä½œä¸ºPart Number
                if (typeName === 'PRC') {
                    return typeValue;
                }
                
                row++;
            }
            
            return null;
        }

        // åœ¨åŸºå‡†è¡¨PORä¸­æŸ¥æ‰¾åŒ¹é…çš„Part Numberè¡Œ
        function findMatchingRowInPOR(sheetPOR, testPartNumber) {
            console.log('åœ¨PORè¡¨ä¸­æŸ¥æ‰¾Part Number:', testPartNumber);
            
            // ä»B2å¼€å§‹å‘ä¸‹æŸ¥æ‰¾ï¼Œç›´åˆ°Båˆ—ä¸ºç©º
            let row = 2;
            while (true) {
                const bCell = `E${row}`;
                const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                
                // å¦‚æœBåˆ—ä¸ºç©ºï¼Œåœæ­¢æŸ¥æ‰¾
                if (!partNumber) {
                    console.log(`è¡Œ${row}: Båˆ—ä¸ºç©ºï¼Œåœæ­¢æŸ¥æ‰¾`);
                    break;
                }
                
                console.log(`è¡Œ${row}: Part Number = "${partNumber}"`);
                
                // å¦‚æœæ‰¾åˆ°åŒ¹é…çš„Part Number
                if (partNumber === testPartNumber) {
                    console.log(`æ‰¾åˆ°åŒ¹é…çš„è¡Œ: ${row}`);
                    
                    // è·å–è¯¥è¡Œçš„ç›¸å…³æ•°æ®
                    const rowData = {
                        row: row,
                        partNumber: partNumber,
                        country: sheetPOR[`G${row}`] ? String(sheetPOR[`G${row}`].v || '').trim() : '',
                        anncDate: sheetPOR[`H${row}`] ? String(sheetPOR[`H${row}`].v || '').trim() : '',
                        audience: sheetPOR[`J${row}`] ? String(sheetPOR[`J${row}`].v || '').trim() : '',
                        ww: sheetPOR[`K${row}`] ? String(sheetPOR[`K${row}`].v || '').trim() : '',
                        color: sheetPOR[`M${row}`] ? String(sheetPOR[`M${row}`].v || '').trim() : '',
                        whatsInTheBox: sheetPOR[`N${row}`] ? String(sheetPOR[`N${row}`].v || '').trim() : ''
                    };
                    
                    console.log('åŒ¹é…è¡Œæ•°æ®:', rowData);
                    return rowData;
                }
                
                row++;
                
                // é˜²æ­¢æ— é™å¾ªç¯ï¼Œæœ€å¤šæŸ¥æ‰¾100è¡Œ
                if (row > 100) {
                    console.log('è¶…è¿‡æœ€å¤§æŸ¥æ‰¾è¡Œæ•°ï¼Œåœæ­¢æŸ¥æ‰¾');
                    break;
                }
            }
            
            console.log('æœªæ‰¾åˆ°åŒ¹é…çš„Part Number');
            return null;
        }

        function extractBaselineSpecs(sheet) {
            const specs = {};
            const b1 = sheet['B1'] ? sheet['B1'].v : '';
            const c1 = sheet['C1'] ? sheet['C1'].v : '';
            
            // ç¡®å®šå€¼åˆ—ï¼ˆBåˆ—è¿˜æ˜¯Cåˆ—ï¼‰
            const valueColumn = String(b1).trim() === 'Product Name' ? 'C' : 'B';
            
            console.log('å¼€å§‹æå–åŸºå‡†è§„æ ¼ï¼Œå€¼åˆ—ä¸º:', valueColumn);
            
            // ä»ç¬¬2è¡Œå¼€å§‹è¯»å–è§„æ ¼ï¼Œç›´åˆ°é‡åˆ°#EOFæˆ–è€…è¶…å‡ºåˆç†èŒƒå›´
            let row = 2;
            const maxRows = 100; // é˜²æ­¢æ— é™å¾ªç¯ï¼Œè®¾ç½®æœ€å¤§è¡Œæ•°
            
            while (row <= maxRows) {
                const attrCell = `A${row}`;
                const valueCell = `${valueColumn}${row}`;
                
                const attrName = sheet[attrCell] ? String(sheet[attrCell].v).trim() : '';
                const attrValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: å±æ€§="${attrName}", å€¼="${attrValue}"`);
                
                // æ£€æŸ¥æ˜¯å¦é‡åˆ°#EOFæ ‡è®°
                if (attrName === '#EOF') {
                    console.log('é‡åˆ°#EOFæ ‡è®°ï¼Œåœæ­¢è¯»å–');
                    break;
                }
                
                // åªæ·»åŠ techSpecMappingä¸­å®šä¹‰çš„å±æ€§
                if (attrName && techSpecMapping.hasOwnProperty(attrName)) {
                    specs[attrName] = {
                        value: attrValue,
                        cell: valueCell
                    };
                    console.log(`æ·»åŠ è§„æ ¼: ${attrName} = "${attrValue}" (æ˜ å°„åˆ°: ${techSpecMapping[attrName]})`);
                } else if (attrName) {
                    console.log(`è·³è¿‡æœªæ˜ å°„çš„å±æ€§: ${attrName}`);
                }
                // å¦‚æœå±æ€§åä¸ºç©ºï¼Œç»§ç»­è¯»å–ä¸‹ä¸€è¡Œï¼ˆè·³è¿‡ç©ºè¡Œï¼‰
                
                row++;
            }
            
            console.log('åŸºå‡†è§„æ ¼æå–å®Œæˆï¼Œæ€»å…±æå–åˆ°:', Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            console.log('è§„æ ¼åˆ—è¡¨:', Object.keys(specs));
            
            return specs;
        }

        function extractTestSpecs(sheet) {
            const specs = {};
            
            // ä»ç¬¬6è¡Œå¼€å§‹è¯»å–ï¼Œç›´åˆ°é‡åˆ°#EOF
            let row = 6;
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                
                if (typeName === '#EOF' || !typeName) break;
                
                specs[typeName] = {
                    value: typeValue,
                    cell: valueCell
                };
                
                row++;
            }
            
            return specs;
        }

        function extractTestSpecsForColumn(sheet, column, sheetPP = null) {  // æ·»åŠ  sheetPP å‚æ•°
            const specs = {};
            
            console.log(`å¼€å§‹ä»åˆ—${column}æå–æµ‹è¯•è§„æ ¼`);
            
            let row = 7;
            
            while (true) {
                const typeCell = `B${row}`;
                const valueCell = `C${row}`;
                const markerCell = `${column}${row}`;
                
                const typeName = sheet[typeCell] ? String(sheet[typeCell].v).trim() : '';
                const typeValue = sheet[valueCell] ? String(sheet[valueCell].v).trim() : '';
                const markerValue = sheet[markerCell] ? String(sheet[markerCell].v).trim() : '';
                
                console.log(`è¡Œ${row}: ç±»å‹="${typeName}", å€¼="${typeValue}", æ ‡è®°åˆ—${column}="${markerValue}"`);
                
                if (typeName === '#EOF' || !typeName) {
                    console.log('é‡åˆ°#EOFæˆ–ç©ºå€¼,åœæ­¢è¯»å–');
                    break;
                }
                
                if (markerValue) {
                    // â­ æ–°å¢ï¼šå½“ç±»å‹æ˜¯PPæ—¶çš„ç‰¹æ®Šå¤„ç†
                    if (typeName === 'PP' && sheetPP) {
                        const ppData = extractPPDimensionData(sheetPP);
                        
                        // åªåœ¨ç¬¬ä¸€æ¬¡é‡åˆ°PPæ—¶å¤„ç†,é¿å…é‡å¤
                        if (!specs[typeName]) {
                            specs[typeName] = {
                                value: ppData.displayValue,
                                rawData: ppData,
                                cell: 'PPå·¥ä½œè¡¨',
                                markerCell: markerCell,
                                row: row
                            };
                            console.log(`ä»PPå·¥ä½œè¡¨æå–æ•°æ®: ${ppData.displayValue}`);
                        }
                    } else {
                        // åŸæœ‰é€»è¾‘ä¿æŒä¸å˜
                        if (specs[typeName]) {
                            if (!Array.isArray(specs[typeName])) {
                                specs[typeName] = [specs[typeName]];
                            }
                            specs[typeName].push({
                                value: typeValue,
                                cell: valueCell,
                                markerCell: markerCell,
                                row: row
                            });
                            console.log(`æ·»åŠ é‡å¤è§„æ ¼: ${typeName} = "${typeValue}"`);
                        } else {
                            specs[typeName] = {
                                value: typeValue,
                                cell: valueCell,
                                markerCell: markerCell,
                                row: row
                            };
                            console.log(`æ”¶é›†è§„æ ¼: ${typeName} = "${typeValue}"`);
                        }
                    }
                }
                
                row++;
                
                if (row > 1000) {
                    console.log('è¶…è¿‡æœ€å¤§è¡Œæ•°,åœæ­¢è¯»å–');
                    break;
                }
            }
            
            console.log(`åˆ—${column}æµ‹è¯•è§„æ ¼æå–å®Œæˆ,æ€»å…±æå–åˆ°:`, Object.keys(specs).length, 'ä¸ªè§„æ ¼');
            
            return specs;
        }

        function extractCameraSpecs(sheet) {
            const cameraSpecs = {};
            
            if (!sheet) {
                return cameraSpecs;
            }
            
            // æ‰¾åˆ°å…³é”®åˆ—çš„ä½ç½®
            let locationCol = null;
            let elementDescCol = null;
            let descriptionCol = null;
            
            // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheet[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    if (headerValue === 'LOCATION' || headerValue === 'FEATURES_LOCATION') locationCol = colLetter;
                    if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC' || headerValue === 'IELEMENT_DESC') elementDescCol = colLetter;
                    if (headerValue === 'DESCRIPTION' || headerValue === 'DESCRIPTI') descriptionCol = colLetter;
                }
            }
            
            console.log('CAMè¡¨åˆ—ä½ç½®:', {
                locationCol,
                elementDescCol,
                descriptionCol
            });
            
            // éå†æ•°æ®è¡Œ
            for (let row = 2; row <= 20; row++) {
                if (!locationCol || !elementDescCol) {
                    console.log('æœªæ‰¾åˆ°å¿…è¦çš„åˆ—ï¼Œè·³è¿‡CAMè¡¨è§£æ');
                    break;
                }
                
                const locationValue = sheet[`${locationCol}${row}`] ? 
                    String(sheet[`${locationCol}${row}`].v).trim().toLowerCase() : '';
                const elementDescValue = sheet[`${elementDescCol}${row}`] ? 
                    String(sheet[`${elementDescCol}${row}`].v).trim() : '';
                const descriptionValue = descriptionCol && sheet[`${descriptionCol}${row}`] ? 
                    String(sheet[`${descriptionCol}${row}`].v).trim() : '';
                
                console.log(`CAMè¡¨ç¬¬${row}è¡Œ: LOCATION=${locationValue}, ElementDesc=${elementDescValue}`);
                
                if (locationValue === 'front') {
                    // Front Camera - ä½¿ç”¨Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                    cameraSpecs['Front Camera'] = {
                        value: elementDescValue,  // æ˜¾ç¤ºElement Descåˆ—çš„å€¼
                        cell: `${elementDescCol}${row}`,
                        technicalValue: descriptionValue || elementDescValue  // æŠ€æœ¯å‚æ•°å€¼
                    };
                    console.log('æ‰¾åˆ°Front Camera:', cameraSpecs['Front Camera']);
                    
                } else if (locationValue === 'back') {
                    // Back Camera - ä½¿ç”¨Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                    cameraSpecs['Back Camera'] = {
                        value: elementDescValue,  // æ˜¾ç¤ºElement Descåˆ—çš„å€¼
                        cell: `${elementDescCol}${row}`,
                        technicalValue: descriptionValue || elementDescValue  // æŠ€æœ¯å‚æ•°å€¼
                    };
                    // ä¹Ÿæ·»åŠ Backåˆ«å
                    cameraSpecs['Back'] = cameraSpecs['Back Camera'];
                    console.log('æ‰¾åˆ°Back Camera:', cameraSpecs['Back Camera']);
                }
            }
            
            return cameraSpecs;
        }

        function extractWirelessSpecs(sheet) {
            const wirelessSpecs = {};
            
            if (!sheet) {
                return wirelessSpecs;
            }
            
            // æ‰¾åˆ°å…³é”®åˆ—çš„ä½ç½®
            let wsTypeCol = null;
            let elementDescCol = null;
            let wsOnPlanACol = null;
            let wsStandardCol = null;
            
            // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheet[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    if (headerValue === 'WSTYPE') wsTypeCol = colLetter;
                    if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC' || headerValue === 'IELEMENT_DESC') elementDescCol = colLetter;
                    if (headerValue === 'WSONPLANA') wsOnPlanACol = colLetter;
                    if (headerValue === 'WSSTANDARD') wsStandardCol = colLetter;
                }
            }
            
            // éå†æ•°æ®è¡Œ
            for (let row = 2; row <= 20; row++) {
                if (!wsTypeCol || !elementDescCol) {
                    break;
                }
                
                const wsTypeValue = sheet[`${wsTypeCol}${row}`] ? String(sheet[`${wsTypeCol}${row}`].v).trim().toUpperCase() : '';
                const elementDescValue = sheet[`${elementDescCol}${row}`] ? String(sheet[`${elementDescCol}${row}`].v).trim() : '';
                
                if (wsTypeValue === 'WLAN') {
                    // Wireless - ä½¿ç”¨Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                    const wsOnPlanAValue = wsOnPlanACol && sheet[`${wsOnPlanACol}${row}`] ? 
                        String(sheet[`${wsOnPlanACol}${row}`].v).trim() : '';
                    
                    wirelessSpecs['Wireless'] = {
                        value: elementDescValue,  // æ˜¾ç¤ºElement Descåˆ—çš„å€¼
                        cell: `${elementDescCol}${row}`,
                        technicalValue: wsOnPlanAValue  // æŠ€æœ¯å‚æ•°å€¼ï¼Œç”¨äºæ£€éªŒ
                    };
                    
                } else if (wsTypeValue === 'PAN') {
                    // Bluetooth - ä½¿ç”¨Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                    const wsStandardValue = wsStandardCol && sheet[`${wsStandardCol}${row}`] ? 
                        String(sheet[`${wsStandardCol}${row}`].v).trim() : '';
                    
                    wirelessSpecs['Bluetooth'] = {
                        value: elementDescValue,  // æ˜¾ç¤ºElement Descåˆ—çš„å€¼
                        cell: `${elementDescCol}${row}`,
                        technicalValue: wsStandardValue  // æŠ€æœ¯å‚æ•°å€¼ï¼Œç”¨äºæ£€éªŒ
                    };
                }
            }
            
            return wirelessSpecs;
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°†åˆ—å·è½¬æ¢ä¸ºåˆ—å­—æ¯
        function getColumnLetter(col) {
            let letter = '';
            while (col > 0) {
                const remainder = (col - 1) % 26;
                letter = String.fromCharCode(65 + remainder) + letter;
                col = Math.floor((col - 1) / 26);
            }
            return letter;
        }

        function matchTechSpecs(baselineSpecs, testSpecs, sheetPP, cameraSpecs, wirelessSpecs, sheetWS, sheetPOR, sheetPRC, sheetMEM, sheetHD, testWorkbook, productInfo, sheetOS, sheetGRA, sheetAUD, sheetWAR, sheetPORT, sheetSEC, sheetMM, sheetMON) {
            const results = [];
            
            // éå†åŸºå‡†è§„æ ¼
            Object.keys(baselineSpecs).forEach(attrName => {
                const baselineSpec = baselineSpecs[attrName];
                const abbreviation = techSpecMapping[attrName];
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // è·³è¿‡What's in the boxï¼Œå› ä¸ºä¼šåœ¨æœ€åå¤„ç†
                if (attrName === 'What\'s in the box') {
                    return;
                }
                
                // å¤„ç†Cameraç‰¹æ®Šæƒ…å†µ
                if ((attrName === 'Front Camera' || attrName === 'Back Camera' || attrName === 'Back') && cameraSpecs) {
                    if (cameraSpecs[attrName]) {
                        testSpec = cameraSpecs[attrName];  // ä½¿ç”¨CAMè¡¨çš„Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                        isMatched = true;
                        
                        // ä½¿ç”¨æŠ€æœ¯å‚æ•°å€¼è¿›è¡Œæ£€éªŒ
                        const technicalValue = cameraSpecs[attrName].technicalValue || cameraSpecs[attrName].value;
                        
                        // Cameraæ£€éªŒï¼šä¼ é€’æŠ€æœ¯å‚æ•°å€¼å’ŒElement Descå€¼ï¼ˆç”¨äºMBGæ£€æŸ¥ï¼‰
                        checkResult = checkCamera(baselineSpec.value, technicalValue, cameraSpecs[attrName].value);
                    } else {
                        checkResult = { isValid: false, message: `æœªåœ¨CAMå·¥ä½œè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„${attrName}æ•°æ®` };
                    }
                // å¤„ç†Bluetoothå’ŒWirelessç‰¹æ®Šæƒ…å†µ
                } else if ((attrName === 'Bluetooth' || attrName === 'Wireless') && wirelessSpecs) {
                    if (wirelessSpecs[attrName]) {
                        testSpec = wirelessSpecs[attrName];  // ä½¿ç”¨WSè¡¨çš„Element Descåˆ—ä½œä¸ºæ˜¾ç¤ºå€¼
                        isMatched = true;
                        
                        // ä½¿ç”¨æŠ€æœ¯å‚æ•°å€¼è¿›è¡Œæ£€éªŒ
                        const technicalValue = wirelessSpecs[attrName].technicalValue || wirelessSpecs[attrName].value;
                        
                        if (attrName === 'Bluetooth') {
                            // Bluetoothæ£€éªŒï¼šä¼ é€’æŠ€æœ¯å‚æ•°å€¼å’ŒElement Descå€¼ï¼ˆç”¨äºMBGæ£€æŸ¥ï¼‰
                            checkResult = checkBluetooth(baselineSpec.value, technicalValue, wirelessSpecs[attrName].value);
                        } else {
                            // Wirelessæ£€éªŒ
                            if (sheetWS) {
                                checkResult = checkWireless(baselineSpec.value, sheetWS);
                            } else {
                                checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°WSå·¥ä½œè¡¨' };
                            }
                        }
                    } else {
                        checkResult = { isValid: false, message: 'æœªåœ¨WSå·¥ä½œè¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„Bluetooth/Wirelessæ•°æ®' };
                    }
                } else if (attrName === 'Color' || attrName.includes('Color')) {
                    if (sheetPP) {
                        checkResult = checkColor(baselineSpec.value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : 'æœªæ‰¾åˆ°',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡ŒColoræ£€éªŒ' };
                    }
                } else if (abbreviation && testSpecs[abbreviation]) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªç›¸åŒç±»å‹çš„è§„æ ¼
                    const specData = testSpecs[abbreviation];
                    const isMultipleSpecs = Array.isArray(specData);
                    
                    if (isMultipleSpecs) {
                        // æœ‰å¤šä¸ªç›¸åŒç±»å‹çš„è§„æ ¼,åˆå¹¶æ˜¾ç¤º
                        testSpec = {
                            value: specData.map((s, idx) => `[${idx + 1}] ${s.value}`).join('\n'),
                            cell: specData.map((s, idx) => `[${idx + 1}] ${s.cell}`).join(', '),
                            isMultiple: true,
                            specs: specData
                        };
                    } else {
                        testSpec = specData;
                    }
                    isMatched = true;
                    
                    // å¯¹Weightã€Dimensionå’ŒProcessorè¿›è¡Œç‰¹æ®Šæ£€éªŒ
                    if (attrName === 'Weight' || attrName.includes('Weight')) {
                        if (sheetPP) {
                            checkResult = checkWeight(baselineSpec.value, sheetPP);
                            // æ›´æ–°testSpecä¸ºå®é™…çš„weightæ•°æ®ï¼Œè€Œä¸æ˜¯dimensionæ•°æ®
                            if (checkResult.isValid && checkResult.ppRows) {
                                // å¤šä¸ªPPçš„æƒ…å†µ
                                const weightDisplay = checkResult.ppRows.map(p => 
                                    `${p.state} (Z${p.row}): ${p.weight}`
                                ).join(', ');
                                testSpec = {
                                    value: weightDisplay,
                                    cell: 'PPå·¥ä½œè¡¨',
                                    rawData: checkResult.ppRows
                                };
                            } else if (checkResult.isValid) {
                                // å•ä¸ªPPçš„æƒ…å†µï¼ˆå‘åå…¼å®¹ï¼‰
                                testSpec = {
                                    value: checkResult.ppCells || `${checkResult.testValue}kg`,
                                    cell: 'PPå·¥ä½œè¡¨'
                                };
                            }
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œé‡é‡æ£€éªŒ' };
                        }
                    } else if (attrName === 'Dimension' || attrName.includes('Dimension')) {
                        if (sheetPP) {
                            checkResult = checkDimension(baselineSpec.value, sheetPP);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå°ºå¯¸æ£€éªŒ' };
                        }
                    } else if (attrName === 'Processor' || attrName.includes('Processor')) {
                        if (sheetPRC) {
                            checkResult = checkProcessor(baselineSpec.value, sheetPRC);
                            // æ ‡è®°ä¸ºå·²åŒ¹é…ï¼Œå› ä¸ºæˆ‘ä»¬æœ‰ä¸“é—¨çš„PRCå·¥ä½œè¡¨æ£€éªŒ
                            isMatched = true;
                            testSpec = {
                                value: testSpec.value, // ä½¿ç”¨OBJECT-ELEMENTä¸­PRCçš„å€¼
                                cell: testSpec.cell
                            };
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PRCå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå¤„ç†å™¨æ£€éªŒ' };
                        }
                    } else if (attrName === 'OS' || attrName.includes('OS')) {
                        if (sheetOS) {
                            checkResult = checkOS(baselineSpec.value, sheetOS);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°OSå·¥ä½œè¡¨' };
                        }
                    }else if (attrName === 'Display' || attrName.includes('Display')) {
                        if (sheetMON) {
                            checkResult = checkDisplay(baselineSpec.value, sheetMON);
                        } else {
                            checkResult = {isValid: false, message: 'æœªæ‰¾åˆ°MONå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡ŒDisplayæ£€éªŒ'};
                        }
                    } else if (attrName === 'Storage' || attrName.includes('Storage')) {
                        if (sheetHD) {
                            checkResult = checkStorage(baselineSpec.value, sheetHD);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°HDå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå­˜å‚¨æ£€éªŒ' };
                        }
                    } else if (attrName === 'Memory' || attrName.includes('Memory')) {
                        if (sheetMEM) {
                            checkResult = checkMemory(baselineSpec.value, sheetMEM);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°MEMå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡Œå†…å­˜æ£€éªŒ' };
                        }
                    } else if (attrName === 'Graphics' || attrName.includes('Graphics')) {
                        if (sheetGRA) {
                            checkResult = checkGraphics(baselineSpec.value, sheetGRA);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°GRAå·¥ä½œè¡¨' };
                        }
                    } else if (attrName === 'Battery Life' || attrName.includes('Battery Life')) {
                        // è·å–æµ‹è¯•æ–‡ä»¶çš„TIå·¥ä½œè¡¨
                        if (testWorkbook && testWorkbook.Sheets && testWorkbook.Sheets['TI']) {
                            const testSheetTI = testWorkbook.Sheets['TI'];
                            checkResult = checkBatteryLife(baselineSpec.value, testSheetTI);
                            
                            // æ›´æ–°testSpecä»¥æ˜¾ç¤ºE2å’ŒF2çš„å€¼
                            if (checkResult.isValid) {
                                testSpec = {
                                    value: `E2: ${checkResult.e2Value || 'æœªæ‰¾åˆ°'} | F2: ${checkResult.f2Value || 'æœªæ‰¾åˆ°'}`,
                                    cell: 'TI E2, F2'
                                };
                                isMatched = checkResult.isMatch;
                            } else {
                                isMatched = false;
                            }
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°TIå·¥ä½œè¡¨ï¼Œæ— æ³•è¿›è¡ŒBattery Lifeæ£€éªŒ' };
                            isMatched = false;
                        }
                    } else if (attrName === 'Port' || attrName.includes('Port')) {
                        if (sheetPORT) {
                            checkResult = checkPort(baselineSpec.value, sheetPORT);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°PORTå·¥ä½œè¡¨' };
                        }
                    } else if (attrName === 'Audio' || attrName.includes('Audio')) {
                        if (sheetAUD) {
                            checkResult = checkAudio(baselineSpec.value, sheetAUD);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°AUDå·¥ä½œè¡¨' };
                        }
                    } else if (attrName === 'Fingerprint Reader' || attrName.includes('Fingerprint Reader')) {
                        if (sheetSEC) {
                            checkResult = checkFingerprintReader(baselineSpec.value, sheetSEC);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°SECå·¥ä½œè¡¨' };
                        }
                    } else if (attrName === 'Warranty' || attrName.includes('Warranty')) {
                        if (sheetWAR) {
                            checkResult = checkWarranty(baselineSpec.value, sheetWAR);
                        } else {
                            checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°WARå·¥ä½œè¡¨' };
                        }
                    } else if (attrName === 'IMG' || attrName.includes('IMG')) {
                        checkResult = checkIMG(baselineSpec.value, testSpec.value, sheetPOR, productInfo.partNumber);
                    }
                }
                
                results.push({
                    attribute: attrName,
                    abbreviation: abbreviation || 'æœªæ˜ å°„',
                    baselineValue: baselineSpec.value,
                    baselineCell: baselineSpec.cell,
                    testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            });
            
        // æœ€åæ·»åŠ What's in the boxçš„å¤„ç†ï¼ˆå³ä½¿ä¸åœ¨åŸºå‡†è§„æ ¼ä¸­ï¼‰
        if (sheetPOR) {
            const n2Cell = sheetPOR['N2'];
            if (n2Cell) {
                const n2Value = String(n2Cell.v || '').trim();
                const abbreviation = 'MM';
                
                let testSpec = null;
                let isMatched = false;
                let checkResult = null;
                
                // è·å–æµ‹è¯•å€¼ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰
                const testValue = testSpecs[abbreviation] ? testSpecs[abbreviation].value : null;
                
                // æ— è®ºæµ‹è¯•å€¼æ˜¯å¦å­˜åœ¨ï¼Œéƒ½è°ƒç”¨æ£€éªŒå‡½æ•°
                if (sheetMM) {
                    checkResult = checkWhatsInTheBox(n2Value, sheetMM);
                } else {
                    checkResult = { isValid: false, message: 'æœªæ‰¾åˆ°MMå·¥ä½œè¡¨' };
                }
                
                // æ ¹æ®æ£€éªŒç»“æœåˆ¤æ–­æ˜¯å¦åŒ¹é…
                if (checkResult.isValid && checkResult.isMatch) {
                    isMatched = true;
                    testSpec = testSpecs[abbreviation] || null;
                } else {
                    isMatched = false;
                    testSpec = testSpecs[abbreviation] || null;
                }
                
                results.push({
                    attribute: 'What\'s in the box',
                    abbreviation: 'MM',
                    baselineValue: n2Value,
                    baselineCell: 'POR N2',
                    testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                    testCell: testSpec ? testSpec.cell : '-',
                    isMatched: isMatched,
                    checkResult: checkResult
                });
            }
                    
                // æ·»åŠ Colorçš„å¤„ç†ï¼ˆä»POR M2è¯»å–åŸºå‡†å€¼ï¼Œä¸PP T2æ¯”è¾ƒï¼‰
                const m2Cell = sheetPOR['M2'];
                if (m2Cell && sheetPP) {
                    const m2Value = String(m2Cell.v || '').trim();
                    
                    let testSpec = null;
                    let isMatched = false;
                    let checkResult = null;
                    
                    if (m2Value) {
                        checkResult = checkColor(m2Value, sheetPP);
                        isMatched = true;
                        testSpec = {
                            value: sheetPP['T2'] ? String(sheetPP['T2'].v || '').trim() : 'æœªæ‰¾åˆ°',
                            cell: 'PP T2'
                        };
                    } else {
                        checkResult = { isValid: false, message: 'POR M2å•å…ƒæ ¼ä¸ºç©º' };
                    }
                    
                    results.push({
                        attribute: 'Color',
                        abbreviation: 'COLOR',
                        baselineValue: m2Value,
                        baselineCell: 'POR M2',
                        testValue: testSpec ? testSpec.value : 'æœªæ‰¾åˆ°',
                        testCell: testSpec ? testSpec.cell : '-',
                        isMatched: isMatched,
                        checkResult: checkResult
                    });
                }
            }
            
            // æ·»åŠ IMGçš„å¤„ç†ï¼ˆä»PORè¡¨è¯»å–Colorä½œä¸ºåŸºå‡†å€¼ï¼‰
            let imgBaselineValue = '(æœªæ‰¾åˆ°)';
            let imgBaselineCell = '-';

            // ä»PORè¡¨ä¸­è¯»å–Colorä½œä¸ºåŸºå‡†å€¼
            if (sheetPOR) {
                // æŸ¥æ‰¾å½“å‰äº§å“çš„Part Numberå¯¹åº”çš„è¡Œ
                let porRow = null;
                let row = 2;
                
                while (row <= 1000) {
                    const bCell = `B${row}`;
                    const partNumber = sheetPOR[bCell] ? String(sheetPOR[bCell].v).trim() : '';
                    
                    if (!partNumber) {
                        break;
                    }
                    
                    if (partNumber === productInfo.partNumber) {
                        porRow = row;
                        break;
                    }
                    
                    row++;
                }
                
                // å¦‚æœæ‰¾åˆ°å¯¹åº”è¡Œï¼Œè¯»å–Måˆ—çš„Colorå€¼
                if (porRow) {
                    const mCell = `M${porRow}`;
                    const colorValue = sheetPOR[mCell] ? String(sheetPOR[mCell].v).trim() : '';
                    if (colorValue) {
                        imgBaselineValue = colorValue;
                        imgBaselineCell = mCell;
                    }
                }
            }

            // æ£€æŸ¥IMG
            if (testSpecs['IMG']) {
                const testSpec = testSpecs['IMG'];
                const checkResult = checkIMG(imgBaselineValue, testSpec.value);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: testSpec.value,
                    testCell: testSpec.cell,
                    isMatched: checkResult.isValid && checkResult.isMatch,
                    checkResult: checkResult
                });
            } else {
                // å¦‚æœæµ‹è¯•è¡¨ä¸­æ²¡æœ‰IMGï¼Œæ·»åŠ å¤±è´¥è®°å½•
                const checkResult = checkIMG(imgBaselineValue, null);
                
                results.push({
                    attribute: 'IMG',
                    abbreviation: 'IMG',
                    baselineValue: imgBaselineValue,
                    baselineCell: imgBaselineCell,
                    testValue: 'æœªæ‰¾åˆ°',
                    testCell: '-',
                    isMatched: false,
                    checkResult: checkResult
                });
            }
            
            return results;
        }

        function checkWeight(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†é‡é‡æ•°æ®' };
                }

                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }

                // ä»åŸºå‡†å€¼ä¸­æå–é‡é‡æ•°å­—ï¼ˆå•ä½ï¼šå…‹ï¼‰
                const weightMatch = String(baselineValue).match(/(\d+(?:\.\d+)?)g/i);
                if (!weightMatch) {
                    return { isValid: false, message: 'åŸºå‡†å€¼æ ¼å¼æ— æ•ˆï¼Œéœ€è¦åŒ…å«"g"å•ä½' };
                }

                // è½¬æ¢ä¸ºåƒå…‹ï¼Œå¹¶ä¿ç•™ 6 ä½å°æ•°ï¼ˆé¿å…æµ®ç‚¹è¯¯å·®ï¼‰
                const weightInGrams = parseFloat(weightMatch[1]);
                const weightInKg = parseFloat((weightInGrams / 1000).toFixed(6));

                // 1. æŸ¥æ‰¾æ‰€æœ‰PPè¡Œï¼ˆä¸checkColoré€»è¾‘ä¸€è‡´ï¼‰
                const ppRows = [];
                for (let row = 2; row <= 50; row++) {
                    const bCell = sheetPP[`B${row}`]; // Element Descåˆ—
                    if (!bCell || !bCell.v) continue;
                    
                    const desc = String(bCell.v);
                    const descLower = desc.toLowerCase();
                    
                    // æ£€æŸ¥æ˜¯å¦åŒ…å«MBGï¼ˆMotorola Business Groupæ ‡è¯†ï¼‰
                    if (descLower.includes('mbg')) {
                        const zCell = sheetPP[`Z${row}`]; // WEIGHT_METåˆ—
                        let weightValue = '';
                        let weightInKgTest = null;
                        
                        if (zCell && zCell.v) {
                            const testWeightValue = zCell.v;
                            
                            if (typeof testWeightValue === 'number') {
                                weightInKgTest = parseFloat(testWeightValue.toFixed(6));
                                weightValue = `${weightInKgTest.toFixed(6)}kg`;
                            } else {
                                const testWeightMatch = String(testWeightValue).match(/(\d+(?:\.\d+)?)/);
                                if (testWeightMatch) {
                                    weightInKgTest = parseFloat(parseFloat(testWeightMatch[1]).toFixed(6));
                                    weightValue = `${weightInKgTest.toFixed(6)}kg`;
                                }
                            }
                        }
                        
                        // åˆ¤æ–­çŠ¶æ€ï¼šOpen / Closed / Standard
                        let state = 'Standard';
                        if (descLower.includes('open')) {
                            state = 'Open';
                        } else if (descLower.includes('closed') || descLower.includes('close')) {
                            state = 'Closed';
                        }
                        
                        ppRows.push({
                            row: row,
                            state: state,
                            desc: desc.substring(0, 60) + (desc.length > 60 ? '...' : ''),
                            weight: weightValue,
                            weightInKg: weightInKgTest
                        });
                    }
                }
                
                if (ppRows.length === 0) {
                    return { isValid: false, message: 'PPå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°PPæ•°æ®ï¼ˆç¼ºå°‘åŒ…å«MBGçš„è¡Œï¼‰' };
                }

                console.log(`æ‰¾åˆ°${ppRows.length}ä¸ªPPçš„é‡é‡æ•°æ®:`, ppRows);

                // 2. æ£€æŸ¥æ¯ä¸ªPPçš„é‡é‡
                const results = [];
                let allMatch = true;
                const tolerance = 0;
                
                for (const ppRow of ppRows) {
                    if (ppRow.weightInKg === null) {
                        // æ²¡æœ‰é‡é‡æ•°æ®
                        results.push({
                            row: ppRow.row,
                            state: ppRow.state,
                            weight: '(æœªæ‰¾åˆ°)',
                            isMatch: false,
                            error: 'ç¼ºå°‘é‡é‡æ•°æ®'
                        });
                        allMatch = false;
                    } else {
                        const difference = parseFloat(Math.abs(weightInKg - ppRow.weightInKg).toFixed(6));
                        const isMatch = difference <= tolerance;
                        
                        if (!isMatch) allMatch = false;
                        
                        results.push({
                            row: ppRow.row,
                            state: ppRow.state,
                            weight: ppRow.weight,
                            weightInKg: ppRow.weightInKg,
                            isMatch: isMatch,
                            difference: difference
                        });
                    }
                }

                // 3. ç”Ÿæˆæ£€éªŒç»“æœæ¶ˆæ¯
                let message = '';
                let ppCellsInfo = '';
                
                if (allMatch) {
                    if (ppRows.length === 1) {
                        message = 'é‡é‡åŒ¹é…';
                        ppCellsInfo = `Z${ppRows[0].row}: ${ppRows[0].weight}`;
                    } else {
                        message = `æ‰€æœ‰PPçš„é‡é‡éƒ½åŒ¹é… (å…±${ppRows.length}ä¸ªPP)`;
                        ppCellsInfo = ppRows.map(p => `${p.state} (Z${p.row}): ${p.weight} âœ“`).join(', ');
                    }
                } else {
                    const failedPPs = results.filter(r => !r.isMatch);
                    const passedPPs = results.filter(r => r.isMatch);
                    
                    message = `éƒ¨åˆ†PPçš„é‡é‡ä¸åŒ¹é…:\n`;
                    message += `  âœ“ é€šè¿‡ (${passedPPs.length}ä¸ª): ${passedPPs.map(p => p.state).join(', ')}\n`;
                    message += `  âœ— å¤±è´¥ (${failedPPs.length}ä¸ª):\n`;
                    failedPPs.forEach(pp => {
                        if (pp.error) {
                            message += `    - ${pp.state} (è¡Œ${pp.row}): ${pp.error}\n`;
                        } else {
                            message += `    - ${pp.state} (è¡Œ${pp.row}): ${pp.weight} (å·®å€¼: ${pp.difference.toFixed(6)}kg)\n`;
                        }
                    });
                    
                    ppCellsInfo = ppRows.map((p, idx) => {
                        const result = results[idx];
                        const status = result.isMatch ? 'âœ“' : 'âœ—';
                        return `${status} ${p.state} (Z${p.row}): ${p.weight}`;
                    }).join(', ');
                }

                return {
                    isValid: true,
                    isMatch: allMatch,
                    convertedValue: weightInKg.toFixed(6),
                    message: message,
                    ppRows: results,
                    ppCells: ppCellsInfo
                };

            } catch (error) {
                console.error('é‡é‡æ£€éªŒé”™è¯¯:', error);
                return { isValid: false, message: `é‡é‡æ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }


        // å°ºå¯¸æ£€éªŒå‡½æ•°
        function checkDimension(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†å°ºå¯¸æ•°æ®' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue);
                console.log('åŸå§‹åŸºå‡†å°ºå¯¸å€¼:', baselineStr);
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«Openå’ŒClosedçŠ¶æ€
                const hasOpenClosed = /open|closed/i.test(baselineStr);
                
                if (hasOpenClosed) {
                    return checkFoldableDimensionWithPPData(baselineStr, sheetPP);
                } else {
                    return checkStandardDimensionWithPPData(baselineStr, sheetPP);
                }
                
            } catch (error) {
                return { isValid: false, message: `å°ºå¯¸æ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }
        
        function checkStandardDimensionWithPPData(baselineStr, sheetPP) {
            console.log('ä½¿ç”¨PPæ•°æ®å¤„ç†æ ‡å‡†è®¾å¤‡å°ºå¯¸');
            
            // é¦–å…ˆä»PPå·¥ä½œè¡¨æå–æ•°æ®
            const ppRawData = extractPPDimensionData(sheetPP);
            console.log('æå–çš„PPæ•°æ®:', ppRawData);
            
            // æå–åŸºå‡†å€¼ä¸­çš„å°ºå¯¸ - å‡è®¾æ ¼å¼æ˜¯ Height x Width x Depth
            const dimensionMatch = baselineStr.match(/(\d+(?:\.\d+)?)\s*[xXÃ—]\s*(\d+(?:\.\d+)?)\s*[xXÃ—]\s*(\d+(?:\.\d+)?)/);
            
            if (!dimensionMatch) {
                return { isValid: false, message: 'åŸºå‡†å€¼æ ¼å¼æ— æ•ˆï¼Œæ— æ³•æå–å°ºå¯¸' };
            }
            
            const baselineDims = {
                height: parseFloat(dimensionMatch[1]),
                width: parseFloat(dimensionMatch[2]),
                depth: parseFloat(dimensionMatch[3])
            };
            
            console.log('åŸºå‡†å°ºå¯¸:', baselineDims);
            console.log('PPæ•°æ®:', ppRawData.standard);
            
            // æ£€æŸ¥æ˜¯å¦æˆåŠŸæå–äº†standardæ•°æ®
            if (!ppRawData.standard) {
                return { 
                    isValid: false, 
                    message: 'æœªèƒ½ä»PPå·¥ä½œè¡¨æå–æ ‡å‡†è®¾å¤‡å°ºå¯¸æ•°æ®' 
                };
            }
            
            const result = compareDimensionsDetailed(baselineDims, ppRawData.standard, 'Standard');
            
            return {
                isValid: true,
                isMatch: result.isMatch,
                message: result.detailMessage || result.message,
                baseline: baselineDims,
                ppData: ppRawData.standard,
                heightMatch: result.heightMatch,
                widthMatch: result.widthMatch,
                depthMatch: result.depthMatch
            };
        }
        
        function checkFoldableDimensionWithPPData(baselineStr, sheetPP) {
            console.log('ä½¿ç”¨PPæ•°æ®å¤„ç†æŠ˜å è®¾å¤‡å°ºå¯¸');
            console.log('åŸºå‡†å­—ç¬¦ä¸²:', baselineStr);
            
            // é¦–å…ˆä»PPå·¥ä½œè¡¨æå–æ•°æ®
            const ppRawData = extractPPDimensionData(sheetPP);
            console.log('æå–çš„PPåŸå§‹æ•°æ®:', ppRawData);

            // å·¥å…·:ä»PPæ•°æ®å¯¹è±¡ä¸­æå–ä¸‰ä¸ªå°ºå¯¸å€¼å¹¶æ’åº
            function extractPPDimensions(ppDataObj) {
                if (!ppDataObj) return null;
                const dims = [ppDataObj.height, ppDataObj.width, ppDataObj.depth].filter(d => d !== null);
                return dims.length === 3 ? dims.sort((a, b) => a - b) : null;
            }

            // è§£æåŸºå‡†å€¼ - æ ¼å¼: "Open 73.99 x 171.30 x 7.25mm Closed 88.08 x 73.99 x 15.85mm"
            // æå–Openéƒ¨åˆ†çš„ä¸‰ä¸ªæ•°å­—
            const openPattern = /open\s+([\d.]+)\s*x\s*([\d.]+)\s*x\s*([\d.]+)\s*mm/i;
            // æå–Closedéƒ¨åˆ†çš„ä¸‰ä¸ªæ•°å­—
            const closedPattern = /closed\s+([\d.]+)\s*x\s*([\d.]+)\s*x\s*([\d.]+)\s*mm/i;

            const openMatch = baselineStr.match(openPattern);
            const closedMatch = baselineStr.match(closedPattern);

            console.log('OpenåŒ¹é…ç»“æœ:', openMatch);
            console.log('ClosedåŒ¹é…ç»“æœ:', closedMatch);

            let results = [];
            let allMatch = true;

            // ========== å¤„ç† Open ==========
            if (openMatch) {
                if (ppRawData.open) {
                    // åŸºå‡†å€¼çš„ä¸‰ä¸ªå°ºå¯¸(æ’åºå)
                    const baseOpenDims = [
                        parseFloat(openMatch[1]),
                        parseFloat(openMatch[2]),
                        parseFloat(openMatch[3])
                    ].sort((a, b) => a - b);

                    // PPæ•°æ®çš„ä¸‰ä¸ªå°ºå¯¸(æ’åºå)
                    const ppOpenDims = extractPPDimensions(ppRawData.open);

                    console.log('OpenåŸºå‡†å°ºå¯¸(æ’åº):', baseOpenDims);
                    console.log('Open PPå°ºå¯¸(æ’åº):', ppOpenDims);

                    if (ppOpenDims) {
                        const isMatch = baseOpenDims.length === ppOpenDims.length &&
                                      baseOpenDims.every((val, idx) => Math.abs(val - ppOpenDims[idx]) < 0.01);

                        results.push({
                            state: 'Open',
                            isMatch: isMatch,
                            detailMessage: isMatch
                                ? `OpenåŒ¹é… (${baseOpenDims.join(' Ã— ')}mm)`
                                : `Openä¸åŒ¹é… (åŸºå‡†: ${baseOpenDims.join(' Ã— ')}, PP: ${ppOpenDims.join(' Ã— ')})`,
                            baseline: baseOpenDims,
                            pp: ppOpenDims
                        });

                        if (!isMatch) allMatch = false;
                    } else {
                        results.push({
                            state: 'Open',
                            isMatch: false,
                            detailMessage: 'Open PPæ•°æ®ä¸å®Œæ•´'
                        });
                        allMatch = false;
                    }
                } else {
                    results.push({
                        state: 'Open',
                        isMatch: false,
                        detailMessage: 'æµ‹è¯•æ•°æ®ä¸­æœªæ‰¾åˆ°Openå°ºå¯¸'
                    });
                    allMatch = false;
                }
            }

            // ========== å¤„ç† Closed ==========
            if (closedMatch) {
                if (ppRawData.closed) {
                    // åŸºå‡†å€¼çš„ä¸‰ä¸ªå°ºå¯¸(æ’åºå)
                    const baseClosedDims = [
                        parseFloat(closedMatch[1]),
                        parseFloat(closedMatch[2]),
                        parseFloat(closedMatch[3])
                    ].sort((a, b) => a - b);

                    // PPæ•°æ®çš„ä¸‰ä¸ªå°ºå¯¸(æ’åºå)
                    const ppClosedDims = extractPPDimensions(ppRawData.closed);

                    console.log('ClosedåŸºå‡†å°ºå¯¸(æ’åº):', baseClosedDims);
                    console.log('Closed PPå°ºå¯¸(æ’åº):', ppClosedDims);

                    if (ppClosedDims) {
                        const isMatch = baseClosedDims.length === ppClosedDims.length &&
                                      baseClosedDims.every((val, idx) => Math.abs(val - ppClosedDims[idx]) < 0.01);

                        results.push({
                            state: 'Closed',
                            isMatch: isMatch,
                            detailMessage: isMatch
                                ? `ClosedåŒ¹é… (${baseClosedDims.join(' Ã— ')}mm)`
                                : `Closedä¸åŒ¹é… (åŸºå‡†: ${baseClosedDims.join(' Ã— ')}, PP: ${ppClosedDims.join(' Ã— ')})`,
                            baseline: baseClosedDims,
                            pp: ppClosedDims
                        });

                        if (!isMatch) allMatch = false;
                    } else {
                        results.push({
                            state: 'Closed',
                            isMatch: false,
                            detailMessage: 'Closed PPæ•°æ®ä¸å®Œæ•´'
                        });
                        allMatch = false;
                    }
                } else {
                    results.push({
                        state: 'Closed',
                        isMatch: false,
                        detailMessage: 'æµ‹è¯•æ•°æ®ä¸­æœªæ‰¾åˆ°Closedå°ºå¯¸'
                    });
                    allMatch = false;
                }
            }

            // ========== æ±‡æ€»æ¶ˆæ¯ ==========
                let message = '';
                if (allMatch && results.length > 0) {
                    message = 'æŠ˜å è®¾å¤‡å°ºå¯¸å…¨éƒ¨åŒ¹é…: ' + results.map(r => r.detailMessage).join('; ');
                } else {
                    const failures = results.filter(r => !r.isMatch);
                    // if (failures.length > 0) {
                    //    message = 'æŠ˜å è®¾å¤‡å°ºå¯¸ä¸åŒ¹é…: ' + failures.map(r => r.detailMessage).join('; ');
                    // } else {
                    //     message = 'æœªæ‰¾åˆ°æœ‰æ•ˆçš„æŠ˜å è®¾å¤‡å°ºå¯¸æ•°æ®';
                    // }
                }

                console.log('æœ€ç»ˆæ£€éªŒç»“æœ:', { isMatch: allMatch, message, results });

                return {
                    isValid: true,
                    isMatch: allMatch,
                    message: message,
                    originalString: baselineStr,
                    results: results,
                    ppData: ppRawData
                };
            }

        // è¯¦ç»†æ¯”å¯¹å°ºå¯¸ï¼ˆé€ä¸ªæ¯”å¯¹é«˜åº¦ã€å®½åº¦ã€æ·±åº¦ï¼‰
        function compareDimensionsDetailed(baseline, ppData, state) {
            const tolerance = 0.1;
            
            console.log(`${state}çŠ¶æ€ - åŸºå‡†å€¼:`, baseline);
            console.log(`${state}çŠ¶æ€ - PPæ•°æ®:`, ppData);
            
            // é¦–å…ˆæ£€æŸ¥å•ä½
            if (!ppData.unitsValid) {
                return {
                    state: state,
                    isMatch: false,
                    message: `${state}å•ä½é”™è¯¯`,
                    detailMessage: `${state}å•ä½å¿…é¡»ä¸ºmm: HEIGHT=${ppData.heightUnit}, WIDTH=${ppData.widthUnit}, DEPTH=${ppData.depthUnit}`,
                    baseline: baseline,
                    ppData: ppData
                };
            }
            
            // é€ä¸ªæ¯”å¯¹
            const heightMatch = ppData.height !== null && Math.abs(baseline.height - ppData.height) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const depthMatch = ppData.depth !== null && Math.abs(baseline.depth - ppData.depth) <= tolerance;
            
            const allMatch = heightMatch && widthMatch && depthMatch;
            
            // ç”Ÿæˆè¯¦ç»†ä¿¡æ¯
            let details = [];
            if (!heightMatch) {
                details.push(`é«˜åº¦ä¸åŒ¹é…(åŸºå‡†${baseline.height}mm vs æµ‹è¯•${ppData.height || 'N/A'}mm)`);
            }
            if (!widthMatch) {
                details.push(`å®½åº¦ä¸åŒ¹é…(åŸºå‡†${baseline.width}mm vs æµ‹è¯•${ppData.width || 'N/A'}mm)`);
            }
            if (!depthMatch) {
                details.push(`æ·±åº¦ä¸åŒ¹é…(åŸºå‡†${baseline.depth}mm vs æµ‹è¯•${ppData.depth || 'N/A'}mm)`);
            }
            
            let message = '';
            let detailMessage = '';
            
            if (allMatch) {
                message = `${state}çŠ¶æ€å°ºå¯¸åŒ¹é…`;
                detailMessage = `${state}[H:${baseline.height}mm âœ“, W:${baseline.width}mm âœ“, D:${baseline.depth}mm âœ“]`;
            } else {
                message = `${state}çŠ¶æ€å°ºå¯¸ä¸åŒ¹é…`;
                detailMessage = `${state}[${details.join(', ')}]`;
            }
            
            return {
                state: state,
                isMatch: allMatch,
                message: message,
                detailMessage: detailMessage,
                baseline: baseline,
                ppData: ppData,
                heightMatch: heightMatch,
                widthMatch: widthMatch,
                depthMatch: depthMatch,
                ppCells: ppData.cells
            };
        }
        
        // åœ¨PPå·¥ä½œè¡¨ä¸­æŸ¥æ‰¾Open PPå’ŒClose PPæ•°æ®
        function findPPData(sheetPP) {
            const ppData = { open: null, closed: null };
            
            // æ‰«æPPå·¥ä½œè¡¨ï¼ŒæŸ¥æ‰¾åŒ…å«"Open PP"å’Œ"Close PP"çš„è¡Œ
            for (let row = 1; row <= 50; row++) {
                for (let col of ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']) {
                    const cell = sheetPP[`${col}${row}`];
                    if (cell && cell.v) {
                        const cellValue = String(cell.v).toLowerCase();
                        
                        if (cellValue.includes('open pp') || cellValue.includes('open')) {
                            // æ‰¾åˆ°Open PPï¼Œè¯»å–åŒè¡Œçš„N, AD, Iåˆ—æ•°æ®
                            ppData.open = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        } else if (cellValue.includes('close pp') || cellValue.includes('closed') || cellValue.includes('close')) {
                            // æ‰¾åˆ°Close PPï¼Œè¯»å–åŒè¡Œçš„N, AD, Iåˆ—æ•°æ®
                            ppData.closed = {
                                length: sheetPP[`N${row}`] ? extractNumber(sheetPP[`N${row}`].v) : null,
                                width: sheetPP[`AD${row}`] ? extractNumber(sheetPP[`AD${row}`].v) : null,
                                thickness: sheetPP[`I${row}`] ? extractNumber(sheetPP[`I${row}`].v) : null,
                                row: row
                            };
                        }
                    }
                }
            }
            
            return ppData;
        }
        
        // ä»å­—ç¬¦ä¸²ä¸­æå–æ•°å­—
        function extractNumber(value) {
            if (typeof value === 'number') return value;
            const match = String(value).match(/(\d+(?:\.\d+)?)/);
            return match ? parseFloat(match[1]) : null;
        }

        function extractPPDimensionData(sheetPP) {
            console.log('å¼€å§‹ä»PPå·¥ä½œè¡¨æå–å°ºå¯¸æ•°æ®');
            
            // æŸ¥æ‰¾Open PPå’ŒClose PPçš„æ•°æ®
            const ppData = { open: null, closed: null, standard: null };
            const processedRows = new Set(); // é¿å…é‡å¤å¤„ç†åŒä¸€è¡Œ
            
            // æ‰«æPPå·¥ä½œè¡¨çš„Element Descåˆ—ï¼ˆBåˆ—ï¼‰å’Œå…¶ä»–åˆ—
            for (let row = 2; row <= 50; row++) {
                if (processedRows.has(row)) continue;
                
                // æ£€æŸ¥è¯¥è¡Œæ˜¯å¦æœ‰æ•°æ®ï¼ˆé€šè¿‡æ£€æŸ¥Båˆ—çš„Element Descï¼‰
                const bCell = sheetPP[`B${row}`];
                if (!bCell || !bCell.v) continue;
                
                const desc = String(bCell.v).toLowerCase();
                
                // åœ¨PPå·¥ä½œè¡¨ä¸­ï¼Œåªéœ€æ£€æŸ¥æ˜¯å¦åŒ…å«"open"æˆ–"closed"å…³é”®è¯
                if (desc.includes('open') && !ppData.open) {
                    // æ‰¾åˆ°Open PPï¼Œè¯»å–åŒè¡Œçš„å°ºå¯¸æ•°æ®
                    ppData.open = extractDimensionFromRow(sheetPP, row, 'Open');
                    console.log(`æ‰¾åˆ°Open PPæ•°æ® (è¡Œ${row}):`, ppData.open);
                    processedRows.add(row);
                } else if ((desc.includes('closed') || desc.includes('close')) && !ppData.closed) {
                    // æ‰¾åˆ°Closed PPï¼Œè¯»å–åŒè¡Œçš„å°ºå¯¸æ•°æ®
                    ppData.closed = extractDimensionFromRow(sheetPP, row, 'Closed');
                    console.log(`æ‰¾åˆ°Closed PPæ•°æ® (è¡Œ${row}):`, ppData.closed);
                    processedRows.add(row);
                }
            }
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°Open/Closedï¼Œå°è¯•è¯»å–æ ‡å‡†è®¾å¤‡çš„æ•°æ®ï¼ˆç¬¬2è¡Œï¼‰
            if (!ppData.open && !ppData.closed) {
                ppData.standard = extractDimensionFromRow(sheetPP, 2, 'Standard');
                console.log('æå–æ ‡å‡†è®¾å¤‡æ•°æ®:', ppData.standard);
            }
            
            // ç”Ÿæˆæ˜¾ç¤ºå€¼
            let displayValue = '';
            if (ppData.open) {
                displayValue += `Open: ${ppData.open.displayText}`;
            }
            if (ppData.closed) {
                if (displayValue) displayValue += ', ';
                displayValue += `Closed: ${ppData.closed.displayText}`;
            }
            if (ppData.standard) {
                displayValue = ppData.standard.displayText;
            }
            
            return {
                displayValue: displayValue || '(æœªæ‰¾åˆ°PPæ•°æ®)',
                isFoldable: !!(ppData.open || ppData.closed),
                isStandard: !!ppData.standard,
                open: ppData.open,
                closed: ppData.closed,
                standard: ppData.standard
            };
        }

        // æ–°å¢ï¼šä»æŒ‡å®šè¡Œæå–å°ºå¯¸æ•°æ®çš„å‡½æ•°
        function extractDimensionFromRow(sheetPP, row, state) {
            // æŸ¥æ‰¾åˆ—æ ‡é¢˜æ‰€åœ¨çš„è¡Œï¼ˆé€šå¸¸æ˜¯ç¬¬1è¡Œï¼‰
            let depthCol = null, heightCol = null, widthCol = null;
            let depthUnitCol = null, heightUnitCol = null, widthUnitCol = null;
            
            // æ‰«æç¬¬1è¡Œæ‰¾åˆ°å¯¹åº”çš„åˆ—
            for (let col = 1; col <= 50; col++) {
                const colLetter = getColumnLetter(col);
                const headerCell = sheetPP[`${colLetter}1`];
                if (headerCell) {
                    const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                    
                    if (headerValue === 'DEPTH_MET' || headerValue === 'DEPTH') depthCol = colLetter;
                    if (headerValue === 'HEIGHT_MET' || headerValue === 'HEIGHT') heightCol = colLetter;
                    if (headerValue === 'WIDTH_MET' || headerValue === 'WIDTH') widthCol = colLetter;
                    if (headerValue === 'DEPTH_METUNITS' || headerValue === 'DEPTHUNITS') depthUnitCol = colLetter;
                    if (headerValue === 'HEIGHT_METUNITS' || headerValue === 'HEIGHTUNITS') heightUnitCol = colLetter;
                    if (headerValue === 'WIDTH_METUNITS' || headerValue === 'WIDTHUNITS') widthUnitCol = colLetter;
                }
            }
            
            console.log(`${state}çŠ¶æ€ - æ‰¾åˆ°çš„åˆ—:`, {
                depth: depthCol,
                height: heightCol,
                width: widthCol,
                depthUnit: depthUnitCol,
                heightUnit: heightUnitCol,
                widthUnit: widthUnitCol
            });
            
            if (!depthCol || !heightCol || !widthCol) {
                console.log(`${state}çŠ¶æ€ - æœªæ‰¾åˆ°å®Œæ•´çš„å°ºå¯¸åˆ—`);
                return null;
            }
            
            // è¯»å–æ•°æ®
            const depth = sheetPP[`${depthCol}${row}`] ? extractNumber(sheetPP[`${depthCol}${row}`].v) : null;
            const height = sheetPP[`${heightCol}${row}`] ? extractNumber(sheetPP[`${heightCol}${row}`].v) : null;
            const width = sheetPP[`${widthCol}${row}`] ? extractNumber(sheetPP[`${widthCol}${row}`].v) : null;
            
            // è¯»å–å•ä½
            const depthUnit = depthUnitCol && sheetPP[`${depthUnitCol}${row}`] ? 
                String(sheetPP[`${depthUnitCol}${row}`].v).trim().toLowerCase() : null;
            const heightUnit = heightUnitCol && sheetPP[`${heightUnitCol}${row}`] ? 
                String(sheetPP[`${heightUnitCol}${row}`].v).trim().toLowerCase() : null;
            const widthUnit = widthUnitCol && sheetPP[`${widthUnitCol}${row}`] ? 
                String(sheetPP[`${widthUnitCol}${row}`].v).trim().toLowerCase() : null;
            
            console.log(`${state}çŠ¶æ€ - æå–çš„å€¼:`, {
                depth, height, width,
                depthUnit, heightUnit, widthUnit
            });
            
            // éªŒè¯å•ä½
            const unitsValid = (!depthUnit || depthUnit === 'mm') && 
                            (!heightUnit || heightUnit === 'mm') && 
                            (!widthUnit || widthUnit === 'mm');
            
            if (!unitsValid) {
                console.warn(`${state}çŠ¶æ€ - å•ä½éªŒè¯å¤±è´¥:`, { depthUnit, heightUnit, widthUnit });
            }
            
            return {
                depth: depth,
                height: height,
                width: width,
                depthUnit: depthUnit || 'mm',
                heightUnit: heightUnit || 'mm',
                widthUnit: widthUnit || 'mm',
                unitsValid: unitsValid,
                row: row,
                displayText: `${height || '?'}mm(H) x ${width || '?'}mm(W) x ${depth || '?'}mm(D)`,
                cells: `è¡Œ${row}: HEIGHT=${height}${heightUnit || 'mm'}, WIDTH=${width}${widthUnit || 'mm'}, DEPTH=${depth}${depthUnit || 'mm'}`
            };
        }
        
        // ä»å°ºå¯¸å­—ç¬¦ä¸²ä¸­æå–é•¿å®½é«˜
        function extractDimensionsFromString(dimensionStr) {
            const match = dimensionStr.match(/(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)\s*[xÃ—]\s*(\d+(?:\.\d+)?)/i);
            if (match) {
                return {
                    length: parseFloat(match[1]),
                    width: parseFloat(match[2]),
                    thickness: parseFloat(match[3])
                };
            }
            return null;
        }
        
        // æ¯”è¾ƒåŸºå‡†å°ºå¯¸å’ŒPPæ•°æ®
        function compareDimensions(baseline, ppData, state) {
            const tolerance = 0.1;
            
            const lengthMatch = ppData.length !== null && Math.abs(baseline.length - ppData.length) <= tolerance;
            const widthMatch = ppData.width !== null && Math.abs(baseline.width - ppData.width) <= tolerance;
            const thicknessMatch = ppData.thickness !== null && Math.abs(baseline.thickness - ppData.thickness) <= tolerance;
            
            const isMatch = lengthMatch && widthMatch && thicknessMatch;
            
            let message = '';
            if (isMatch) {
                message = `${state}çŠ¶æ€å°ºå¯¸åŒ¹é…`;
            } else {
                const mismatches = [];
                if (!lengthMatch) mismatches.push(`é•¿åº¦(${baseline.length} vs ${ppData.length || 'N/A'})`);
                if (!widthMatch) mismatches.push(`å®½åº¦(${baseline.width} vs ${ppData.width || 'N/A'})`);
                if (!thicknessMatch) mismatches.push(`åšåº¦(${baseline.thickness} vs ${ppData.thickness || 'N/A'})`);
                message = `${state}çŠ¶æ€ä¸åŒ¹é…: ${mismatches.join(', ')}`;
            }
            
            return {
                state: state,
                isMatch: isMatch,
                message: message,
                baseline: baseline,
                ppData: ppData,
                ppCells: `è¡Œ${ppData.row}: N${ppData.row}=${ppData.length || 'N/A'}mm, AD${ppData.row}=${ppData.width || 'N/A'}mm, I${ppData.row}=${ppData.thickness || 'N/A'}mm`
            };
        }

        function checkProcessor(baselineValue, sheetPRC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†å¤„ç†å™¨æ•°æ®' };
                }

                if (!sheetPRC) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PRCå·¥ä½œè¡¨' };
                }

                // ä»PRCå·¥ä½œè¡¨æ‰¾åˆ°PROCESSORTYPEå’ŒPROCCLKSPDåˆ—
                let processorTypeCol = null;
                let procClkSpdCol = null;
                let procClkSpdUnitsCol = null;
                let processorTypeValue = '';
                let procClkSpdValue = '';
                let unitValue = '';
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetPRC[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'PROCESSORTYPE') {
                            processorTypeCol = colLetter;
                        }
                        if (headerValue === 'PROCCLKSPD') {
                            procClkSpdCol = colLetter;
                        } else if (headerValue === 'PROCCLKSPDUNITS') {
                            procClkSpdUnitsCol = colLetter;
                        }
                    }
                }
                
                // æ£€æŸ¥PROCCLKSPDUNITSåˆ—çš„å€¼å¿…é¡»æ˜¯GHz
                if (procClkSpdUnitsCol) {
                    for (let row = 2; row <= 1000; row++) {
                        const cellRef = `${procClkSpdUnitsCol}${row}`;
                        const cell = sheetPRC[cellRef];
                        if (cell && cell.v) {
                            // ç»™å¤–å±‚ unitValue èµ‹å€¼ï¼Œç»Ÿä¸€ä¸ºå¤§å†™æ¯”è¾ƒï¼Œå»æ‰é‡å¤æ£€æŸ¥
                            unitValue = String(cell.v).trim();
                            if (unitValue !== 'GHz') {
                               return { isValid: false, message: `ç¬¬${row}è¡ŒPROCCLKSPDUNITSå€¼"${cell.v}"æ— æ•ˆï¼Œå¿…é¡»æ˜¯GHz` };
                            }
                        } else {
                            // åˆ°è¾¾ç©ºè¡Œï¼Œåœæ­¢æ£€æŸ¥
                            break;
                        }
                    }
                }

                if (!processorTypeCol) {
                    return { isValid: false, message: 'PRCå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°PROCESSORTYPEåˆ—' };
                }
                
                // è¯»å–PROCESSORTYPEåˆ—çš„ç¬¬2è¡Œæ•°æ®
                const processorCell = sheetPRC[`${processorTypeCol}2`];
                if (!processorCell) {
                    return { isValid: false, message: `PRCå·¥ä½œè¡¨${processorTypeCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                processorTypeValue = String(processorCell.v).trim();
                
                if (!processorTypeValue) {
                    return { isValid: false, message: 'PRCå·¥ä½œè¡¨PROCESSORTYPEå­—æ®µä¸ºç©º' };
                }

                // è¯»å–PROCCLKSPDåˆ—çš„ç¬¬2è¡Œæ•°æ®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                let clockSpeedFormatted = '';
                let clockSpeedNumeric = null;
                
                if (procClkSpdCol) {
                    const clockSpeedCell = sheetPRC[`${procClkSpdCol}2`];
                    if (clockSpeedCell && clockSpeedCell.v) {
                        const rawValue = clockSpeedCell.v;
                        // å°è¯•è§£æä¸ºæ•°å­—
                        clockSpeedNumeric = parseFloat(rawValue);
                        if (!isNaN(clockSpeedNumeric)) {
                            // æ ¼å¼åŒ–ä¸ºä¿ç•™ä¸¤ä½å°æ•°
                            clockSpeedFormatted = clockSpeedNumeric.toFixed(2);
                        }
                    }
                }

                // ç»Ÿä¸€æ¸…æ´—å‡½æ•°
                const clean = (str) => str
                    .toLowerCase()
                    .normalize("NFKD")
                    .replace(/[\u00AE\u2122]/g, "")
                    .replace(/[^\w\s.-]/g, " ")
                    .replace(/\s+/g, " ")
                    .trim();

                const baseClean = clean(baselineValue);
                const testClean = clean(processorTypeValue);

                // æå–å…³é”®è¯ï¼ˆè¿‡æ»¤æ‰å¸¸è§æ— æ„ä¹‰è¯ï¼‰
                const extractKeywords = (str) =>
                    str.split(/[\s\/-]+/)
                    .filter(s =>
                        s.length > 0 &&
                        !["processor","mobile","platform","qualcomm"].includes(s)
                    );

                const baseKeys = extractKeywords(baseClean);
                
                // è®°å½•æ¯ä¸ªå…³é”®å­—çš„åŒ¹é…æƒ…å†µ
                const matchDetails = [];
                const missing = [];
                
                baseKeys.forEach(baseKey => {
                    // åœ¨æµ‹è¯•å€¼ä¸­æŸ¥æ‰¾è¿™ä¸ªå…³é”®å­—
                    if (testClean.includes(baseKey)) {
                        // æ‰¾åˆ°åŒ¹é…çš„å®Œæ•´è¯
                        const testWords = testClean.split(/\s+/);
                        const matchedWord = testWords.find(word => word.includes(baseKey) || baseKey.includes(word));
                        
                        if (matchedWord) {
                            matchDetails.push(`"${baseKey}" åŒ¹é… "${matchedWord}"`);
                        } else {
                            matchDetails.push(`"${baseKey}" å·²åŒ¹é…`);
                        }
                    } else {
                        missing.push(baseKey);
                    }
                });

                // æ£€æŸ¥åŸºå‡†å€¼ä¸­çš„Clock Speedï¼ˆGHzä¹‹å‰çš„æ•°å­—ï¼‰
                let baselineClockSpeed = null;
                let clockSpeedMatch = true;
                let clockSpeedMessage = '';
                
                // ä»åŸºå‡†å€¼ä¸­æå–Clock Speedï¼ˆæŸ¥æ‰¾GHzä¹‹å‰çš„æ•°å­—ï¼‰
                const clockSpeedRegex = /(\d+\.?\d*)\s*GHz/i;
                const clockSpeedMatch_result = baselineValue.match(clockSpeedRegex);
                
                if (clockSpeedMatch_result) {
                    // åŸºå‡†å€¼åŒ…å«Clock Speed
                    baselineClockSpeed = parseFloat(clockSpeedMatch_result[1]);
                    
                    if (clockSpeedNumeric !== null) {
                        // æ¯”è¾ƒClock Speed
                        if (Math.abs(clockSpeedNumeric - baselineClockSpeed) < 0.01) {
                            // Clock SpeedåŒ¹é…ï¼ˆå…è®¸0.01çš„è¯¯å·®ï¼‰
                            clockSpeedMatch = true;
                            clockSpeedMessage = `ï¼ŒClock SpeedåŒ¹é…`;
                        } else {
                            // Clock Speedä¸åŒ¹é…
                            clockSpeedMatch = false;
                            clockSpeedMessage = `ï¼ŒClock Speedä¸åŒ¹é…ï¼ˆåŸºå‡†: ${baselineClockSpeed.toFixed(2)} GHzï¼Œæµ‹è¯•: ${clockSpeedFormatted}ï¼‰`;
                        }
                    } else {
                        // åŸºå‡†æœ‰Clock Speedä½†æµ‹è¯•å€¼æ²¡æœ‰
                        clockSpeedMatch = false;
                        clockSpeedMessage = `ï¼Œç¼ºå°‘Clock Speedæ•°æ®ï¼ˆåŸºå‡†è¦æ±‚: ${baselineClockSpeed.toFixed(2)} GHzï¼‰`;
                    }
                }

                // æ„å»ºæ¶ˆæ¯
                let messagePrefix = `Processoræ£€éªŒé€šè¿‡ï¼ˆPROCESSORTYPE: ${processorTypeValue}`;
                
                // æ·»åŠ PROCCLKSPDä¿¡æ¯
                if (clockSpeedFormatted) {
                    messagePrefix += `ï¼ŒPROCCLKSPD: ${clockSpeedFormatted}ï¼ŒPROCCLKSPDUNITS: ${unitValue}`;
                }
                
                messagePrefix += `ï¼‰`;

                // åˆ¤æ–­æ•´ä½“æ˜¯å¦åŒ¹é…
                const overallMatch = missing.length === 0 && clockSpeedMatch;

                if (overallMatch) {
                    return { 
                        isValid: true, 
                        isMatch: true,
                        message: messagePrefix + clockSpeedMessage,
                        processorTypeCell: `${processorTypeCol}2`,
                        processorTypeValue: processorTypeValue,
                        procClkSpdCell: procClkSpdCol ? `${procClkSpdCol}2` : null,
                        procClkSpdValue: clockSpeedFormatted,
                        matchedKeys: matchDetails,
                        clockSpeedMatch: clockSpeedMatch
                    };
                }

                // æ„å»ºå¤±è´¥æ¶ˆæ¯
                let failureMessage = '';
                
                if (missing.length > 0) {
                    failureMessage += `å¤„ç†å™¨ç±»å‹æ ¡éªŒå¤±è´¥ï¼šæµ‹è¯•å­—æ®µç¼ºå°‘ä»¥ä¸‹å…³é”®å­— â†’ ${missing.join(', ')}`;
                }
                
                if (!clockSpeedMatch) {
                    if (missing.length > 0) {
                        failureMessage += `ï¼›`;
                    }
                    failureMessage += clockSpeedMessage.replace('ï¼Œ', '');
                }

                return {
                    isValid: true,
                    isMatch: false,
                    message: failureMessage,
                    processorTypeCell: `${processorTypeCol}2`,
                    processorTypeValue: processorTypeValue,
                    procClkSpdCell: procClkSpdCol ? `${procClkSpdCol}2` : null,
                    procClkSpdValue: clockSpeedFormatted,
                    missingKeys: missing,
                    clockSpeedMatch: clockSpeedMatch
                };

            } catch (err) {
                return { isValid: false, message: 'å¤„ç†å™¨æ£€éªŒå¼‚å¸¸ï¼š' + err.message };
            }
        }

        function checkOS(baselineValue, sheetOS) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†OSæ•°æ®' };
                }
                
                if (!sheetOS) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°OSå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†OSå€¼:', baselineStr);
                
                // æ‰¾åˆ°POSTITLEåˆ—å’ŒElementåˆ—
                let posTitleCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetOS[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'POSTITLE') posTitleCol = colLetter;
                        // å¢åŠ å¯¹Element Descçš„æ”¯æŒ
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!posTitleCol || !elementNameCol) {
                    return { isValid: false, message: `OSå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (POSTITLE: ${posTitleCol}, Elementåˆ—: ${elementNameCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameCell = sheetOS[`${elementNameCol}2`];
                const posTitleCell = sheetOS[`${posTitleCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `OSå·¥ä½œè¡¨${elementNameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!posTitleCell) {
                    return { isValid: false, message: `OSå·¥ä½œè¡¨${posTitleCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const posTitleValue = String(posTitleCell.v).trim();
                
                console.log('OSå·¥ä½œè¡¨ Elementåˆ—:', elementNameValue);
                console.log('OSå·¥ä½œè¡¨ POSTITLE:', posTitleValue);
                
                // æ£€æŸ¥1: Elementåˆ—æœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OSå·¥ä½œè¡¨Elementåˆ—å¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: false,
                        versionMatch: false
                    };
                }
                
                // æ£€æŸ¥2: æå–å¹¶æ¯”è¾ƒAndroidç‰ˆæœ¬å·
                // æ ‡å‡†åŒ–å‡½æ•°ï¼šç§»é™¤ç¬¦å·ã€MBGã€"or later"ç­‰æ— å…³å†…å®¹
                function normalizeOSString(str) {
                    return str
                        .replace(/â„¢/g, '')           // ç§»é™¤â„¢ç¬¦å·
                        .replace(/Â®/g, '')           // ç§»é™¤Â®ç¬¦å·
                        .replace(/\bMBG\b/gi, '')    // ç§»é™¤MBG
                        .replace(/\bor\s+later\b/gi, '') // ç§»é™¤"or later"
                        .trim();
                }
                
                // æå–Androidç‰ˆæœ¬å·ï¼ˆAndroidåçš„ç¬¬ä¸€ä¸ªæ•´æ•°ï¼‰
                function extractAndroidVersion(str) {
                    const normalized = normalizeOSString(str);
                    console.log('æ ‡å‡†åŒ–åçš„å­—ç¬¦ä¸²:', normalized);
                    
                    // æŸ¥æ‰¾"Android"åçš„ç¬¬ä¸€ä¸ªæ•´æ•°
                    const match = normalized.match(/Android\s+(\d+)/i);
                    
                    if (match) {
                        const version = parseInt(match[1], 10);
                        console.log('æå–çš„ç‰ˆæœ¬å·:', version);
                        return version;
                    }
                    
                    console.log('æœªæ‰¾åˆ°Androidç‰ˆæœ¬å·');
                    return null;
                }
                
                const baselineVersion = extractAndroidVersion(baselineStr);
                const testVersion = extractAndroidVersion(posTitleValue);
                
                console.log('åŸºå‡†ç‰ˆæœ¬å·:', baselineVersion);
                console.log('æµ‹è¯•ç‰ˆæœ¬å·:', testVersion);
                
                // æ£€æŸ¥æ˜¯å¦æˆåŠŸæå–ç‰ˆæœ¬å·
                if (baselineVersion === null) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OSæ£€éªŒå¤±è´¥ï¼šæ— æ³•ä»åŸºå‡†å€¼"${baselineStr}"ä¸­æå–Androidç‰ˆæœ¬å·`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: endsWithMBG,
                        versionMatch: false,
                        baselineVersion: null,
                        testVersion: testVersion
                    };
                }
                
                if (testVersion === null) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `OSæ£€éªŒå¤±è´¥ï¼šæ— æ³•ä»æµ‹è¯•å€¼"${posTitleValue}"ä¸­æå–Androidç‰ˆæœ¬å·`,
                        elementNameValue: elementNameValue,
                        posTitleValue: posTitleValue,
                        endsWithMBG: endsWithMBG,
                        versionMatch: false,
                        baselineVersion: baselineVersion,
                        testVersion: null
                    };
                }
                
                // ä¸¥æ ¼æ¯”è¾ƒç‰ˆæœ¬å·ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
                const versionMatch = baselineVersion === testVersion;
                const isMatch = endsWithMBG && versionMatch;
                
                let message = '';
                if (isMatch) {
                    message = `OSæ£€éªŒé€šè¿‡ï¼ˆPOSTITLEï¼š${posTitleValue}ï¼‰`;
                } else if (!versionMatch) {
                    message = `OSæ£€éªŒå¤±è´¥ï¼šAndroidç‰ˆæœ¬å·ä¸åŒ¹é…ï¼ŒåŸºå‡†ç‰ˆæœ¬ ${baselineVersion} â‰  æµ‹è¯•ç‰ˆæœ¬ ${testVersion}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    posTitleValue: posTitleValue,
                    endsWithMBG: endsWithMBG,
                    versionMatch: versionMatch,
                    baselineVersion: baselineVersion,
                    testVersion: testVersion,
                    osCells: `Elementåˆ— (${elementNameCol}2): ${elementNameValue}, POSTITLE (${posTitleCol}2): ${posTitleValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `OSæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // è§£æåŸºå‡†å€¼ä¸­çš„å¤šä¸ªæ˜¾ç¤ºå±æè¿°
        function parseMultipleDisplays(baselineText) {
            const displays = [];
            
            console.log('è§£æåŸºå‡†Displayæ–‡æœ¬:', baselineText);
            
            // å¸¸è§çš„æ˜¾ç¤ºå±æ ‡è¯†å…³é”®è¯
            const displayKeywords = [
                'main display',
                'external display',
                'cover display',
                'inner display',
                'outer display',
                'primary display',
                'secondary display'
            ];
            
            // å°†æ–‡æœ¬æŒ‰è¡Œåˆ†å‰²
            const lines = baselineText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            // å°è¯•è¯†åˆ«æ¯ä¸ªæ˜¾ç¤ºå±æ®µè½
            let currentDisplay = null;
            
            lines.forEach(line => {
                const lineLower = line.toLowerCase();
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„æ˜¾ç¤ºå±å¼€å§‹
                let foundKeyword = null;
                for (const keyword of displayKeywords) {
                    if (lineLower.includes(keyword)) {
                        foundKeyword = keyword;
                        break;
                    }
                }
                
                if (foundKeyword) {
                    // ä¿å­˜ä¹‹å‰çš„æ˜¾ç¤ºå±(å¦‚æœæœ‰)
                    if (currentDisplay) {
                        displays.push(currentDisplay);
                    }
                    
                    // å¼€å§‹æ–°çš„æ˜¾ç¤ºå±
                    currentDisplay = {
                        name: foundKeyword.replace('display', '').trim() || 'Display',
                        text: line,
                        lines: [line]
                    };
                } else if (currentDisplay) {
                    // ç»§ç»­å½“å‰æ˜¾ç¤ºå±çš„æè¿°
                    currentDisplay.text += '\n' + line;
                    currentDisplay.lines.push(line);
                }
            });
            
            // ä¿å­˜æœ€åä¸€ä¸ªæ˜¾ç¤ºå±
            if (currentDisplay) {
                displays.push(currentDisplay);
            }
            
            // å¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°å…³é”®è¯,å½“ä½œå•ä¸ªæ˜¾ç¤ºå±å¤„ç†
            if (displays.length === 0) {
                displays.push({
                    name: 'Display',
                    text: baselineText,
                    lines: lines
                });
            }
            
            console.log('è§£æå‡ºçš„æ˜¾ç¤ºå±:', displays);
            return displays;
        }

        // Displayæ£€éªŒå‡½æ•° - ä¿®æ”¹ä¸ºè®¿é—®MONå·¥ä½œè¡¨
        function checkDisplay(baselineValue, sheetMON) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Displayæ•°æ®' };
                }
                
                if (!sheetMON) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°MONå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Displayå€¼:', baselineStr);
                
                // æ‰¾åˆ°éœ€è¦çš„åˆ—
                let nameCol = null;
                let screenSizeCol = null;
                let displayTypeCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetMON[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'SCREENSIZEVIEW_IN') screenSizeCol = colLetter;
                        if (headerValue === 'DISPLAYTYPE') displayTypeCol = colLetter;
                    }
                }
                
                if (!nameCol || !screenSizeCol || !displayTypeCol) {
                    return { isValid: false, message: `MONå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (Element NAME: ${nameCol}, SCREENSIZEVIEW_IN: ${screenSizeCol}, DISPLAYTYPE: ${displayTypeCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const nameCell = sheetMON[`${nameCol}2`];
                const screenSizeCell = sheetMON[`${screenSizeCol}2`];
                const displayTypeCell = sheetMON[`${displayTypeCol}2`];
                
                if (!nameCell) {
                    return { isValid: false, message: `MONå·¥ä½œè¡¨${nameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!screenSizeCell) {
                    return { isValid: false, message: `MONå·¥ä½œè¡¨${screenSizeCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!displayTypeCell) {
                    return { isValid: false, message: `MONå·¥ä½œè¡¨${displayTypeCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const nameValue = String(nameCell.v).trim();
                const screenSizeValue = screenSizeCell.v; // æ•°å€¼ï¼Œä¸trim
                const displayTypeValue = String(displayTypeCell.v).trim();
                
                console.log('MONå·¥ä½œè¡¨ Name:', nameValue);
                console.log('MONå·¥ä½œè¡¨ SCREENSIZEVIEW_IN:', screenSizeValue);
                console.log('MONå·¥ä½œè¡¨ DISPLAYTYPE:', displayTypeValue);

                
                // æ£€æŸ¥1: Nameæœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = nameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `MONå·¥ä½œè¡¨Nameå¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${nameValue}"`,
                        nameValue: nameValue,
                        screenSizeValue: screenSizeValue,
                        displayTypeValue: displayTypeValue,
                        endsWithMBG: false,
                        screenSizeMatch: false,
                        displayTypeMatch: false
                    };
                }
                
                // æ£€æŸ¥2: ä»åŸºå‡†å€¼ä¸­æå–å±å¹•å°ºå¯¸å¹¶ä¸¥æ ¼åŒ¹é…
                const sizeMatch = baselineStr.match(/(\d+(?:\.\d+)?)\s*(?:inch|inches|")/i);
                let screenSizeMatches = false;
                let extractedSize = null;
                
                if (sizeMatch) {
                    extractedSize = parseFloat(sizeMatch[1]);
                    // ä¸¥æ ¼æ•°å€¼åŒ¹é…ï¼Œä¸å…è®¸å››èˆäº”å…¥
                    screenSizeMatches = Math.abs(screenSizeValue - extractedSize) < 0.01;
                } else {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æ— æ³•ä»åŸºå‡†å€¼ä¸­æå–å±å¹•å°ºå¯¸',
                        nameValue: nameValue,
                        screenSizeValue: screenSizeValue,
                        displayTypeValue: displayTypeValue,
                        endsWithMBG: endsWithMBG,
                        screenSizeMatch: false,
                        displayTypeMatch: false
                    };
                }
                
                if (!screenSizeMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `å±å¹•å°ºå¯¸ä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼${extractedSize}" â‰  æµ‹è¯•å€¼${screenSizeValue}"`,
                        nameValue: nameValue,
                        screenSizeValue: screenSizeValue,
                        displayTypeValue: displayTypeValue,
                        endsWithMBG: endsWithMBG,
                        screenSizeMatch: false,
                        displayTypeMatch: false,
                        extractedSize: extractedSize
                    };
                }
                
                // æ£€æŸ¥3: ä»åŸºå‡†å€¼ä¸­æå–å…³é”®æŒ‡æ ‡å¹¶æ£€æŸ¥DISPLAYTYPEæ˜¯å¦å…¨éƒ¨åŒ…å«
                const keyIndicators = {
                    resolution: null,
                    tech: [],
                    refreshRate: null,
                    ppi: null,
                    ratio: null,
                    brightness: null
                };
                
                // æå–åˆ†è¾¨ç‡
                const resMatch = baselineStr.match(/(\d+)\s*[xÃ—]\s*(\d+)/i);
                if (resMatch) {
                    keyIndicators.resolution = `${resMatch[1]}x${resMatch[2]}`;
                }
                
                // æå–æ˜¾ç¤ºæŠ€æœ¯/é¢æ¿ç±»å‹ 
                const techPatterns = [
                    /\b(AMOLED|OLED|LCD|LED|TDDI|IPS|TFT)\b/gi,
                    /\b(Super\s+HD|FHD\+?|QHD\+?|HD\+?)\b/gi,
                    /\b(Extreme\s+\w+)\b/gi
                ];
                techPatterns.forEach(pattern => {
                    const matches = baselineStr.match(pattern);
                    if (matches) {
                        keyIndicators.tech.push(...matches);
                    }
                });
                
                // æå–åˆ·æ–°ç‡
                const refreshMatch = baselineStr.match(/(\d+)\s*Hz/i);
                if (refreshMatch) {
                    keyIndicators.refreshRate = refreshMatch[1] + 'Hz';
                }
                
                // æå–PPI
                const ppiMatch = baselineStr.match(/(\d+)\s*ppi/i);
                if (ppiMatch) {
                    keyIndicators.ppi = ppiMatch[1] + 'ppi';
                }
                
                // æå–äº®åº¦
                const brightnessMatch = baselineStr.match(/(\d+)\s*nits?/i);
                if (brightnessMatch) {
                    keyIndicators.brightness = brightnessMatch[1] + ' nits';
                }
                
                // æ£€æŸ¥æ‰€æœ‰å…³é”®æŒ‡æ ‡æ˜¯å¦éƒ½åœ¨DISPLAYTYPEä¸­
                const displayTypeLower = displayTypeValue.toLowerCase();
                const missingIndicators = [];
                const foundIndicators = [];
                
                const normalizeResolution = str =>String(str).toLowerCase().replace(/\s+/g, '').replace(/[Ã—]/g, 'x');
                
                if (keyIndicators.resolution) {
                    if (normalizeResolution(displayTypeValue)
                            .includes(normalizeResolution(keyIndicators.resolution))) {
                        foundIndicators.push(`åˆ†è¾¨ç‡: ${keyIndicators.resolution}`);
                    } else {
                        missingIndicators.push(`åˆ†è¾¨ç‡: ${keyIndicators.resolution}`);
                    }
                }
                
                if (keyIndicators.tech.length > 0) {
                    keyIndicators.tech.forEach(tech => {
                        if (displayTypeLower.includes(tech.toLowerCase())) {
                            foundIndicators.push(`æ˜¾ç¤ºæŠ€æœ¯: ${tech}`);
                        } else {
                            missingIndicators.push(`æ˜¾ç¤ºæŠ€æœ¯: ${tech}`);
                        }
                    });
                }
                
                if (keyIndicators.refreshRate) {
                    if (displayTypeLower.includes(keyIndicators.refreshRate.toLowerCase())) {
                        foundIndicators.push(`åˆ·æ–°ç‡: ${keyIndicators.refreshRate}`);
                    } else {
                        missingIndicators.push(`åˆ·æ–°ç‡: ${keyIndicators.refreshRate}`);
                    }
                }
                
                const normalizePPI = str =>str.toLowerCase().replace(/\s+/g, '');

                if (normalizePPI(displayTypeValue)
                        .includes(normalizePPI(keyIndicators.ppi))) {
                    foundIndicators.push(`PPI: ${keyIndicators.ppi}`);
                } else {
                    missingIndicators.push(`PPI: ${keyIndicators.ppi}`);
                }

                if (keyIndicators.brightness) {
                    const normalized = keyIndicators.brightness.replace(/nits?/i, 'nit');
                    if (displayTypeLower.includes(normalized.toLowerCase()) || displayTypeLower.includes(keyIndicators.brightness.toLowerCase())) {
                        foundIndicators.push(`äº®åº¦: ${keyIndicators.brightness}`);
                    } else {
                        missingIndicators.push(`äº®åº¦: ${keyIndicators.brightness}`);
                    }
                }
                
                const displayTypeMatches = missingIndicators.length === 0;
                const isMatch = endsWithMBG && screenSizeMatches && displayTypeMatches;
                
                let message = '';
                if (isMatch) {
                    message = `Displayæ£€éªŒé€šè¿‡ï¼ˆSCREENSIZEVIEW_IN: ${extractedSize}ï¼ŒDISPLAYTYPE: ${displayTypeValue}ï¼‰`;
                } else if (!displayTypeMatches) {
                    message = `Displayæ£€éªŒå¤±è´¥ï¼šDISPLAYTYPEç¼ºå°‘ä»¥ä¸‹å…³é”®æŒ‡æ ‡: ${missingIndicators.join(', ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    nameValue: nameValue,
                    screenSizeValue: screenSizeValue,
                    displayTypeValue: displayTypeValue,
                    endsWithMBG: endsWithMBG,
                    screenSizeMatch: screenSizeMatches,
                    displayTypeMatch: displayTypeMatches,
                    extractedSize: extractedSize,
                    foundIndicators: foundIndicators,
                    missingIndicators: missingIndicators,
                    keyIndicators: keyIndicators
                };
                
            } catch (error) {
                return { isValid: false, message: `Displayæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        function checkStorage(baselineValue, sheetHD) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Storageæ•°æ®' };
                }

                if (!sheetHD) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°HDå·¥ä½œè¡¨' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Storageå€¼:', baselineStr);

                // æ‰¾åˆ—
                let nameCol = null;
                let capacityCol = null;
                let unitCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetHD[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'HDDCAPACITY') capacityCol = colLetter;
                        if (headerValue === 'HDDCAPACITYUNITS') unitCol = colLetter;
                    }
                }

                if (!nameCol || !capacityCol || !unitCol) {
                    return {
                        isValid: false,
                        message: `HDå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (Element Desc: ${nameCol}, HDDCAPACITY: ${capacityCol}, HDDCAPACITYUNITS: ${unitCol})`
                    };
                }

                // è¯»ç¬¬2è¡Œ
                const nameCell = sheetHD[`${nameCol}2`];
                const capacityCell = sheetHD[`${capacityCol}2`];
                const unitCell = sheetHD[`${unitCol}2`];

                if (!nameCell || !capacityCell || !unitCell) {
                    return {
                        isValid: false,
                        message: 'HDå·¥ä½œè¡¨ç¬¬2è¡Œå­˜åœ¨ç©ºå•å…ƒæ ¼'
                    };
                }

                const nameValue = String(nameCell.v).trim();
                const capacityValue = Number(capacityCell.v);
                const unitValue = String(unitCell.v).trim();

                console.log('HD Name:', nameValue);
                console.log('HD Capacity:', capacityValue);
                console.log('HD Unit:', unitValue);

                // æ£€æŸ¥1ï¼šMBG
                const endsWithMBG = nameValue.slice(-3).toUpperCase() === 'MBG';
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `HD Nameå¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${nameValue}"`,
                        endsWithMBG: false,
                        capacityMatch: false,
                        unitMatch: false
                    };
                }

                // ä»åŸºå‡†å€¼æå–å®¹é‡æ•°å­—ï¼ˆåªææ•°å­—ï¼‰
                const capacityMatch = baselineStr.match(/(\d+(?:\.\d+)?)/);
                if (!capacityMatch) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æ— æ³•ä»åŸºå‡†å€¼ä¸­æå–å­˜å‚¨å®¹é‡æ•°å­—',
                        endsWithMBG: endsWithMBG,
                        capacityMatch: false,
                        unitMatch: false
                    };
                }

                const extractedCapacity = Number(capacityMatch[1]);

                // æ£€æŸ¥2ï¼šå®¹é‡æ•°å­—ä¸¥æ ¼ç›¸ç­‰
                const capacityMatches = capacityValue === extractedCapacity;
                if (!capacityMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `å­˜å‚¨å®¹é‡ä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼${extractedCapacity} â‰  æµ‹è¯•å€¼${capacityValue}`,
                        endsWithMBG: endsWithMBG,
                        capacityMatch: false,
                        unitMatch: false,
                        extractedCapacity: extractedCapacity
                    };
                }

                // æ£€æŸ¥3ï¼šå•ä½å¿…é¡»æ˜¯ GB
                const unitMatches = unitValue.toUpperCase() === 'GB';
                if (!unitMatches) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `å­˜å‚¨å•ä½å¿…é¡»ä¸ºGBï¼Œå®é™…ä¸º"${unitValue}"`,
                        endsWithMBG: endsWithMBG,
                        capacityMatch: true,
                        unitMatch: false
                    };
                }

                // å…¨éƒ¨é€šè¿‡
                return {
                    isValid: true,
                    isMatch: true,
                    message: `Storageæ£€éªŒé€šè¿‡ï¼ˆHDDCAPACITY: ${capacityValue}, HDDCAPACITYUNITS: ${unitValue}ï¼‰`,
                    nameValue: nameValue,
                    capacityValue: capacityValue,
                    unitValue: unitValue,
                    extractedCapacity: extractedCapacity,
                    endsWithMBG: endsWithMBG,
                    capacityMatch: true,
                    unitMatch: true
                };

            } catch (error) {
                return { isValid: false, message: `Storageæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        function checkMemory(baselineValue, sheetMEM) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Memoryæ•°æ®' };
                }
                
                if (!sheetMEM) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°MEMå·¥ä½œè¡¨' };
                }

                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Memoryå€¼:', baselineStr);

                // æ‰¾åˆ°éœ€è¦çš„åˆ—
                let nameCol = null;
                let memCapacityCol = null;
                let memUnitCol = null;
                let memModSpecCol = null;

                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetMEM[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim();
                        if (headerValue === 'Element Desc') nameCol = colLetter;
                        if (headerValue === 'MEMCAPACITY') memCapacityCol = colLetter;
                        if (headerValue === 'MEMCAPACITYUNITS') memUnitCol = colLetter;
                        if (headerValue === 'MEMMODSPEC') memModSpecCol = colLetter;
                    }
                }

                if (!nameCol || !memCapacityCol || !memUnitCol || !memModSpecCol) {
                    return { 
                        isValid: false, 
                        message: `MEMå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (Element NAME: ${nameCol}, MEMCAPACITY: ${memCapacityCol}, MEMCAPACITYUNITS: ${memUnitCol}, MEMMODSPEC: ${memModSpecCol})` 
                    };
                }

                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const nameCell = sheetMEM[`${nameCol}2`];
                const memCapacityCell = sheetMEM[`${memCapacityCol}2`];
                const memUnitCell = sheetMEM[`${memUnitCol}2`];
                const memModSpecCell = sheetMEM[`${memModSpecCol}2`];

                if (!nameCell || !memCapacityCell || !memUnitCell || !memModSpecCell) {
                    return { isValid: false, message: 'MEMå·¥ä½œè¡¨ç¬¬2è¡Œæœ‰å•å…ƒæ ¼ä¸ºç©º' };
                }

                const nameValue = String(nameCell.v).trim();
                const memCapacityValue = parseFloat(memCapacityCell.v); // æ•°å€¼
                const memUnitValue = String(memUnitCell.v).trim();
                const memModSpecValue = String(memModSpecCell.v).trim();

                console.log('MEMå·¥ä½œè¡¨ Name:', nameValue);
                console.log('MEMCAPACITY:', memCapacityValue);
                console.log('MEMCAPACITYUNITS:', memUnitValue);
                console.log('MEMMODSPEC:', memModSpecValue);

                // æ£€æŸ¥MBG
                const endsWithMBG = nameValue.slice(-3) === 'MBG';

                // ä»åŸºå‡†å€¼æå–å®¹é‡å’Œç±»å‹
                const capacityMatch = baselineStr.match(/(\d+)\s*GB/i);
                let extractedCapacity = null;
                if (capacityMatch) {
                    extractedCapacity = parseInt(capacityMatch[1]);
                } else {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æ— æ³•ä»åŸºå‡†å€¼ä¸­æå–å®¹é‡',
                        nameValue, memCapacityValue, memUnitValue, memModSpecValue
                    };
                }

                // æ£€æŸ¥å®¹é‡
                const capacityMatches = memCapacityValue === extractedCapacity;

                // æ£€æŸ¥å•ä½
                const unitMatches = memUnitValue.toUpperCase() === 'GB';

                // æ£€æŸ¥ç±»å‹ä¿¡æ¯ï¼ˆMEMMODSPECï¼‰
                let typeMatches = true;
                const typeIndicators = baselineStr.replace(/\d+\s*GB/i, '').trim().split(/\s+/); // å»æ‰å®¹é‡å‰©ä¸‹çš„éƒ½æ˜¯ç±»å‹
                typeIndicators.forEach(ind => {
                    if (ind && !memModSpecValue.toUpperCase().includes(ind.toUpperCase())) {
                        typeMatches = false;
                    }
                });

                const isMatch = endsWithMBG && capacityMatches && unitMatches && typeMatches;

                let message = '';
                const missingIndicators = [];
                if (!endsWithMBG) missingIndicators.push('MBG');
                if (!capacityMatches) missingIndicators.push(`å®¹é‡: ${extractedCapacity}GB`);
                if (!unitMatches) missingIndicators.push('å•ä½ä¸æ˜¯GB');
                if (!typeMatches) missingIndicators.push('ç±»å‹ä¿¡æ¯ä¸åŸºå‡†ä¸åŒ¹é…');

                if (isMatch) {
                    message = `Memoryæ£€éªŒé€šè¿‡ï¼ˆMEMCAPACITY: ${memCapacityValue}, MEMCAPACITYUNITS: ${memUnitValue}${memModSpecValue ? `, MEMMODSPEC: ${memModSpecValue}` : ''}ï¼‰`;
                } else {
                    message = `Memoryæ£€éªŒå¤±è´¥: ${missingIndicators.join(', ')}`;
                }

                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    nameValue,
                    memCapacityValue,
                    memUnitValue,
                    memModSpecValue,
                    endsWithMBG,
                    capacityMatches,
                    unitMatches,
                    typeMatches,
                    extractedCapacity,
                    missingIndicators
                };

            } catch (error) {
                return { isValid: false, message: `Memoryæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Graphicsæ£€éªŒå‡½æ•°
        function checkGraphics(baselineValue, sheetGRA) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Graphicsæ•°æ®' };
                }
                
                if (!sheetGRA) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°GRAå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Graphicså€¼:', baselineStr);
                
                // æ‰¾åˆ°GRAPHIC_DESCåˆ—å’ŒElement Nameåˆ—
                let graphicDescCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetGRA[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'GRAPHIC_DESC' || headerValue === 'GRAPHICDESC') graphicDescCol = colLetter;
                        if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!graphicDescCol || !elementNameCol) {
                    return { isValid: false, message: `GRAå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (GRAPHIC_DESC: ${graphicDescCol}, Elementåˆ—: ${elementNameCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameCell = sheetGRA[`${elementNameCol}2`];
                const graphicDescCell = sheetGRA[`${graphicDescCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `GRAå·¥ä½œè¡¨${elementNameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!graphicDescCell) {
                    return { isValid: false, message: `GRAå·¥ä½œè¡¨${graphicDescCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const graphicDescValue = String(graphicDescCell.v).trim();
                
                console.log('GRAå·¥ä½œè¡¨ Element Name:', elementNameValue);
                console.log('GRAå·¥ä½œè¡¨ GRAPHIC_DESC:', graphicDescValue);
                
                // æ£€æŸ¥1: Element Nameæœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `GRAå·¥ä½œè¡¨Element Nameå¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        graphicDescValue: graphicDescValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // æ£€æŸ¥2: GRAPHIC_DESCå†…å®¹ä¸åŸºå‡†è¡¨åŒ¹é…
                const contentMatch = graphicDescValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Graphicsæ£€éªŒé€šè¿‡ï¼ˆGRAPHIC_DESC: ${graphicDescValue}ï¼‰`;
                } else if (!contentMatch) {
                    message = `Graphicsæ£€éªŒå¤±è´¥ï¼šGRAPHIC_DESCä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼"${baselineStr}" â‰  æµ‹è¯•å€¼"${graphicDescValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    graphicDescValue: graphicDescValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    graCells: `Element Name (${elementNameCol}2): ${elementNameValue}, GRAPHIC_DESC (${graphicDescCol}2): ${graphicDescValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Graphicsæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Wirelessæ£€éªŒå‡½æ•°
        function checkWireless(baselineValue, sheetWS) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Wirelessæ•°æ®' };
                }
                
                if (!sheetWS) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°WSå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Wirelesså€¼:', baselineStr);
                
                // æ‰¾åˆ°WSDESCåˆ—å’ŒElement Nameåˆ—
                let wsDescCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWS[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'WSDESC') wsDescCol = colLetter;
                        if (headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') elementNameCol = colLetter;
                    }
                }
                
                if (!wsDescCol || !elementNameCol) {
                    return { isValid: false, message: `WSå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (WSDESC: ${wsDescCol}, ELEMENTNAME: ${elementNameCol})` };
                }
                
                // æ‰¾åˆ°WSTYPEä¸ºWLANçš„è¡Œ
                let wsTypeCol = null;
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWS[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'WSTYPE') wsTypeCol = colLetter;
                    }
                }
                
                // æŸ¥æ‰¾WLANè¡Œ
                let wlanRow = null;
                for (let row = 2; row <= 20; row++) {
                    if (wsTypeCol) {
                        const wsTypeCell = sheetWS[`${wsTypeCol}${row}`];
                        if (wsTypeCell && String(wsTypeCell.v).trim().toUpperCase() === 'WLAN') {
                            wlanRow = row;
                            break;
                        }
                    }
                }
                
                if (!wlanRow) {
                    return { isValid: false, message: 'WSå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°WSTYPEä¸ºWLANçš„è¡Œ' };
                }
                
                // è¯»å–WLANè¡Œçš„æ•°æ®
                const elementNameCell = sheetWS[`${elementNameCol}${wlanRow}`];
                const wsDescCell = sheetWS[`${wsDescCol}${wlanRow}`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `WSå·¥ä½œè¡¨${elementNameCol}${wlanRow}å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!wsDescCell) {
                    return { isValid: false, message: `WSå·¥ä½œè¡¨${wsDescCol}${wlanRow}å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const wsDescValue = String(wsDescCell.v).trim();
                
                console.log('WSå·¥ä½œè¡¨ Element Name:', elementNameValue);
                console.log('WSå·¥ä½œè¡¨ WSDESC:', wsDescValue);
                
                // æ£€æŸ¥1: Element Nameæœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `WSå·¥ä½œè¡¨Element Nameå¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        wsDescValue: wsDescValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // æ£€æŸ¥2: WSDESCå†…å®¹ä¸åŸºå‡†è¡¨åŒ¹é…
                const contentMatch = wsDescValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = 'Wirelessæ£€éªŒé€šè¿‡ï¼šElement Nameä»¥MBGç»“å°¾ä¸”WSDESCä¸åŸºå‡†å€¼åŒ¹é…';
                } else if (!contentMatch) {
                    message = `Wirelessæ£€éªŒå¤±è´¥ï¼šWSDESCä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼"${baselineStr}" â‰  æµ‹è¯•å€¼"${wsDescValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    wsDescValue: wsDescValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    wsCells: `Element Name (${elementNameCol}${wlanRow}): ${elementNameValue}, WSDESC (${wsDescCol}${wlanRow}): ${wsDescValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Wirelessæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Bluetoothæ£€éªŒå‡½æ•°
        function checkBluetooth(baselineValue, testValue, objectElementWsValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Bluetoothæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥OBJECT-ELEMENTçš„Cåˆ—æ˜¯å¦åŒ…å« "MBG"ï¼ˆå¦‚æœæä¾›äº†è¯¥å‚æ•°ï¼‰
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementWsValue !== null) {
                    // ä»OBJECT-ELEMENTçš„Cåˆ—æ£€æŸ¥MBG
                    const objectElementStr = String(objectElementWsValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT Cåˆ—';
                } else {
                    // é™çº§åˆ°ä»WSå·¥ä½œè¡¨çš„å€¼æ£€æŸ¥MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'WSå·¥ä½œè¡¨';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`,
                        baselineTokens: [],
                        testTokens: [],
                        missingTokens: [],
                        foundTokens: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. æ™ºèƒ½æå–æ•°å­—tokençš„å‡½æ•° - é¿å…åè®®åç§°ä¸­çš„æ•°å­—
                function extractBluetoothNumbers(text) {
                    // å·²çŸ¥çš„Bluetoothåè®®åç§°ï¼ŒåŒ…å«æ•°å­—ä½†ä¸åº”è¯¥è¢«æå–
                    const protocolPatterns = [
                        /A2DP/gi,
                        /HFP/gi,
                        /HSP/gi,
                        /AVRCP/gi,
                        /HID/gi,
                        /OPP/gi,
                        /FTP/gi,
                        /BIP/gi,
                        /PBAP/gi,
                        /MAP/gi,
                        /DUN/gi,
                        /PAN/gi,
                        /SPP/gi
                    ];
                    
                    // é¦–å…ˆç§»é™¤å·²çŸ¥çš„åè®®åç§°ï¼Œé˜²æ­¢æå–å…¶ä¸­çš„æ•°å­—
                    let cleanedText = text;
                    protocolPatterns.forEach(pattern => {
                        cleanedText = cleanedText.replace(pattern, ' ');
                    });
                    
                    console.log('BluetoothåŸå§‹æ–‡æœ¬:', text);
                    console.log('ç§»é™¤åè®®åçš„æ–‡æœ¬:', cleanedText);
                    
                    // ä»æ¸…ç†åçš„æ–‡æœ¬ä¸­æå–ç‹¬ç«‹çš„æ•°å­—ï¼ˆå‰åå¿…é¡»æ˜¯ç©ºæ ¼ã€æ ‡ç‚¹æˆ–å­—ç¬¦ä¸²å¼€å§‹/ç»“æŸï¼‰
                    const numbers = [];
                    const numberMatches = cleanedText.match(/(?:^|[\s,;])(\d+(?:\.\d+)?)(?=[\s,;]|$)/g);
                    
                    if (numberMatches) {
                        numberMatches.forEach(match => {
                            const num = parseFloat(match.trim());
                            if (!isNaN(num)) {
                                numbers.push(num);
                            }
                        });
                    }
                    
                    console.log('æå–çš„æ•°å­—:', numbers);
                    return numbers;
                }
                
                // 3. å¤„ç†baselineå’Œtest tokens
                const rawBaselineTokens = baselineStr.split(/\s+/).filter(token => token.length > 0);
                const rawTestTokens = testStr.split(/\s+/).filter(token => 
                    token.length > 0 && token.toUpperCase() !== 'MBG'
                );
                
                // æå–æ•°å­—tokensï¼ˆé¿å…åè®®åç§°ä¸­çš„æ•°å­—ï¼‰
                const baselineNumbers = extractBluetoothNumbers(baselineStr);
                const testNumbers = extractBluetoothNumbers(testStr.replace(/MBG/gi, '')); // ç§»é™¤MBGåæå–æ•°å­—
                
                // 4. æ£€æŸ¥æ•°å­—æ˜¯å¦ç›¸åŒï¼ˆé¡ºåºæ— å…³ï¼‰
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);
                
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);
                
                const isMatch = hasMBG && numbersMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Bluetoothä¿¡æ¯å®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”ç‰ˆæœ¬å·ç›¸åŒ (MBGæ£€æŸ¥æ¥æº: ${mbgCheckSource}, å·²æ’é™¤åè®®åç§°ä¸­çš„æ•°å­—)`;
                } else if (!hasMBG) {
                    message = `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                } else if (!numbersMatch) {
                    message = `Bluetoothç‰ˆæœ¬å·ä¸åŒ¹é…ï¼ŒåŸºå‡†: [${sortedBaselineNumbers.join(', ')}], æµ‹è¯•: [${sortedTestNumbers.join(', ')}] (MBGæ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineTokens: rawBaselineTokens,
                    testTokens: rawTestTokens.filter(token => token.toUpperCase() !== 'MBG'),
                    foundTokens: isMatch ? sortedTestNumbers.map(n => n.toString()) : [],
                    missingTokens: !numbersMatch ? sortedBaselineNumbers.filter(n => !sortedTestNumbers.includes(n)).map(n => n.toString()) : [],
                    hasMBG: hasMBG,
                    cleanedBaselineTokens: baselineNumbers,
                    cleanedTestTokens: testNumbers,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Bluetoothæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Cameraæ£€éªŒå‡½æ•°
        function checkCamera(baselineValue, testValue, objectElementCamValue = null) {
            try {
                if (!baselineValue || !testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Cameraæ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = String(testValue).trim();
                
                // 1. é¦–å…ˆæ£€æŸ¥OBJECT-ELEMENTçš„Cåˆ—æ˜¯å¦åŒ…å« "MBG"ï¼ˆå¦‚æœæä¾›äº†è¯¥å‚æ•°ï¼‰
                let hasMBG = false;
                let mbgCheckSource = '';
                
                if (objectElementCamValue !== null) {
                    // ä»OBJECT-ELEMENTçš„Cåˆ—æ£€æŸ¥MBG
                    const objectElementStr = String(objectElementCamValue).trim();
                    hasMBG = objectElementStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'OBJECT-ELEMENT Cåˆ—';
                } else {
                    // é™çº§åˆ°ä»CAMå·¥ä½œè¡¨çš„å€¼æ£€æŸ¥MBG
                    hasMBG = testStr.toUpperCase().includes('MBG');
                    mbgCheckSource = 'CAMå·¥ä½œè¡¨';
                }
                
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`,
                        baselineSpecs: {},
                        testSpecs: {},
                        missingSpecs: [],
                        foundSpecs: [],
                        hasMBG: false,
                        mbgCheckSource: mbgCheckSource
                    };
                }
                
                // 2. æå–å…³é”®Cameraå‚æ•°çš„å‡½æ•°
                function extractCameraSpecs(text) {
                    const specs = {};
                    
                    console.log('æå–Cameraè§„æ ¼ï¼ŒåŸå§‹æ–‡æœ¬:', text);
                    
                    // æå–åƒç´  (MP)
                    const mpMatch = text.match(/(\d+)\s*MP/i);
                    if (mpMatch) {
                        specs.pixels = parseInt(mpMatch[1]);
                        console.log('æ‰¾åˆ°åƒç´ :', specs.pixels + 'MP');
                    }
                    
                    // æå–å…‰åœˆ (f/æ•°å­—)
                    const apertureMatch = text.match(/f\/(\d+\.\d+)/i);
                    if (apertureMatch) {
                        specs.aperture = parseFloat(apertureMatch[1]);
                        console.log('æ‰¾åˆ°å…‰åœˆ:', 'f/' + specs.aperture);
                    }
                    
                    // æå–åƒç´ å°ºå¯¸ (æ•°å­—Âµm æˆ– æ•°å­—Î¼m)
                    const pixelSizeMatch = text.match(/(\d+(?:\.\d+)?)[ÂµÎ¼]m/i);
                    if (pixelSizeMatch) {
                        specs.pixelSize = parseFloat(pixelSizeMatch[1]);
                        console.log('æ‰¾åˆ°åƒç´ å°ºå¯¸:', specs.pixelSize + 'Âµm');
                    }
                    
                    console.log('æå–çš„è§„æ ¼:', specs);
                    return specs;
                }
                
                // 3. æå–åŸºå‡†å’Œæµ‹è¯•è§„æ ¼
                const baselineSpecs = extractCameraSpecs(baselineStr);
                const testSpecs = extractCameraSpecs(testStr);
                
                // 4. æ¯”è¾ƒå…³é”®å‚æ•°
                const missingSpecs = [];
                const foundSpecs = [];
                const mismatchedSpecs = [];
                
                // æ£€æŸ¥åƒç´ 
                if (baselineSpecs.pixels !== undefined) {
                    if (testSpecs.pixels !== undefined) {
                        if (baselineSpecs.pixels === testSpecs.pixels) {
                            foundSpecs.push(`${baselineSpecs.pixels}MP`);
                        } else {
                            mismatchedSpecs.push(`åƒç´ ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.pixels}MP vs æµ‹è¯•${testSpecs.pixels}MP`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixels}MP`);
                    }
                }
                
                // æ£€æŸ¥å…‰åœˆ
                if (baselineSpecs.aperture !== undefined) {
                    if (testSpecs.aperture !== undefined) {
                        if (baselineSpecs.aperture === testSpecs.aperture) {
                            foundSpecs.push(`f/${baselineSpecs.aperture}`);
                        } else {
                            mismatchedSpecs.push(`å…‰åœˆä¸åŒ¹é…: åŸºå‡†f/${baselineSpecs.aperture} vs æµ‹è¯•f/${testSpecs.aperture}`);
                        }
                    } else {
                        missingSpecs.push(`f/${baselineSpecs.aperture}`);
                    }
                }
                
                // æ£€æŸ¥åƒç´ å°ºå¯¸
                if (baselineSpecs.pixelSize !== undefined) {
                    if (testSpecs.pixelSize !== undefined) {
                        if (baselineSpecs.pixelSize === testSpecs.pixelSize) {
                            foundSpecs.push(`${baselineSpecs.pixelSize}Âµm`);
                        } else {
                            mismatchedSpecs.push(`åƒç´ å°ºå¯¸ä¸åŒ¹é…: åŸºå‡†${baselineSpecs.pixelSize}Âµm vs æµ‹è¯•${testSpecs.pixelSize}Âµm`);
                        }
                    } else {
                        missingSpecs.push(`${baselineSpecs.pixelSize}Âµm`);
                    }
                }
                
                // 5. åˆ¤æ–­æ˜¯å¦åŒ¹é…
                const allSpecsFound = missingSpecs.length === 0 && mismatchedSpecs.length === 0;
                const isMatch = hasMBG && allSpecsFound;
                
                let message = '';
                if (isMatch) {
                    message = `Cameraæ£€éªŒé€šè¿‡ï¼ˆDESCRIPTION: ${testStr}ï¼‰`;
                } else if (!hasMBG) {
                    message = `æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG" (æ£€æŸ¥æ¥æº: ${mbgCheckSource})`;
                } else {
                    const issues = [];
                    if (missingSpecs.length > 0) {
                        issues.push(`æœªæ‰¾åˆ°: ${missingSpecs.join(', ')}`);
                    }
                    if (mismatchedSpecs.length > 0) {
                        issues.push(mismatchedSpecs.join('; '));
                    }
                    message = `Cameraå‚æ•°æ£€éªŒå¤±è´¥: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineSpecs: baselineSpecs,
                    testSpecs: testSpecs,
                    foundSpecs: foundSpecs,
                    missingSpecs: missingSpecs,
                    mismatchedSpecs: mismatchedSpecs,
                    hasMBG: hasMBG,
                    mbgCheckSource: mbgCheckSource
                };
                
            } catch (error) {
                return { isValid: false, message: `Cameraæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Battery Lifeæ£€éªŒå‡½æ•°ï¼ˆä¿®æ”¹ç‰ˆï¼‰
        function checkBatteryLife(baselineValue, testSheetTI) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘Battery LifeåŸºå‡†æ•°æ®' };
                }
                
                if (!testSheetTI) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶ä¸­æœªæ‰¾åˆ°TIå·¥ä½œè¡¨' };
                }
                
                // è·å–TIè¡¨çš„E2å’ŒF2å•å…ƒæ ¼
                const e2Cell = testSheetTI['E2'];
                const f2Cell = testSheetTI['F2'];
                
                if (!e2Cell) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶TIè¡¨ä¸­æœªæ‰¾åˆ°E2å•å…ƒæ ¼æ•°æ®' };
                }
                
                if (!f2Cell) {
                    return { isValid: false, message: 'æµ‹è¯•æ–‡ä»¶TIè¡¨ä¸­æœªæ‰¾åˆ°F2å•å…ƒæ ¼æ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const e2Value = String(e2Cell.v || '').trim();
                const f2Value = String(f2Cell.v || '').trim();
                
                console.log('Battery Lifeæ£€éªŒ:');
                console.log('åŸºå‡†å€¼:', baselineStr);
                console.log('TI-E2å€¼:', e2Value);
                console.log('TI-F2å€¼:', f2Value);
                
                // 1. æ£€æŸ¥F2å•å…ƒæ ¼æ˜¯å¦åŒ…å«"MBG"
                const hasMBG = f2Value.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'TIè¡¨F2å•å…ƒæ ¼å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineValue: baselineStr,
                        e2Value: e2Value,
                        f2Value: f2Value,
                        hasMBG: false,
                        baselineNumbers: [],
                        testNumbers: []
                    };
                }
                
                // 2. æå–æ‰€æœ‰æ•°å­—çš„å‡½æ•°
                function extractNumericTokens(text) {
                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ‰€æœ‰æ•°å­—ï¼ˆåŒ…æ‹¬å°æ•°ï¼‰
                    const numbers = text.match(/\d+(?:\.\d+)?/g) || [];
                    return numbers.map(num => parseFloat(num));
                }
                
                // 3. ä»åŸºå‡†å€¼å’ŒE2å•å…ƒæ ¼ä¸­æå–æ•°å­—
                const baselineNumbers = extractNumericTokens(baselineStr);
                const testNumbers = extractNumericTokens(e2Value);
                
                console.log('åŸºå‡†å€¼æ•°å­—:', baselineNumbers);
                console.log('E2å•å…ƒæ ¼æ•°å­—:', testNumbers);
                
                // 4. æ£€æŸ¥æ•°å­—æ˜¯å¦ç›¸åŒæˆ–éƒ¨åˆ†åŒ¹é…
                const sortedBaselineNumbers = [...baselineNumbers].sort((a, b) => a - b);
                const sortedTestNumbers = [...testNumbers].sort((a, b) => a - b);

                // æ£€æŸ¥ä¸¥æ ¼åŒ¹é…
                const numbersMatch = sortedBaselineNumbers.length === sortedTestNumbers.length &&
                    sortedBaselineNumbers.every((num, index) => num === sortedTestNumbers[index]);

                // æ£€æŸ¥å®½æ¾åŒ¹é…ï¼ˆæµ‹è¯•å€¼æ˜¯åŸºå‡†çš„å­é›†ï¼‰
                const subsetMatch = sortedTestNumbers.every(num => sortedBaselineNumbers.includes(num));

                // 5. åˆ¤æ–­æ•´ä½“åŒ¹é…çŠ¶æ€
                let isMatch = hasMBG && (numbersMatch || subsetMatch);
                let message = '';

                if (isMatch && numbersMatch) {
                    message = `Battery Lifeæ£€éªŒé€šè¿‡ï¼ˆF2åŒ…å«MBGï¼ŒE2æ•°å­— [${sortedTestNumbers.join(', ')}] ä¸åŸºå‡†å€¼ [${sortedBaselineNumbers.join(', ')}] ç›¸åŒ`;
                } else if (isMatch && subsetMatch) {
                    message = `Battery Lifeæ£€éªŒé€šè¿‡ï¼ˆF2åŒ…å«MBGï¼ŒE2æ•°å­— [${sortedTestNumbers.join(', ')}] æ˜¯åŸºå‡†å€¼ [${sortedBaselineNumbers.join(', ')}] çš„å­é›†`;
                } else if (!hasMBG) {
                    message = 'TIè¡¨F2å•å…ƒæ ¼å†…å®¹å¿…é¡»åŒ…å«"MBG"';
                } else {
                    message = `Battery Lifeæ•°å­—ä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼æ•°å­—: [${sortedBaselineNumbers.join(', ')}], E2æ•°å­—: [${sortedTestNumbers.join(', ')}]`;
                }

                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineStr,
                    e2Value: e2Value,
                    f2Value: f2Value,
                    hasMBG: hasMBG,
                    baselineNumbers: sortedBaselineNumbers,
                    testNumbers: sortedTestNumbers,
                    numbersMatch: numbersMatch
                };
                
            } catch (error) {
                return { isValid: false, message: `Battery Lifeæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Fingerprint Readeræ£€éªŒå‡½æ•° 
        function checkFingerprintReader(baselineValue, sheetSEC) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Fingerprint Readeræ•°æ®' };
                }
                
                if (!sheetSEC) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°SECå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Fingerprint Readerå€¼:', baselineStr);
                
                // æ‰¾åˆ°SECTYPEåˆ—å’ŒElementåˆ—
                let secTypeCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetSEC[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'SECTYPE' || headerValue === 'SEC_TYPE') secTypeCol = colLetter;
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!secTypeCol || !elementNameCol) {
                    return { isValid: false, message: `SECå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (SECTYPE: ${secTypeCol}, Elementåˆ—: ${elementNameCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameCell = sheetSEC[`${elementNameCol}2`];
                const secTypeCell = sheetSEC[`${secTypeCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `SECå·¥ä½œè¡¨${elementNameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!secTypeCell) {
                    return { isValid: false, message: `SECå·¥ä½œè¡¨${secTypeCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const secTypeValue = String(secTypeCell.v).trim();
                
                console.log('SECå·¥ä½œè¡¨ Elementåˆ—:', elementNameValue);
                console.log('SECå·¥ä½œè¡¨ SECTYPE:', secTypeValue);
                
                // æ£€æŸ¥1: Elementåˆ—æœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `SECå·¥ä½œè¡¨Elementåˆ—å¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        secTypeValue: secTypeValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // æ£€æŸ¥2: SECTYPEå†…å®¹ä¸åŸºå‡†è¡¨åŒ¹é…
                const contentMatch = secTypeValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = `Fingerprint Readeræ£€éªŒé€šè¿‡ï¼ˆSECTYPE: ${secTypeValue}ï¼‰`;
                } else if (!contentMatch) {
                    message = `Fingerprint Readeræ£€éªŒå¤±è´¥ï¼šSECTYPEä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼"${baselineStr}" â‰  æµ‹è¯•å€¼"${secTypeValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    secTypeValue: secTypeValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    secCells: `Elementåˆ— (${elementNameCol}2): ${elementNameValue}, SECTYPE (${secTypeCol}2): ${secTypeValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Fingerprint Readeræ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        function checkAudio(baselineValue, sheetAUD, coverageThreshold = 0.9) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Audioæ•°æ®' };
                }
                
                if (!sheetAUD) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°AUDå·¥ä½œè¡¨' };
                }

                const baselineStr = String(baselineValue).trim();
                
                // æ‰¾åˆ°AUDIO_DESCåˆ—å’ŒElementåˆ—
                let audioDescCol = null;
                let elementNameCol = null;
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetAUD[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'AUDIO_DESC' || headerValue === 'AUDIODESC') audioDescCol = colLetter;
                        if (['ELEMENTNAME','ELEMENT_NAME','IELEMENT_NAME','ELEMENTDESC','ELEMENT_DESC'].includes(headerValue)) {
                            elementNameCol = colLetter;
                        }
                    }
                }

                if (!audioDescCol || !elementNameCol) {
                    return { isValid: false, message: `AUDå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (AUDIO_DESC: ${audioDescCol}, Elementåˆ—: ${elementNameCol})` };
                }

                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameValue = String(sheetAUD[`${elementNameCol}2`].v).trim();
                const audioDescValue = String(sheetAUD[`${audioDescCol}2`].v).trim();

                // æ£€æŸ¥MBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';

                // å…³é”®è¯è¦†ç›–ç‡åŒ¹é…
                const baselineKeywords = baselineStr.split(/\s+/).map(k => k.toLowerCase()).filter(k => k); 
                const audioDescNormalized = audioDescValue.toLowerCase().replace(/\s+/g, ' ');

                let matchedCount = 0;
                baselineKeywords.forEach(keyword => {
                    if (audioDescNormalized.includes(keyword)) matchedCount++;
                });

                const coverage = matchedCount / baselineKeywords.length;
                const contentMatch = coverage >= coverageThreshold;

                const isMatch = endsWithMBG && contentMatch;

                // æ„å»ºæ¶ˆæ¯
                let message = '';
                if (isMatch) {
                    message = `Audioæ£€éªŒé€šè¿‡ï¼ˆAUDIO_DESC: ${audioDescValue}ï¼‰`;
                } else {
                    const missingKeywords = baselineKeywords.filter(k => !audioDescNormalized.includes(k));
                    message = `Audioæ£€éªŒå¤±è´¥ï¼ˆå…³é”®è¯è¦†ç›–ç‡ ${(coverage*100).toFixed(1)}%ï¼Œç¼ºå¤±å…³é”®è¯: ${missingKeywords.join(', ')}ï¼‰`;
                }

                return {
                    isValid: true,
                    isMatch,
                    message,
                    elementNameValue,
                    audioDescValue,
                    endsWithMBG,
                    coverage
                };

            } catch (error) {
                return { isValid: false, message: `Audioæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Warrantyæ£€éªŒå‡½æ•° - ä¿®æ”¹ä¸ºè®¿é—®WARå·¥ä½œè¡¨
        function checkWarranty(baselineValue, sheetWAR) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Warrantyæ•°æ®' };
                }
                
                if (!sheetWAR) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°WARå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Warrantyå€¼:', baselineStr);
                
                // æ‰¾åˆ°WARRANTY_PERIODåˆ—å’ŒElementåˆ—
                let warrantyPeriodCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetWAR[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'WARRANTY_PERIOD' || headerValue === 'WARRANTYPERIOD') warrantyPeriodCol = colLetter;
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!warrantyPeriodCol || !elementNameCol) {
                    return { isValid: false, message: `WARå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (WARRANTY_PERIOD: ${warrantyPeriodCol}, Elementåˆ—: ${elementNameCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameCell = sheetWAR[`${elementNameCol}2`];
                const warrantyPeriodCell = sheetWAR[`${warrantyPeriodCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `WARå·¥ä½œè¡¨${elementNameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!warrantyPeriodCell) {
                    return { isValid: false, message: `WARå·¥ä½œè¡¨${warrantyPeriodCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const warrantyPeriodValue = String(warrantyPeriodCell.v).trim();
                
                console.log('WARå·¥ä½œè¡¨ Elementåˆ—:', elementNameValue);
                console.log('WARå·¥ä½œè¡¨ WARRANTY_PERIOD:', warrantyPeriodValue);
                
                // æ£€æŸ¥1: Elementåˆ—æœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `WARå·¥ä½œè¡¨Elementåˆ—å¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        warrantyPeriodValue: warrantyPeriodValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // æ£€æŸ¥2: WARRANTY_PERIODå†…å®¹ä¸åŸºå‡†è¡¨åŒ¹é…
                const contentMatch = warrantyPeriodValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = 'Warrantyæ£€éªŒé€šè¿‡ï¼šElementåˆ—ä»¥MBGç»“å°¾ä¸”WARRANTY_PERIODä¸åŸºå‡†å€¼åŒ¹é…';
                } else if (!contentMatch) {
                    message = `Warrantyæ£€éªŒå¤±è´¥ï¼šWARRANTY_PERIODä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼"${baselineStr}" â‰  æµ‹è¯•å€¼"${warrantyPeriodValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    warrantyPeriodValue: warrantyPeriodValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    warCells: `Elementåˆ— (${elementNameCol}2): ${elementNameValue}, WARRANTY_PERIOD (${warrantyPeriodCol}2): ${warrantyPeriodValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Warrantyæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // IMGæ£€éªŒå‡½æ•°
        function checkIMG(baselineColorValue, testValue) {
            try {
                console.log('IMGæ£€éªŒ - åŸºå‡†é¢œè‰²å€¼:', baselineColorValue);
                console.log('IMGæ£€éªŒ - æµ‹è¯•å€¼:', testValue);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åŸºå‡†é¢œè‰²å€¼
                if (!baselineColorValue || baselineColorValue === '(æœªæ‰¾åˆ°)') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæœªèƒ½ä»PORè¡¨ä¸­è·å–é¢œè‰²ä¿¡æ¯',
                        baselineValue: baselineColorValue || '(æœªæ‰¾åˆ°)',
                        testValue: testValue || '(ç©º)'
                    };
                }
                
                // æ£€æŸ¥æµ‹è¯•å€¼æ˜¯å¦å­˜åœ¨
                if (!testValue || String(testValue).trim() === '') {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•è¡¨ä¸­æœªæ‰¾åˆ°IMGå€¼',
                        baselineValue: baselineColorValue,
                        testValue: '(ç©º)'
                    };
                }
                
                const testStr = String(testValue).trim();
                
                // è§„åˆ™1ï¼šæ£€æŸ¥æ˜¯å¦ä»¥MBGç»“å°¾
                const endsWithMBG = /\bMBG\s*$/i.test(testStr);
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•å€¼å¿…é¡»ä»¥"MBG"ç»“å°¾',
                        baselineValue: baselineColorValue,
                        testValue: testStr,
                        endsWithMBG: false,
                        colorMatch: false
                    };
                }
                
                // è§„åˆ™2ï¼šæ£€æŸ¥æµ‹è¯•å€¼æ˜¯å¦åŒ…å«åŸºå‡†é¢œè‰²å€¼
                // æ ‡å‡†åŒ–å¤„ç†ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
                const normalizedTest = testStr.toLowerCase();
                const normalizedColor = baselineColorValue.toLowerCase();
                
                const colorMatch = normalizedTest.includes(normalizedColor);
                
                console.log('IMGæ£€éªŒ - ä»¥MBGç»“å°¾:', endsWithMBG);
                console.log('IMGæ£€éªŒ - é¢œè‰²åŒ¹é…:', colorMatch);
                
                // ä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³æ‰é€šè¿‡
                const isMatch = endsWithMBG && colorMatch;
                
                let message = '';
                if (isMatch) {
                    message = `IMGæ£€éªŒé€šè¿‡ï¼šä»¥MBGç»“å°¾ä¸”åŒ…å«é¢œè‰² "${baselineColorValue}"`;
                } else if (!colorMatch) {
                    message = `IMGæ£€éªŒå¤±è´¥ï¼šæµ‹è¯•å€¼ä¸­æœªåŒ…å«åŸºå‡†é¢œè‰² "${baselineColorValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    baselineValue: baselineColorValue,
                    testValue: testStr,
                    endsWithMBG: endsWithMBG,
                    colorMatch: colorMatch
                };
                
            } catch (error) {
                return { 
                    isValid: false, 
                    message: `IMGæ£€éªŒé”™è¯¯: ${error.message}`,
                    baselineValue: baselineColorValue || '(æœªçŸ¥)',
                    testValue: testValue || '(æœªçŸ¥)'
                };
            }
        }

        // Portæ£€éªŒå‡½æ•° - ä¿®æ”¹ä¸ºè®¿é—®PORTå·¥ä½œè¡¨
        function checkPort(baselineValue, sheetPORT) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Portæ•°æ®' };
                }
                
                if (!sheetPORT) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PORTå·¥ä½œè¡¨' };
                }
                
                const baselineStr = String(baselineValue).trim();
                console.log('åŸºå‡†Portå€¼:', baselineStr);
                
                // æ‰¾åˆ°PORTTYPEåˆ—å’ŒElementåˆ—
                let portTypeCol = null;
                let elementNameCol = null;
                
                // æ‰«æç¬¬1è¡Œæ‰¾åˆ°åˆ—æ ‡é¢˜
                for (let col = 1; col <= 50; col++) {
                    const colLetter = getColumnLetter(col);
                    const headerCell = sheetPORT[`${colLetter}1`];
                    if (headerCell) {
                        const headerValue = String(headerCell.v).trim().toUpperCase().replace(/\s+/g, '');
                        if (headerValue === 'PORTTYPE' || headerValue === 'PORT_TYPE') portTypeCol = colLetter;
                        if (headerValue === 'ELEMENTNAME' || headerValue === 'ELEMENT_NAME' || headerValue === 'IELEMENT_NAME' || 
                            headerValue === 'ELEMENTDESC' || headerValue === 'ELEMENT_DESC') {
                            elementNameCol = colLetter;
                        }
                    }
                }
                
                if (!portTypeCol || !elementNameCol) {
                    return { isValid: false, message: `PORTå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°å¿…è¦çš„åˆ— (PORTTYPE: ${portTypeCol}, Elementåˆ—: ${elementNameCol})` };
                }
                
                // è¯»å–ç¬¬2è¡Œæ•°æ®
                const elementNameCell = sheetPORT[`${elementNameCol}2`];
                const portTypeCell = sheetPORT[`${portTypeCol}2`];
                
                if (!elementNameCell) {
                    return { isValid: false, message: `PORTå·¥ä½œè¡¨${elementNameCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                if (!portTypeCell) {
                    return { isValid: false, message: `PORTå·¥ä½œè¡¨${portTypeCol}2å•å…ƒæ ¼ä¸ºç©º` };
                }
                
                const elementNameValue = String(elementNameCell.v).trim();
                const portTypeValue = String(portTypeCell.v).trim();
                
                console.log('PORTå·¥ä½œè¡¨ Elementåˆ—:', elementNameValue);
                console.log('PORTå·¥ä½œè¡¨ PORTTYPE:', portTypeValue);
                
                // æ£€æŸ¥1: Elementåˆ—æœ€åä¸‰ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºMBG
                const endsWithMBG = elementNameValue.slice(-3).toUpperCase() === 'MBG';
                
                if (!endsWithMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: `PORTå·¥ä½œè¡¨Elementåˆ—å¿…é¡»ä»¥"MBG"ç»“å°¾ï¼Œå®é™…ä¸º"${elementNameValue}"`,
                        elementNameValue: elementNameValue,
                        portTypeValue: portTypeValue,
                        endsWithMBG: false,
                        contentMatch: false
                    };
                }
                
                // æ£€æŸ¥2: PORTTYPEå†…å®¹ä¸åŸºå‡†è¡¨åŒ¹é…
                const contentMatch = portTypeValue === baselineStr;
                
                const isMatch = endsWithMBG && contentMatch;
                
                let message = '';
                if (isMatch) {
                    message = 'Portæ£€éªŒé€šè¿‡ï¼šElementåˆ—ä»¥MBGç»“å°¾ä¸”PORTTYPEä¸åŸºå‡†å€¼åŒ¹é…';
                } else if (!contentMatch) {
                    message = `Portæ£€éªŒå¤±è´¥ï¼šPORTTYPEä¸åŒ¹é…ï¼ŒåŸºå‡†å€¼"${baselineStr}" â‰  æµ‹è¯•å€¼"${portTypeValue}"`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    elementNameValue: elementNameValue,
                    portTypeValue: portTypeValue,
                    endsWithMBG: endsWithMBG,
                    contentMatch: contentMatch,
                    portCells: `Elementåˆ— (${elementNameCol}2): ${elementNameValue}, PORTTYPE (${portTypeCol}2): ${portTypeValue}`
                };
                
            } catch (error) {
                return { isValid: false, message: `Portæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // Coloræ£€éªŒå‡½æ•°
        function checkColor(baselineValue, sheetPP) {
            try {
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘åŸºå‡†Coloræ•°æ®' };
                }
                
                if (!sheetPP) {
                    return { isValid: false, message: 'æœªæ‰¾åˆ°PPå·¥ä½œè¡¨' };
                }
                
                const baselineColorValue = String(baselineValue).trim();
                
                // 1. æŸ¥æ‰¾æ‰€æœ‰PPè¡Œï¼ˆä»ç¬¬2è¡Œå¼€å§‹ï¼Œè·³è¿‡æ ‡é¢˜è¡Œï¼‰
                const ppRows = [];
                for (let row = 2; row <= 50; row++) {
                    const bCell = sheetPP[`B${row}`]; // Element Descåˆ—
                    if (!bCell || !bCell.v) continue;
                    
                    const desc = String(bCell.v);
                    const descLower = desc.toLowerCase();
                    
                    // åœ¨PPå·¥ä½œè¡¨ä¸­ï¼Œæœ‰Element Descçš„è¡Œå°±æ˜¯PPæ•°æ®è¡Œ
                    // æ£€æŸ¥æ˜¯å¦åŒ…å«MBGï¼ˆMotorola Business Groupæ ‡è¯†ï¼‰æ¥ç¡®è®¤æ˜¯æœ‰æ•ˆçš„PPè¡Œ
                    if (descLower.includes('mbg')) {
                        const tCell = sheetPP[`T${row}`]; // PKG_COLORåˆ—
                        const colorValue = tCell ? String(tCell.v || '').trim() : '';
                        
                        // åˆ¤æ–­æ˜¯Openã€Closedè¿˜æ˜¯Standard
                        let state = 'Standard';
                        if (descLower.includes('open')) {
                            state = 'Open';
                        } else if (descLower.includes('closed') || descLower.includes('close')) {
                            state = 'Closed';
                        }
                        
                        ppRows.push({
                            row: row,
                            state: state,
                            desc: desc.substring(0, 60) + (desc.length > 60 ? '...' : ''), // æˆªæ–­å¤ªé•¿çš„æè¿°
                            color: colorValue
                        });
                    }
                }
                
                if (ppRows.length === 0) {
                    return { isValid: false, message: 'PPå·¥ä½œè¡¨ä¸­æœªæ‰¾åˆ°PPæ•°æ®ï¼ˆç¼ºå°‘åŒ…å«MBGçš„è¡Œï¼‰' };
                }
                
                console.log(`æ‰¾åˆ°${ppRows.length}ä¸ªPP:`, ppRows);
                
                // 2. æ£€æŸ¥æ¯ä¸ªPPçš„é¢œè‰²
                const results = [];
                let allMatch = true;
                
                for (const ppRow of ppRows) {
                    const isMatch = ppRow.color === baselineColorValue;
                    if (!isMatch) allMatch = false;
                    
                    results.push({
                        row: ppRow.row,
                        state: ppRow.state,
                        color: ppRow.color,
                        isMatch: isMatch
                    });
                }
                
                // 3. ç”Ÿæˆæ£€éªŒç»“æœæ¶ˆæ¯
                let message = '';
                let ppCellsInfo = '';
                
                if (allMatch) {
                    if (ppRows.length === 1) {
                        message = `Colorå®Œå…¨åŒ¹é…`;
                        ppCellsInfo = `T${ppRows[0].row}: ${ppRows[0].color}`;
                    } else {
                        message = `æ‰€æœ‰PPçš„Coloréƒ½åŒ¹é… (å…±${ppRows.length}ä¸ªPP)`;
                        ppCellsInfo = ppRows.map(p => `${p.state} (T${p.row}): ${p.color} âœ“`).join(', ');
                    }
                } else {
                    const failedPPs = results.filter(r => !r.isMatch);
                    const passedPPs = results.filter(r => r.isMatch);
                    
                    message = `éƒ¨åˆ†PPçš„Colorä¸åŒ¹é…:\n`;
                    message += `  âœ“ é€šè¿‡ (${passedPPs.length}ä¸ª): ${passedPPs.map(p => p.state).join(', ')}\n`;
                    message += `  âœ— å¤±è´¥ (${failedPPs.length}ä¸ª):\n`;
                    failedPPs.forEach(pp => {
                        message += `    - ${pp.state} (è¡Œ${pp.row}): "${pp.color}" â‰  "${baselineColorValue}"\n`;
                    });
                    
                    ppCellsInfo = ppRows.map(p => {
                        const status = p.color === baselineColorValue ? 'âœ“' : 'âœ—';
                        return `${status} ${p.state} (T${p.row}): ${p.color}`;
                    }).join(', ');
                }
                
                return {
                    isValid: true,
                    isMatch: allMatch,
                    message: message,
                    baselineValue: baselineColorValue,
                    ppRows: results,
                    ppCells: ppCellsInfo
                };
                
            } catch (error) {
                console.error('Coloræ£€éªŒé”™è¯¯:', error);
                return { isValid: false, message: `Coloræ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        // What's in the boxæ£€éªŒå‡½æ•°
        function checkWhatsInTheBox(baselineValue, testValue) {
            try {
                // æ£€æŸ¥åŸºå‡†å€¼æ˜¯å¦å­˜åœ¨
                if (!baselineValue) {
                    return { isValid: false, message: 'ç¼ºå°‘What\'s in the boxåŸºå‡†æ•°æ®' };
                }
                
                const baselineStr = String(baselineValue).trim();
                const testStr = testValue ? String(testValue).trim() : '';
                
                console.log('What\'s in the boxæ£€éªŒ:');
                console.log('åŸºå‡†å€¼:', baselineStr);
                console.log('æµ‹è¯•å€¼:', testStr || '(ç©º)');
                
                // ã€æ–°å¢ã€‘ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœåŸºå‡†å€¼åªåŒ…å«"No"ä¸”æ²¡æœ‰é€—å·ï¼Œæµ‹è¯•å€¼ä¸ºç©ºæ˜¯åˆç†çš„
                const baselineUpper = baselineStr.toUpperCase();
                const hasNoInBaseline = baselineUpper.includes('NO');
                const hasComma = baselineStr.includes(',');
                
                if (hasNoInBaseline && !hasComma && !testStr) {
                    // åŸºå‡†å€¼çº¯ç²¹æ˜¯"No xxx"ï¼Œæµ‹è¯•å€¼ä¸ºç©º = åŒ¹é…æˆåŠŸ
                    console.log('åŸºå‡†å€¼è¦æ±‚æ— å†…å®¹ï¼Œæµ‹è¯•å€¼ä¸ºç©ºï¼Œåˆ¤å®šä¸ºåŒ¹é…æˆåŠŸ');
                    return {
                        isValid: true,
                        isMatch: true,
                        message: 'åŸºå‡†å€¼è¦æ±‚æ— å†…å®¹ï¼Œæµ‹è¯•å€¼ä¸ºç©ºï¼ŒåŒ¹é…æˆåŠŸ',
                        hasNoInBaseline: true,
                        noItemsPart: baselineStr,
                        positiveItemsPart: '',
                        noItemsViolation: false,
                        positiveItemsMatch: true,
                        hasMBG: false,
                        baselineValue: baselineStr,
                        testValue: testStr || '(ç©º)'
                    };
                }
                
                // å¯¹äºå…¶ä»–æƒ…å†µï¼Œæµ‹è¯•å€¼ä¸èƒ½ä¸ºç©º
                if (!testValue) {
                    return { isValid: false, message: 'ç¼ºå°‘What\'s in the boxæµ‹è¯•æ•°æ®' };
                }
                
                // 1. é¦–å…ˆæ£€æŸ¥æµ‹è¯•è¡¨å†…å®¹æ˜¯å¦åŒ…å« "MBG"
                const hasMBG = testStr.toUpperCase().includes('MBG');
                if (!hasMBG) {
                    return {
                        isValid: true,
                        isMatch: false,
                        message: 'æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"',
                        baselineTokens: [],
                        testTokens: [],
                        hasMBG: false
                    };
                }
                
                // 2. æ£€æŸ¥åŸºå‡†å€¼æ˜¯å¦åŒ…å«"No"ï¼Œå¦‚æœåŒ…å«åˆ™è¿›è¡Œç‰¹æ®Šå¤„ç†
                let processedBaselineStr = baselineStr;
                let shouldCheckNoItems = false;
                let noItemsPart = '';
                let positiveItemsPart = '';
                
                if (hasNoInBaseline) {
                    console.log('åŸºå‡†å€¼åŒ…å«"No"ï¼Œè¿›è¡Œç‰¹æ®Šå¤„ç†');
                    
                    // æŸ¥æ‰¾é€—å·åˆ†éš”ç¬¦
                    const commaIndex = baselineStr.indexOf(',');
                    if (commaIndex !== -1) {
                        // åˆ†å‰²ä¸ºNoéƒ¨åˆ†å’Œæ­£é¢éƒ¨åˆ†
                        noItemsPart = baselineStr.substring(0, commaIndex).trim();
                        positiveItemsPart = baselineStr.substring(commaIndex + 1).trim();
                        
                        console.log('Noéƒ¨åˆ†:', noItemsPart);
                        console.log('æ­£é¢éƒ¨åˆ†:', positiveItemsPart);
                        
                        // ä½¿ç”¨æ­£é¢éƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒ
                        processedBaselineStr = positiveItemsPart;
                        shouldCheckNoItems = true;
                    } else {
                        // æ²¡æœ‰é€—å·ï¼Œæ•´ä¸ªéƒ½æ˜¯Noéƒ¨åˆ†
                        noItemsPart = baselineStr;
                        positiveItemsPart = '';
                        processedBaselineStr = '';
                        shouldCheckNoItems = true;
                        
                        console.log('æ•´ä¸ªåŸºå‡†å€¼éƒ½æ˜¯Noéƒ¨åˆ†ï¼Œæ— æ­£é¢å†…å®¹');
                    }
                }
                
                console.log('å¤„ç†åçš„åŸºå‡†å€¼:', processedBaselineStr);
                
                // 2.5. æå–å’Œæ¸…ç†tokençš„å‡½æ•°
                function extractAndCleanTokens(text, removeMBG = false) {
                    let cleanedText = text;
                    
                    // å¦‚æœéœ€è¦ï¼Œç§»é™¤MBG
                    if (removeMBG) {
                        cleanedText = cleanedText.replace(/\bMBG\b/gi, '');
                    }
                    
                    // éœ€è¦å¿½ç•¥çš„å¸¸è§è¿æ¥è¯å’Œä»‹è¯
                    const stopWords = [
                        'and', 'or', 'with', 'without', 'the', 'a', 'an', 
                        'in', 'on', 'at', 'for', 'of', 'to', 'from',
                        '&', '+', ',', '-'
                    ];
                    
                    // åˆ†å‰²ä¸ºtokenså¹¶æ¸…ç†
                    const tokens = cleanedText
                        .split(/\s+/)
                        .map(token => {
                            // ç§»é™¤æ ‡ç‚¹ç¬¦å·
                            const cleaned = token.replace(/[^\w]/g, '').trim();
                            return cleaned.toLowerCase();
                        })
                        .filter(token => token.length > 0)
                        .filter(token => !stopWords.includes(token)); // è¿‡æ»¤åœç”¨è¯
                    
                    console.log('åŸå§‹æ–‡æœ¬:', text);
                    console.log('æ¸…ç†åçš„tokens:', tokens);
                    return tokens;
                }
                
                // 3. å¦‚æœéœ€è¦æ£€æŸ¥Noé¡¹ç›®ï¼ŒéªŒè¯æµ‹è¯•å€¼ä¸­ä¸åº”åŒ…å«Noéƒ¨åˆ†çš„å…³é”®è¯
                let noItemsViolation = false;
                let noItemsViolationDetails = '';
                
                if (shouldCheckNoItems && noItemsPart) {
                    // æå–Noéƒ¨åˆ†çš„å…³é”®è¯ï¼ˆæ’é™¤"No"æœ¬èº«ï¼‰
                    const noItemsTokens = extractAndCleanTokens(noItemsPart, false)
                        .filter(token => token.toLowerCase() !== 'no');
                    
                    console.log('Noéƒ¨åˆ†çš„å…³é”®è¯:', noItemsTokens);
                    
                    // æ£€æŸ¥æµ‹è¯•å€¼ä¸­æ˜¯å¦åŒ…å«è¿™äº›ä¸åº”è¯¥å‡ºç°çš„å…³é”®è¯
                    const testTokensForNoCheck = extractAndCleanTokens(testStr, true); // ç§»é™¤MBG
                    const foundNoItems = noItemsTokens.filter(token => 
                        testTokensForNoCheck.some(testToken => 
                            testToken.includes(token) || token.includes(testToken)
                        )
                    );
                    
                    if (foundNoItems.length > 0) {
                        noItemsViolation = true;
                        noItemsViolationDetails = `æµ‹è¯•å€¼ä¸­ä¸åº”åŒ…å«ä»¥ä¸‹é¡¹ç›®: ${foundNoItems.join(', ')}`;
                        console.log('å‘ç°è¿è§„é¡¹ç›®:', foundNoItems);
                    }
                }
                
                // 4. å¤„ç†æ­£é¢éƒ¨åˆ†çš„åŒ¹é…ï¼ˆå¦‚æœæœ‰ï¼‰
                let positiveItemsMatch = true;
                let positiveMatchDetails = '';
                
                if (processedBaselineStr) {
                    // æå–æ­£é¢éƒ¨åˆ†çš„tokens
                    const baselineTokens = extractAndCleanTokens(processedBaselineStr, false);
                    const testTokens = extractAndCleanTokens(testStr, true); // ç§»é™¤MBG
                    
                    console.log('æ­£é¢éƒ¨åˆ†åŸºå‡†tokens:', baselineTokens);
                    console.log('æµ‹è¯•tokens (ç§»é™¤MBGå):', testTokens);
                    
                    // è¿›è¡Œæ¨¡ç³ŠåŒ¹é…ï¼šæ£€æŸ¥åŸºå‡†ä¸­çš„æ¯ä¸ªtokenæ˜¯å¦åœ¨æµ‹è¯•å€¼ä¸­å­˜åœ¨
                    const missingTokens = baselineTokens.filter(baseToken => 
                        !testTokens.some(testToken => 
                            testToken.includes(baseToken) || baseToken.includes(testToken)
                        )
                    );
                    
                    positiveItemsMatch = missingTokens.length === 0;
                    
                    if (!positiveItemsMatch) {
                        positiveMatchDetails = `ç¼ºå°‘å…³é”®è¯: ${missingTokens.join(', ')}`;
                    }
                } else {
                    // å¦‚æœæ²¡æœ‰æ­£é¢éƒ¨åˆ†ï¼Œåˆ™è®¤ä¸ºæ­£é¢åŒ¹é…æˆåŠŸ
                    positiveMatchDetails = 'æ— éœ€æ£€æŸ¥æ­£é¢å†…å®¹';
                }
                
                // 5. ç”Ÿæˆæœ€ç»ˆç»“æœ
                const isMatch = hasMBG && !noItemsViolation && positiveItemsMatch;
                
                let message = '';
                if (isMatch) {
                    if (hasNoInBaseline) {
                        message = `What's in the boxåŒ¹é…æˆåŠŸï¼šåŒ…å«MBGï¼Œæœªå‘ç°ç¦æ­¢é¡¹ç›®${positiveItemsPart ? 'ï¼Œæ­£é¢å†…å®¹åŒ¹é…' : ''}`;
                    } else {
                        message = 'What\'s in the boxå®Œå…¨åŒ¹é…ï¼šåŒ…å«MBGä¸”å…³é”®è¯ç›¸åŒï¼ˆå·²å¿½ç•¥è¿æ¥è¯å¦‚andã€withç­‰ï¼‰';
                    }
                } else {
                    let issues = [];
                    if (!hasMBG) issues.push('æµ‹è¯•è¡¨å†…å®¹å¿…é¡»åŒ…å«"MBG"');
                    if (noItemsViolation) issues.push(noItemsViolationDetails);
                    if (!positiveItemsMatch && positiveMatchDetails) issues.push(positiveMatchDetails);
                    message = `What's in the boxéªŒè¯å¤±è´¥: ${issues.join('; ')}`;
                }
                
                return {
                    isValid: true,
                    isMatch: isMatch,
                    message: message,
                    hasNoInBaseline: hasNoInBaseline,
                    noItemsPart: noItemsPart,
                    positiveItemsPart: positiveItemsPart,
                    noItemsViolation: noItemsViolation,
                    noItemsViolationDetails: noItemsViolationDetails,
                    positiveItemsMatch: positiveItemsMatch,
                    positiveMatchDetails: positiveMatchDetails,
                    hasMBG: hasMBG,
                    baselineValue: baselineStr,
                    testValue: testStr
                };
                
            } catch (error) {
                return { isValid: false, message: `What's in the boxæ£€éªŒé”™è¯¯: ${error.message}` };
            }
        }

        function displayTechResultsMultiple(allProductResults) {
            const resultsDiv = document.getElementById('techResults');
            const productNameSpan = document.getElementById('productName');
            const checkResultsDiv = document.getElementById('techCheckResults');
            const summaryDiv = document.getElementById('techSummary');
            
            // æ˜¾ç¤ºäº§å“æ€»æ•°
            productNameSpan.textContent = `å…± ${allProductResults.length} ä¸ªäº§å“`;
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
            checkResultsDiv.innerHTML = '';
            
            const totalInfoDiv = document.createElement('div');
            totalInfoDiv.style.cssText = `
                background-color: #e3f2fd;
                border: 2px solid #2196f3;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 25px;
                font-size: 16px;
                font-weight: bold;
            `;
            totalInfoDiv.innerHTML = `
                <div style="text-align: center;">
                    å…±æ£€éªŒ <span style="color: #2196f3; font-size: 20px;">${allProductResults.length}</span> ä¸ªäº§å“çš„æŠ€æœ¯è§„æ ¼
                </div>
            `;
            checkResultsDiv.appendChild(totalInfoDiv);
            
            let totalMatchedCount = 0;
            let totalUnmatchedCount = 0;
            
            // æ˜¾ç¤ºæ¯ä¸ªäº§å“çš„æ£€éªŒç»“æœ
            allProductResults.forEach((productResult, productIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.style.cssText = `
                    margin-bottom: 30px;
                    border: 2px solid #667eea;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
                `;
                
                let matchedCount = 0;
                let unmatchedCount = 0;
                
                productResult.matchResults.forEach(result => {
                    if (result.checkResult) {
                        if (result.checkResult.isMatch === true) {
                            matchedCount++;
                        } else if (result.checkResult.isMatch === false) {
                            unmatchedCount++;
                        } else {
                            matchedCount++; // æ‰‹åŠ¨æ£€éªŒä¹Ÿç®—é€šè¿‡
                        }
                    } else {
                        if (result.isMatched) {
                            matchedCount++;
                        } else {
                            unmatchedCount++;
                        }
                    }
                });
                
                totalMatchedCount += matchedCount;
                totalUnmatchedCount += unmatchedCount;
                
                const totalCount = matchedCount + unmatchedCount;
                const passRate = totalCount > 0 ? ((matchedCount / totalCount) * 100).toFixed(1) : 0;
                
                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = `
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    margin-bottom: 15px;
                    font-weight: bold;
                    font-size: 1.1rem;
                `;
                
                headerDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 1.2rem;">ğŸ“¦ äº§å“ ${productIndex + 1}: ${productResult.partNumber}</span>
                            <br>
                            <small style="opacity: 0.9;">${productResult.productName}</small>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.2); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem;">
                            é€šè¿‡ç‡: ${passRate}%
                        </div>
                    </div>
                `;
                
                groupDiv.appendChild(headerDiv);
                
                const checksContainer = document.createElement('div');
                checksContainer.style.cssText = `
                    margin-top: 15px;
                `;
                
                // æ˜¾ç¤ºæ¯é¡¹è§„æ ¼å¯¹æ¯”ç»“æœ
                productResult.matchResults.forEach(result => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'check-item';
                    itemDiv.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        padding: 15px 20px;
                        margin: 10px 0;
                        background: white;
                        border-radius: 10px;
                        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
                        transition: all 0.3s ease;
                    `;
                    
                    let statusClass = result.isMatched ? 'pass' : 'fail';
                    let statusText = result.isMatched ? 'å·²åŒ¹é…' : 'æœªåŒ¹é…';
                    
                    // å¤„ç†ç‰¹æ®Šæ£€éªŒç»“æœ
                    let extraInfo = '';
                    if (result.checkResult) {
                        const checkResult = result.checkResult;
                        if (checkResult.isValid) {
                            if (checkResult.isMatch === true) {
                                statusClass = 'pass';
                                statusText = 'PASS';
                                extraInfo = `<br><small style="color: #28a745;">âœ“ ${checkResult.message}</small>`;
                            } else if (checkResult.isMatch === false) {
                                statusClass = 'fail';
                                statusText = 'FAIL';
                                extraInfo = `<br><small style="color: #dc3545;">âœ— ${checkResult.message}</small>`;
                            } else {
                                statusClass = 'pass';
                                statusText = 'éœ€æ‰‹åŠ¨æ£€éªŒ';
                                extraInfo = `<br><small style="color: #ffc107;">âš  ${checkResult.message}</small>`;
                            }
                            
                            // æ·»åŠ è½¬æ¢åçš„å€¼ä¿¡æ¯
                            if (checkResult.convertedValue) {
                                extraInfo += `<br><small style="color: #666;">è½¬æ¢å€¼: ${checkResult.convertedValue}kg</small>`;
                            }
                            if (checkResult.convertedValues) {
                                const cv = checkResult.convertedValues;
                                extraInfo += `<br><small style="color: #666;">è½¬æ¢å€¼: é•¿=${cv.length}mm, å®½=${cv.width}mm, åš=${cv.thickness}mm</small>`;
                            }
                            if (checkResult.ppCells) {
                                extraInfo += `<br><small style="color: #007bff;">PPå·¥ä½œè¡¨: ${checkResult.ppCells}</small>`;
                            }
                            
                            // // æ·»åŠ Processoræ£€éªŒçš„è¯¦ç»†ä¿¡æ¯
                            // if (checkResult.detailMessage) {
                            //     extraInfo += `<br><small style="color: #666;">è¯¦ç»†ä¿¡æ¯: ${checkResult.detailMessage}</small>`;
                            // }
                        } else {
                            statusClass = 'fail';
                            statusText = 'ERROR';
                            extraInfo = `<br><small style="color: #dc3545;">âœ— ${checkResult.message}</small>`;
                        }
                    }
                    
                    itemDiv.innerHTML = `
                        <div class="item-name" style="font-weight: bold; color: #333; flex: 1;">
                            ${result.attribute}<br>
                            <small style="color: #666;">(${result.abbreviation})</small>
                        </div>
                        <div class="item-values" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #666; margin: 0 20px; text-align: center; flex: 2;">
                            åŸºå‡†(${result.baselineCell}): ${result.baselineValue || '(ç©º)'}<br>
                            æµ‹è¯•(${result.testCell}): ${result.testValue || '(ç©º)'}${extraInfo}
                        </div>
                        <div class="status ${statusClass}" style="padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9rem;">${statusText}</div>
                    `;
                    
                    checksContainer.appendChild(itemDiv);
                });
                
                groupDiv.appendChild(checksContainer);
                checkResultsDiv.appendChild(groupDiv);
            });
            
            // æ˜¾ç¤ºæ±‡æ€»ä¿¡æ¯
            const totalCount = totalMatchedCount + totalUnmatchedCount;
            const totalPassRate = totalCount > 0 ? ((totalMatchedCount / totalCount) * 100).toFixed(1) : 0;
            
            const successfulProducts = allProductResults.filter(p => {
                const total = p.matchResults.length;
                const passed = p.matchResults.filter(r => {
                    if (r.checkResult) {
                        return r.checkResult.isMatch === true || r.checkResult.isMatch === undefined;
                    }
                    return r.isMatched;
                }).length;
                return passed === total;
            }).length;
            
            const partialProducts = allProductResults.length - successfulProducts;
            
            summaryDiv.innerHTML = `
                <h4>æ€»ä½“æ£€éªŒæ±‡æ€»</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-number" style="color: #2196f3;">${allProductResults.length}</span>
                        <div class="stat-label">æ€»äº§å“æ•°</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #28a745;">${successfulProducts}</span>
                        <div class="stat-label">å®Œå…¨é€šè¿‡</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-number" style="color: #ffc107;">${partialProducts}</span>
                        <div class="stat-label">éƒ¨åˆ†é€šè¿‡</div>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-number pass">${totalMatchedCount}</span>
                            <div class="stat-label">æ€»é€šè¿‡é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number fail">${totalUnmatchedCount}</span>
                            <div class="stat-label">æ€»å¤±è´¥é¡¹ç›®</div>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number" style="color: #667eea;">${totalPassRate}%</span>
                            <div class="stat-label">æ€»é€šè¿‡ç‡</div>
                        </div>
                    </div>
                </div>
            `;
            
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }
        
    </script>
</body>
</html>